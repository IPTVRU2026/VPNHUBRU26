name: ICEBREAKER ‚Äî Global Stealth Aggregator & Auto-Publisher

on:
  schedule:
    - cron: '0 * * * *' # –ö–∞–∂–¥—ã–π —á–∞—Å
  workflow_dispatch: # –†—É—á–Ω–æ–µ –∑–∞–ø—É—Å–∫

env:
  TELEGRAM_API_ID: 38922115
  TELEGRAM_API_HASH: b34ae241317eff8743f538a8272c5f6d
  DC_ID: 2
  DC_IP: 149.154.167.50
  DC_PORT: 443
  GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

jobs:
  stealth_aggregator:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.10'

      - name: Install Dependencies
        run: |
          pip install telethon requests qrcode[pil] beautifulsoup4 pyyaml

      - name: Aggressive Infiltration (Telegram Bots, Gists, Pastebin, Reddit)
        run: |
          python3 - << 'EOF'
          import os
          import re
          import json
          import requests
          from telethon.sync import TelegramClient
          from telethon.tl.functions.messages import GetDialogsRequest
          from telethon.tl.types import InputPeerEmpty
          from bs4 import BeautifulSoup
          import qrcode
          import yaml

          # --- 1. Telegram Bots Infiltration ---
          def scrape_telegram_bots():
              client = TelegramClient('anon', env.TELEGRAM_API_ID, env.TELEGRAM_API_HASH)
              client.start()
              dials = client(GetDialogsRequest(offset_date=None, offset_id=0, offset_peer=InputPeerEmpty(), limit=200, hash=0))
              bot_links = []
              for chat in dials.chats:
                  if hasattr(chat, 'username') and 'bot' in chat.username.lower():
                      bot_links.append(f"https://t.me/{chat.username}")
              client.disconnect()
              return bot_links

          # --- 2. GitHub Gists, Pastebin, Reddit Crawler ---
          def crawl_external_sources():
              sources = {
                  "gists": "https://api.github.com/gists/public",
                  "pastebin": "https://pastebin.com/archive",
                  "reddit": "https://www.reddit.com/r/proxy/search.json?q=flair%3Aconfig&sort=new"
              }
              configs = []
              for name, url in sources.items():
                  try:
                      r = requests.get(url, timeout=10)
                      if name == "gists":
                          data = r.json()
                          for gist in data:
                              for file in gist['files'].values():
                                  if re.search(r'(vless|vmess|ss|trojan|tg://proxy)', file['content'], re.I):
                                      configs.append(file['content'])
                      elif name == "pastebin":
                          soup = BeautifulSoup(r.text, 'html.parser')
                          for link in soup.find_all('a', href=re.compile(r'/raw/')):
                              raw = requests.get(f"https://pastebin.com{link['href']}").text
                              if re.search(r'(vless|vmess|ss|trojan|tg://proxy)', raw, re.I):
                                  configs.append(raw)
                      elif name == "reddit":
                          data = r.json()
                          for post in data['data']['children']:
                              if re.search(r'(vless|vmess|ss|trojan|tg://proxy)', post['data']['selftext'], re.I):
                                  configs.append(post['data']['selftext'])
                  except Exception as e:
                      print(f"Error crawling {name}: {e}")
              return configs

          # --- 3. Universal Parser ---
          def parse_configs(raw_configs):
              parsed = {"telegram": [], "vpn": []}
              for config in raw_configs:
                  if re.search(r'tg://proxy|MTProto|Socks5', config, re.I):
                      parsed["telegram"].append(config)
                  elif re.search(r'vless|vmess|ss|trojan', config, re.I):
                      parsed["vpn"].append(config)
              return parsed

          # --- 4. Live Check (Speed/Ping) ---
          def check_configs(configs):
              # TODO: Implement real speed/ping check (e.g. using subprocess + curl)
              return configs  # Placeholder

          # --- 5. Generate QR Codes ---
          def generate_qr(config, filename):
              qr = qrcode.QRCode(version=1, box_size=10, border=5)
              qr.add_data(config)
              qr.make(fit=True)
              img = qr.make_image(fill_color="black", back_color="white")
              img.save(filename)

          # --- 6. Generate GitHub Pages Site ---
          def generate_site(telegram_configs, vpn_configs):
              os.makedirs("site", exist_ok=True)
              with open("site/index.html", "w") as f:
                  f.write("""
                  <!DOCTYPE html>
                  <html lang="ru">
                  <head>
                      <meta charset="UTF-8">
                      <meta name="viewport" content="width=device-width, initial-scale=1.0">
                      <title>ICEBREAKER ‚Äî –°–≤–µ–∂–∏–µ –∫–æ–Ω—Ñ–∏–≥–∏</title>
                      <style>
                          body { background: #121212; color: #e0e0e0; font-family: Arial, sans-serif; }
                          .container { max-width: 1000px; margin: 0 auto; padding: 20px; }
                          .card { background: #1e1e1e; border-radius: 8px; padding: 15px; margin: 10px 0; }
                          .qr { margin: 10px; }
                          button { background: #4CAF50; color: white; border: none; padding: 10px 15px; border-radius: 4px; cursor: pointer; }
                          a { color: #2196F3; }
                      </style>
                  </head>
                  <body>
                      <div class="container">
                          <h1>üåç ICEBREAKER ‚Äî –°–≤–µ–∂–∏–µ –∫–æ–Ω—Ñ–∏–≥–∏</h1>
                          <div class="card">
                              <h2>üì± Telegram Proxy (MTProto/Socks5)</h2>
                              {% for config in telegram_configs %}
                              <div>
                                  <pre>{{config}}</pre>
                                  <img class="qr" src="qr/telegram_{{loop.index}}.png" width="150">
                                  <button onclick="navigator.clipboard.writeText('{{config}}')">Copy</button>
                              </div>
                              {% endfor %}
                          </div>
                          <div class="card">
                              <h2>üîí VPN (VLESS/VMESS/Shadowsocks/Trojan)</h2>
                              {% for config in vpn_configs %}
                              <div>
                                  <pre>{{config}}</pre>
                                  <img class="qr" src="qr/vpn_{{loop.index}}.png" width="150">
                                  <button onclick="navigator.clipboard.writeText('{{config}}')">Copy</button>
                              </div>
                              {% endfor %}
                          </div>
                          <div class="card">
                              <h2>üì± –ü—Ä–∏–ª–æ–∂–µ–Ω–∏—è</h2>
                              <p><a href="https://github.com/MatsuriDayo/nekoray">Nekobox (Android/Windows)</a></p>
                              <p><a href="https://apps.apple.com/us/app/v2box-v2ray-utility/id6446693134">V2BOX (iOS)</a></p>
                          </div>
                          <div class="card">
                              <h2>üìñ –ò–Ω—Å—Ç—Ä—É–∫—Ü–∏—è</h2>
                              <p>1. –í—ã–±–µ—Ä–∏—Ç–µ –∫–æ–Ω—Ñ–∏–≥.</p>
                              <p>2. –û—Ç—Å–∫–∞–Ω–∏—Ä—É–π—Ç–µ QR –∏–ª–∏ —Å–∫–æ–ø–∏—Ä—É–π—Ç–µ —Å—Å—ã–ª–∫—É.</p>
                              <p>3. –í—Å—Ç–∞–≤—å—Ç–µ –≤ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ.</p>
                          </div>
                      </div>
                  </body>
                  </html>
                  """.replace("{% for config in telegram_configs %}", "".join(f"<div><pre>{c}</pre><img class='qr' src='qr/telegram_{i}.png' width='150'><button onclick='navigator.clipboard.writeText(`{c}`)'>Copy</button></div>" for i, c in enumerate(telegram_configs)))
                   .replace("{% for config in vpn_configs %}", "".join(f"<div><pre>{c}</pre><img class='qr' src='qr/vpn_{i}.png' width='150'><button onclick='navigator.clipboard.writeText(`{c}`)'>Copy</button></div>" for i, c in enumerate(vpn_configs))))

          # --- MAIN ---
          if __name__ == "__main__":
              os.makedirs("qr", exist_ok=True)
              os.makedirs("output", exist_ok=True)

              # 1. Scrape
              bot_links = scrape_telegram_bots()
              raw_configs = crawl_external_sources()

              # 2. Parse & Check
              parsed = parse_configs(raw_configs)
              telegram_configs = check_configs(parsed["telegram"])
              vpn_configs = check_configs(parsed["vpn"])

              # 3. Generate QR
              for i, config in enumerate(telegram_configs):
                  generate_qr(config, f"qr/telegram_{i}.png")
              for i, config in enumerate(vpn_configs):
                  generate_qr(config, f"qr/vpn_{i}.png")

              # 4. Generate Site
              generate_site(telegram_configs, vpn_configs)

              # 5. Save to Files
              with open("output/telegram_proxies.txt", "w") as f:
                  f.write("\n\n".join(telegram_configs))
              with open("output/vpn_configs.json", "w") as f:
                  json.dump(vpn_configs, f, indent=2)
              with open("output/all_in_one.raw", "w") as f:
                  f.write("\n\n".join(telegram_configs + vpn_configs))

              # 6. Create Release
              os.system("git config --global user.name 'ICEBREAKER'")
              os.system("git config --global user.email 'icebreaker@noreply.github.com'")
              os.system("git add .")
              os.system("git commit -m 'Update configs'")
              os.system("git push")
              os.system("gh release create $(date +%Y-%m-%d) --title 'Update $(date +%d-%m-%Y)' --notes 'Auto-update' output/*")
          EOF

      - name: Deploy to GitHub Pages
        uses: peaceiris/actions-gh-pages@v3
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}
          publish_dir: ./site        run: |
          mkdir -p output/{telegram,vpn,simple_proxy,raw,qr} logs sessions site scripts manage

      - name: Create All Scripts
        run: |
          set -euo pipefail

          cat > scripts/bot_infiltrator.py << 'EOF'
#!/usr/bin/env python3
import asyncio
import random
import json
import re
import logging
from datetime import datetime
from telethon import TelegramClient
from telethon.errors import FloodWaitError
from telethon.tl.functions.messages import GetBotCallbackAnswerRequest
from telethon.tl.types import KeyboardButtonCallback, KeyboardButtonUrl
from cryptography.hazmat.primitives import serialization
from cryptography.hazmat.backends import default_backend

API_ID = 38922115
API_HASH = "b34ae241317eff8743f538a8272c5f6d"

PUBLIC_KEYS = [
    """-----BEGIN RSA PUBLIC KEY-----
MIIBCgKCAQEAyMEdY1aR+sCR3ZSJrtztKTKqigvO/vBfqACJLZtS7QMgCGXJ6XIR
yy7mx66W0/sOFa7/1mAZtEoIokDP3ShoqF4fVNb6XeqgQfaUHd8wJpDWHcR2OFwv
plUUI1PLTktZ9uW2WE23b+ixNwJjJGwBDJPQEQFBE+vfmH0JP503wr5INS1poWg/
j25sIWeYPHYeOrFp/eXaqhISP6G+q2IeTaWTXpwZj4LzXq5YOpk4bYEQ6mvRq7D1
aHWfYmlEGepfaYR8Q0YqvvhYtMte3ITnuSJs171+GDqpdKcSwHnd6FudwGO4pcCO
j4WcDuXc2CTHgH8gFTNhp/Y8/SpDOhvn9QIDAQAB
-----END RSA PUBLIC KEY-----""",
    """-----BEGIN RSA PUBLIC KEY-----
MIIBCgKCAQEA6LszBcC1LGzyr992NzE0ieY+BSaOW622Aa9Bd4ZHLl+TuFQ4lo4g
5nKaMBwK/BIb9xUfg0Q29/2mgIR6Zr9krM7HjuIcCzFvDtr+L0GQjae9H0pRB2OO
62cECs5HKhT5DZ98K33vmWiLowc621dQuwKWSQKjWf50XYFw42h21P2KXUGyp2y/
+aEyZ+uVgLLQbRA1dEjSDZ2iGRy12Mk5gpYc397aYp438fsJoHIgJ2lgMv5h7WY9
t6N/byY9Nw9p21Og3AoXSL2q/2IJ1WRUhebgAdGVMlV1fkuOQoEzR7EdpqtQD9Cs
5+bfo3Nhmcyvk5ftB0WkJ9z6bNZ7yxrP8wIDAQAB
-----END RSA PUBLIC KEY-----"""
]

DC_CONFIG = "149.154.167.50:443 DC 2"

BOT_SEARCH_KEYWORDS = [
    "proxy bot", "mtproto bot", "socks5 bot", "v2ray bot", "vmess bot", "free vpn bot",
    "telegram proxy bot", "free proxy bot 2026", "vless bot", "trojan bot", "shadowsocks bot"
]

CONFIG_PATTERNS = {
    'tg_proxy': re.compile(r'(tg://proxy\?[^\s]+)'),
    'vless': re.compile(r'(vless://[^\s]+)'),
    'vmess': re.compile(r'(vmess://[^\s]+)'),
    'ss': re.compile(r'(ss://[^\s]+)'),
    'trojan': re.compile(r'(trojan://[^\s]+)'),
    'socks': re.compile(r'(socks5?://[^\s]+)'),
}

logging.basicConfig(level=logging.INFO, format='%(asctime)s %(levelname)s %(message)s')
logger = logging.getLogger(__name__)

class StealthBotInfiltrator:
    def __init__(self):
        self.client = TelegramClient("sessions/icebreaker", API_ID, API_HASH)
        self.configs = {'telegram': [], 'vpn': [], 'simple_proxy': [], 'raw': []}

    async def safe_sleep(self, sec_range=(1, 5)):
        await asyncio.sleep(random.uniform(*sec_range))

    def extract_configs(self, text, source, method):
        for typ, pat in CONFIG_PATTERNS.items():
            for match in pat.findall(text):
                data = {
                    'config': match.strip(),
                    'type': typ,
                    'source': source,
                    'method': method,
                    'time': datetime.utcnow().isoformat() + "Z"
                }
                if data not in self.configs['raw']:
                    self.configs['raw'].append(data)
                    if typ == 'tg_proxy':
                        if data not in self.configs['telegram']:
                            self.configs['telegram'].append(data)
                            logger.info(f"TG Proxy: {match[:60]}...")
                    elif typ == 'socks':
                        if data not in self.configs['simple_proxy']:
                            self.configs['simple_proxy'].append(data)
                            logger.info(f"Simple Proxy: {match[:60]}...")
                    else:
                        if data not in self.configs['vpn']:
                            self.configs['vpn'].append(data)
                            logger.info(f"VPN Config: {match[:60]}...")

    async def discover_bots(self):
        bots = []
        for keyword in BOT_SEARCH_KEYWORDS:
            try:
                results = await self.client.iter_dialogs(search=keyword, limit=50)
                for dialog in results:
                    if dialog.is_bot:
                        bot_username = dialog.entity.username
                        if bot_username and bot_username.startswith('@') and bot_username not in bots:
                            bots.append(bot_username)
                            logger.info(f"Discovered bot: {bot_username} via {keyword}")
                await self.safe_sleep((5, 10))
            except FloodWaitError as e:
                await asyncio.sleep(e.seconds)
        return bots[:20]

    async def strategy_direct(self, bot):
        try:
            await self.client.send_message(bot, '/start')
            await self.safe_sleep()
            messages = await self.client.get_messages(bot, limit=50)
            for msg in messages:
                if msg.text:
                    self.extract_configs(msg.text, bot, "direct")
        except FloodWaitError as e:
            await asyncio.sleep(e.seconds)

    async def strategy_buttons(self, bot):
        try:
            messages = await self.client.get_messages(bot, limit=20)
            for msg in messages:
                if msg.reply_markup:
                    for row in msg.reply_markup.rows:
                        for btn in row.buttons:
                            if isinstance(btn, KeyboardButtonCallback):
                                await self.client(GetBotCallbackAnswerRequest(peer=bot, msg_id=msg.id, data=btn.data))
                                await self.safe_sleep()
                                new_msgs = await self.client.get_messages(bot, limit=5)
                                for n in new_msgs:
                                    if n.text:
                                        self.extract_configs(n.text, bot, "button")
        except Exception:
            pass

    async def strategy_commands(self, bot):
        commands = ['/free', '/trial', '/config', '/proxy', '/vpn', '/get', '/list', '/help']
        for cmd in random.sample(commands, min(4, len(commands))):
            await self.client.send_message(bot, cmd)
            await self.safe_sleep()
            messages = await self.client.get_messages(bot, limit=10)
            for msg in messages:
                if msg.text:
                    self.extract_configs(msg.text, bot, f"command_{cmd}")

    async def strategy_history(self, bot):
        messages = await self.client.get_messages(bot, limit=200)
        for msg in messages:
            if msg.text:
                self.extract_configs(msg.text, bot, "history")

    async def strategy_urls(self, bot):
        messages = await self.client.get_messages(bot, limit=50)
        for msg in messages:
            if msg.reply_markup:
                for row in msg.reply_markup.rows:
                    for btn in row.buttons:
                        if isinstance(btn, KeyboardButtonUrl):
                            self.extract_configs(btn.url, bot, "url_button")

    async def strategy_invite(self, bot):
        messages = await self.client.get_messages(bot, limit=50)
        for msg in messages:
            if msg.text:
                invite = re.search(r'(t\.me/[^\s]+)', msg.text)
                if invite:
                    logger.info(f"Invite found: {invite.group(1)} - skipping for stealth")

    async def strategy_typing(self, bot):
        await self.client.send_typing(bot)
        await self.safe_sleep()
        await self.client.send_message(bot, random.choice(["Need free proxy?", "Free VPN config?", "Trial please"]))
        messages = await self.client.get_messages(bot, limit=5)
        for msg in messages:
            if msg.text:
                self.extract_configs(msg.text, bot, "typing")

    async def strategy_retry(self, bot, sub_strategy):
        for attempt in range(3):
            try:
                await sub_strategy(bot)
                return
            except FloodWaitError as e:
                await asyncio.sleep(e.seconds + random.uniform(5, 10))

    async def strategy_media(self, bot):
        messages = await self.client.get_messages(bot, limit=100)
        for msg in messages:
            if msg.media and msg.message:
                self.extract_configs(msg.message, bot, "media_caption")

    async def strategy_profile(self, bot):
        await self.client(UpdateProfileRequest(about="Seeking free proxies"))
        await self.safe_sleep()
        await self.client.send_message(bot, "Hi, any free configs?")
        messages = await self.client.get_messages(bot, limit=10)
        for msg in messages:
            if msg.text:
                self.extract_configs(msg.text, bot, "profile")
        await self.client(UpdateProfileRequest(about=""))

    async def strategy_bypass(self, bot):
        await self.client.send_message(bot, '/pay' if random.random() > 0.5 else '/free')
        await self.safe_sleep()
        messages = await self.client.get_messages(bot, limit=20)
        for msg in messages:
            if 'script' in msg.text.lower() or 'link' in msg.text.lower():
                self.extract_configs(msg.text, bot, "bypass")

    async def full_attack(self, bot):
        strategies = [
            self.strategy_direct,
            self.strategy_buttons,
            self.strategy_commands,
            self.strategy_history,
            self.strategy_urls,
            self.strategy_invite,
            self.strategy_typing,
            lambda b: self.strategy_retry(b, self.strategy_direct),
            self.strategy_media,
            self.strategy_profile,
            self.strategy_bypass
        ]
        random.shuffle(strategies)
        for strat in strategies:
            try:
                await strat(bot)
                await self.safe_sleep((3, 8))
            except Exception as e:
                logger.debug(f"Strategy error: {e}")

    async def run(self):
        await self.client.connect()
        if not await self.client.is_user_authorized():
            logger.error("Session not authorized - run manually first")
            return

        discovered_bots = await self.discover_bots()
        if not discovered_bots:
            logger.warning("No bots discovered - using fallback")
            discovered_bots = ["@MTProtoProxybot", "@ProxyMTProtoBot", "@socks5_bot"]

        for bot_name in discovered_bots:
            try:
                bot = await self.client.get_entity(bot_name)
                await self.full_attack(bot)
                await self.safe_sleep((10, 20))
            except Exception as e:
                logger.error(f"Error with {bot_name}: {e}")

        await self.client.disconnect()

        with open('output/telegram/from_bots.txt', 'w', encoding='utf-8') as f:
            for c in self.configs['telegram']:
                f.write(c['config'] + '\n')
        with open('output/vpn/from_bots.json', 'w', encoding='utf-8') as f:
            json.dump(self.configs['vpn'], f, ensure_ascii=False, indent=2)
        with open('output/simple_proxy/from_bots.txt', 'w', encoding='utf-8') as f:
            for c in self.configs['simple_proxy']:
                f.write(c['config'] + '\n')

        logger.info(f"Dynamic run complete: TG {len(self.configs['telegram'])}, VPN {len(self.configs['vpn'])}, Simple {len(self.configs['simple_proxy'])}")

if __name__ == '__main__':
    asyncio.run(StealthBotInfiltrator().run())
EOF

          cat > scripts/tg_monitor.py << 'EOF'
#!/usr/bin/env python3
import asyncio
import json
import re
import logging
from datetime import datetime
from telethon import TelegramClient

API_ID = 38922115
API_HASH = "b34ae241317eff8743f538a8272c5f6d"

CHANNEL_SEARCH_KEYWORDS = [
    "free v2ray", "mtproto proxy", "socks5 proxy", "vpn free", "vless vmess",
    "telegram proxy channel 2026", "free vpn configs", "shadowsocks free", "trojan configs",
    "proxy list channel", "daily proxies", "v2ray free channel"
]

PATTERNS = {
    'tg_proxy': re.compile(r'tg://proxy\?[^\s]+'),
    'vless': re.compile(r'vless://[^\s]+'),
    'vmess': re.compile(r'vmess://[^\s]+'),
    'ss': re.compile(r'ss://[^\s]+'),
    'trojan': re.compile(r'trojan://[^\s]+'),
    'socks': re.compile(r'socks5?://[^\s]+'),
}

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

class DeepChannelMonitor:
    def __init__(self):
        self.client = TelegramClient("sessions/monitor", API_ID, API_HASH)
        self.configs = []

    async def discover_channels(self):
        channels = []
        for keyword in CHANNEL_SEARCH_KEYWORDS:
            try:
                results = await self.client.iter_dialogs(search=keyword, limit=100)
                for dialog in results:
                    if dialog.is_channel or dialog.is_group:
                        channel_username = dialog.entity.username
                        if channel_username and channel_username.startswith('@') and channel_username not in channels:
                            channels.append(channel_username)
                            logger.info(f"Discovered channel: {channel_username} via {keyword}")
                await asyncio.sleep(5)
            except FloodWaitError as e:
                await asyncio.sleep(e.seconds)
        return channels[:50]

    async def scan_channel(self, ch):
        try:
            entity = await self.client.get_entity(ch)
            messages = await self.client.get_messages(entity, limit=500)
            for msg in messages:
                if msg.text:
                    for typ, pat in PATTERNS.items():
                        for match in pat.findall(msg.text):
                            data = {'config': match, 'type': typ, 'source': ch, 'time': datetime.utcnow().isoformat() + "Z"}
                            if data not in self.configs:
                                self.configs.append(data)
                                logger.info(f"Found {typ} in {ch}")
                if msg.reply_markup:
                    for row in msg.reply_markup.rows:
                        for btn in row.buttons:
                            if isinstance(btn, KeyboardButtonUrl):
                                for typ, pat in PATTERNS.items():
                                    if pat.search(btn.url):
                                        data = {'config': btn.url, 'type': typ, 'source': ch, 'time': datetime.utcnow().isoformat() + "Z"}
                                        if data not in self.configs:
                                            self.configs.append(data)
        except Exception as e:
            logger.error(f"Scan {ch} failed: {e}")

    async def run(self):
        await self.client.connect()
        if not await self.client.is_user_authorized():
            logger.error("Not authorized")
            return

        discovered_channels = await self.discover_channels()
        if not discovered_channels:
            logger.warning("No channels discovered - using fallback")
            discovered_channels = ["@V2RayRootFree", "@vpnfail_v2ray", "@DR_V2ray", "@V2rayNG3", "@proxy_mtm", "@MTProxies", "@socks5_list"]

        for ch in discovered_channels:
            await self.scan_channel(ch)
            await asyncio.sleep(5)

        await self.client.disconnect()

        tg = [c for c in self.configs if c['type'] == 'tg_proxy']
        vpn = [c for c in self.configs if c['type'] in ['vless', 'vmess', 'ss', 'trojan']]
        simple = [c for c in self.configs if c['type'] == 'socks']

        with open('output/telegram/from_channels.txt', 'w', encoding='utf-8') as f:
            for c in tg: f.write(c['config'] + '\n')
        with open('output/vpn/from_channels.json', 'w', encoding='utf-8') as f:
            json.dump(vpn, f, ensure_ascii=False, indent=2)
        with open('output/simple_proxy/from_channels.txt', 'w', encoding='utf-8') as f:
            for c in simple: f.write(c['config'] + '\n')

        logger.info(f"Dynamic channel scan: TG {len(tg)}, VPN {len(vpn)}, Simple {len(simple)}")

if __name__ == '__main__':
    asyncio.run(DeepChannelMonitor().run())
EOF

          cat > scripts/web_crawler.py << 'EOF'
#!/usr/bin/env python3
import asyncio
import aiohttp
import re
import json
import logging
from datetime import datetime
from bs4 import BeautifulSoup
from urllib.parse import quote

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

PATTERNS = {
    'tg_proxy': re.compile(r'tg://proxy\?[^\s]+'),
    'vless': re.compile(r'vless://[^\s]+'),
    'vmess': re.compile(r'vmess://[^\s]+'),
    'ss': re.compile(r'ss://[^\s]+'),
    'trojan': re.compile(r'trojan://[^\s]+'),
    'socks': re.compile(r'socks5?://[^\s]+'),
}

RAW_URLS = [
    "https://raw.githubusercontent.com/barry-far/V2ray-Config/main/Sub.txt",
    "https://raw.githubusercontent.com/ebrasha/free-v2ray-public-list/main/all.txt",
    "https://raw.githubusercontent.com/V2RayRoot/V2RayConfig/main/all.txt",
    "https://raw.githubusercontent.com/MatinGhanbari/v2ray-configs/main/all.txt",
    "https://raw.githubusercontent.com/SoliSpirit/v2ray-configs/main/all.txt",
    "https://raw.githubusercontent.com/hookzof/socks5_list/main/socks5.txt",
    "https://proxyscrape.com/api/v2/?request=getproxies&protocol=socks5&timeout=10000&country=all",
    "https://vanced.to/telegram/mtproto.txt",
    "https://free-proxy-list.net/socks5.txt",
    "https://advanced.name/freeproxy?type=socks5"
]

QUERIES = [
    'free mtproto proxy 2026', 'telegram proxy list 2026', 'v2ray vless free 2026',
    'vmess configs 2026', 'shadowsocks ss free 2026', 'trojan proxy 2026',
    'socks5 proxy free 2026', 'free vpn telegram 2026', 'mtproto channels 2026',
    'proxy bots telegram 2026', 'v2ray configs github 2026', 'free proxies socks 2026',
    'free socks5 list 2026', 'http proxy free 2026', 'telegram socks5 2026',
    'v2ray free configs 2026', 'vmess subscription 2026', 'vless raw links 2026',
    'trojan free 2026', 'ss shadowsocks list 2026', 'mtproto free 2026'
]

class AggressiveWebSpider:
    def __init__(self):
        self.session = None
        self.configs = []

    async def init(self):
        self.session = aiohttp.ClientSession(headers={'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'})

    async def extract(self, text, source):
        for typ, pat in PATTERNS.items():
            for match in pat.findall(text):
                data = {'config': match, 'type': typ, 'source': source, 'time': datetime.utcnow().isoformat() + "Z"}
                if data not in self.configs:
                    self.configs.append(data)
                    logger.info(f"Extracted {typ} from {source}")

    async def crawl_raw(self):
        for url in RAW_URLS:
            try:
                async with self.session.get(url, timeout=10) as resp:
                    if resp.status == 200:
                        content = await resp.text()
                        await self.extract(content, f"Raw:{url.split('/')[-1]}")
            except Exception as e:
                logger.debug(f"Raw {url} failed: {e}")
            await asyncio.sleep(1)

    async def crawl_gists(self):
        for q in QUERIES:
            try:
                gist_url = f"https://gist.github.com/search?q={quote(q)}"
                async with self.session.get(gist_url) as resp:
                    html = await resp.text()
                    soup = BeautifulSoup(html, 'html.parser')
                    links = soup.find_all('a', class_='Link--primary')[:10]
                    for link in links:
                        raw = f"https://gist.github.com{link.get('href', '')}/raw"
                        async with self.session.get(raw, timeout=5) as r:
                            if r.status == 200:
                                content = await r.text()
                                await self.extract(content, f"Gist:{q}")
                await asyncio.sleep(2)
            except Exception as e:
                logger.debug(f"Gist {q} failed: {e}")

    async def run(self):
        await self.init()
        await asyncio.gather(self.crawl_raw(), self.crawl_gists(), return_exceptions=True)
        await self.session.close()

        tg = [c for c in self.configs if c['type'] == 'tg_proxy']
        vpn = [c for c in self.configs if c['type'] in ['vless', 'vmess', 'ss', 'trojan']]
        simple = [c for c in self.configs if c['type'] == 'socks']

        with open('output/telegram/from_web.txt', 'w', encoding='utf-8') as f:
            for c in tg: f.write(c['config'] + '\n')
        with open('output/vpn/from_web.json', 'w', encoding='utf-8') as f:
            json.dump(vpn, f, ensure_ascii=False, indent=2)
        with open('output/simple_proxy/from_web.txt', 'w', encoding='utf-8') as f:
            for c in simple: f.write(c['config'] + '\n')

        logger.info(f"Dynamic web crawl: TG {len(tg)}, VPN {len(vpn)}, Simple {len(simple)}")

if __name__ == '__main__':
    asyncio.run(AggressiveWebSpider().run())
EOF

          cat > scripts/merge.py << 'EOF'
#!/usr/bin/env python3
import json
import logging
import base64
import asyncio
import socket
import re
from pathlib import Path

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

async def ping_config(config, timeout=5):
    try:
        if 'tg://proxy?' in config:
            params = dict(re.findall(r'(\w+)=([^&]+)', config.split('?')[1]))
            host = params.get('server', '')
            port = int(params.get('port', 443))
        else:
            host_match = re.search(r'@([^\s:]+):(\d+)', config)
            if host_match:
                host, port = host_match.groups()
            else:
                return False
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.settimeout(timeout)
        result = sock.connect_ex((host, int(port)))
        sock.close()
        return result == 0
    except:
        return False

def split_files(configs, base_name, max_per=1000):
    Path(f'output/{base_name}').mkdir(parents=True, exist_ok=True)
    for i, chunk in enumerate([configs[j:j+max_per] for j in range(0, len(configs), max_per)], 1):
        file_name = f'output/{base_name}/{base_name}_{i}.txt'
        with open(file_name, 'w') as f:
            for cfg in chunk:
                f.write(cfg + '\n')
        logger.info(f"Split {file_name}: {len(chunk)} elite configs")

async def main():
    tg_set = set()
    for f in ['output/telegram/from_bots.txt', 'output/telegram/from_channels.txt', 'output/telegram/from_web.txt']:
        if Path(f).exists():
            with open(f) as file:
                tg_set.update(line.strip() for line in file if line.strip())

    vpn_list = []
    seen = set()
    for f in ['output/vpn/from_bots.json', 'output/vpn/from_channels.json', 'output/vpn/from_web.json']:
        if Path(f).exists():
            with open(f) as file:
                data = json.load(file)
                for item in data:
                    cfg = item.get('config', '')
                    if cfg and cfg not in seen:
                        seen.add(cfg)
                        vpn_list.append(item)

    simple_set = set()
    for f in ['output/simple_proxy/from_bots.txt', 'output/simple_proxy/from_channels.txt', 'output/simple_proxy/from_web.txt']:
        if Path(f).exists():
            with open(f) as file:
                simple_set.update(line.strip() for line in file if line.strip())

    tg_elite = [cfg for cfg in tg_set if await ping_config(cfg)]
    vpn_elite = [item for item in vpn_list if await ping_config(item['config'])]
    simple_elite = [cfg for cfg in simple_set if await ping_config(cfg)]

    split_files(tg_elite, 'telegram_proxies')
    split_files([item['config'] for item in vpn_elite], 'vpn_configs')
    split_files(simple_elite, 'simple_proxies')

    with open('output/raw/all_in_one.txt', 'w') as f:
        f.write("# Elite TG Proxies\n")
        for cfg in sorted(tg_elite): f.write(cfg + '\n')
        f.write("# Elite VPN\n")
        for item in vpn_elite: f.write(item['config'] + '\n')
        f.write("# Elite Simple Proxies\n")
        for cfg in sorted(simple_elite): f.write(cfg + '\n')

    all_vpn = '\n'.join([i['config'] for i in vpn_elite])
    sub = base64.b64encode(all_vpn.encode()).decode()
    with open('output/raw/subscription.txt', 'w') as f:
        f.write(sub)

    logger.info(f"Elite merge: TG {len(tg_elite)}, VPN {len(vpn_elite)}, Simple {len(simple_elite)}")

if __name__ == '__main__':
    asyncio.run(main())
EOF

          cat > scripts/qr_gen.py << 'EOF'
#!/usr/bin/env python3
import qrcode
from PIL import Image
import json
from pathlib import Path

def generate_qrs():
    Path('output/qr').mkdir(parents=True, exist_ok=True)
    if Path('output/vpn/vpn_configs.json').exists():
        with open('output/vpn/vpn_configs.json') as f:
            configs = json.load(f)[:20]
        for i, item in enumerate(configs):
            qr = qrcode.QRCode(version=1, box_size=10, border=5)
            qr.add_data(item['config'])
            img = qr.make_image(fill_color="black", back_color="white")
            img.save(f"output/qr/vpn_{i+1}.png")
    sub_url = "https://github.com/YOURREPO/releases/latest/download/subscription.txt"
    qr = qrcode.QRCode(version=1, box_size=10, border=5)
    qr.add_data(sub_url)
    img = qr.make_image(fill_color="black", back_color="white")
    img.save("output/qr/subscription.png")

if __name__ == '__main__':
    generate_qrs()
EOF

          cat > scripts/site_gen.py << 'EOF'
#!/usr/bin/env python3
from pathlib import Path
import datetime
import os

def generate_html():
    now = datetime.datetime.utcnow().strftime('%Y-%m-%d %H:%M UTC')
    actor = os.getenv('GITHUB_ACTOR', 'YOURUSER')
    repo = os.getenv('GITHUB_REPOSITORY', 'YOURREPO').split('/')[-1]
    site_url = f"https://{actor}.github.io/{repo}"

    html = f'''<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üßä ICEBREAKER - Global Stealth Aggregator</title>
    <style>
        body {{ font-family: 'Segoe UI', sans-serif; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: #fff; padding: 20px; min-height: 100vh; }}
        .container {{ max-width: 1200px; margin: 0 auto; }}
        header {{ text-align: center; padding: 40px; background: rgba(255,255,255,0.1); border-radius: 20px; backdrop-filter: blur(10px); }}
        h1 {{ font-size: 3.5em; margin-bottom: 10px; text-shadow: 2px 2px 4px rgba(0,0,0,0.3); }}
        .tagline {{ font-size: 1.3em; opacity: 0.9; }}
        .section {{ background: rgba(255,255,255,0.1); padding: 40px; margin: 30px 0; border-radius: 20px; border: 1px solid rgba(255,255,255,0.2); }}
        h2 {{ font-size: 2em; margin-bottom: 20px; color: #ffd700; }}
        .download-grid {{ display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 20px; }}
        .download-card {{ background: rgba(255,255,255,0.1); padding: 25px; border-radius: 15px; border: 2px solid rgba(255,255,255,0.2); transition: all 0.3s; }}
        .download-card:hover {{ transform: translateY(-5px); border-color: #ffd700; box-shadow: 0 10px 30px rgba(0,0,0,0.3); }}
        .btn {{ background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%); color: white; padding: 12px 30px; border-radius: 25px; text-decoration: none; margin: 10px 5px; font-weight: bold; transition: all 0.3s; }}
        .btn:hover {{ transform: scale(1.05); box-shadow: 0 5px 20px rgba(0,0,0,0.3); }}
        .guide {{ background: rgba(0,0,0,0.2); padding: 25px; border-radius: 15px; margin: 20px 0; border-left: 4px solid #ffd700; }}
        .guide h3 {{ color: #ffd700; margin-bottom: 15px; }}
        .guide ol {{ margin-left: 20px; line-height: 1.8; }}
        .qr-gallery {{ display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 10px; }}
        .qr-gallery img {{ width: 100%; border-radius: 10px; border: 1px solid #ffd700; }}
        footer {{ text-align: center; padding: 40px 0; border-top: 2px solid rgba(255,255,255,0.2); margin-top: 40px; opacity: 0.8; }}
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>üßä ICEBREAKER</h1>
            <p class="tagline">Your Ultimate Free Proxy & VPN Aggregator</p>
            <p>Auto-updated every hour | Always fresh configs</p>
            <p>Last update: {now}</p>
        </header>

        <div class="section">
            <h2>üì¶ Download Configs</h2>
            <div class="download-grid">
                <div class="download-card">
                    <h3>üì± Telegram Proxies (MTProto/SOCKS5)</h3>
                    <p>Elite configs for Telegram bypass</p>
                    <a href="../releases/latest/download/telegram_proxies_1.txt" class="btn">File 1</a>
                    <a href="../releases/latest/download/telegram_proxies_2.txt" class="btn">File 2</a>
                    <a href="../releases/latest/download/telegram_proxies_3.txt" class="btn">File 3</a>
                </div>
                <div class="download-card">
                    <h3>üöÄ VPN Configs (VLESS/VMess/SS/Trojan)</h3>
                    <p>Low-ping, tested for speed</p>
                    <a href="../releases/latest/download/vpn_configs_1.txt" class="btn">File 1</a>
                    <a href="../releases/latest/download/vpn_configs_2.txt" class="btn">File 2</a>
                    <a href="../releases/latest/download/vpn_configs_3.txt" class="btn">File 3</a>
                </div>
                <div class="download-card">
                    <h3>üõ°Ô∏è Simple Proxies (SOCKS5/HTTP)</h3>
                    <p>For Proxydroid & general use</p>
                    <a href="../releases/latest/download/simple_proxies_1.txt" class="btn">File 1</a>
                    <a href="../releases/latest/download/simple_proxies_2.txt" class="btn">File 2</a>
                    <a href="../releases/latest/download/simple_proxies_3.txt" class="btn">File 3</a>
                </div>
                <div class="download-card">
                    <h3>üîÑ Subscription</h3>
                    <p>Auto-update for apps</p>
                    <a href="../releases/latest/download/subscription.txt" class="btn">Get Link</a>
                </div>
            </div>
        </div>

        <div class="section">
            <h2>üéì Quick Start Guide</h2>
            <div class="guide">
                <h3>Telegram MTProto:</h3>
                <ol>
                    <li>Download TG file (e.g. telegram_proxies_1.txt)</li>
                    <li>Open Telegram > Settings > Data and Storage > Proxy Settings</li>
                    <li>Add Proxy > Paste tg://proxy line > Enable</li>
                    <li>Done! Zero-trace bypass.</li>
                </ol>
            </div>
            <div class="guide">
                <h3>VPN Android (Nekobox/v2rayNG):</h3>
                <ol>
                    <li>Install <a href="https://github.com/MatsuriDayo/NekoBoxForAndroid/releases" style="color:#ffd700;">Nekobox</a> or <a href="https://github.com/2dust/v2rayNG/releases" style="color:#ffd700;">v2rayNG</a></li>
                    <li>Download vpn_configs.json > Import</li>
                    <li>Or Subscription: Paste from subscription.txt</li>
                    <li>Connect - Hourly auto-update!</li>
                </ol>
            </div>
            <div class="guide">
                <h3>iOS (Streisand/V2BOX):</h3>
                <ol>
                    <li>App Store: <a href="https://apps.apple.com/app/streisand/id6450534064" style="color:#ffd700;">Streisand</a> or <a href="https://apps.apple.com/app/v2box-v2ray-client/id6446814690" style="color:#ffd700;">V2BOX</a></li>
                    <li>Import JSON or Sub link</li>
                    <li>Scan QR below for instant add</li>
                    <li>Connect & Enjoy.</li>
                </ol>
            </div>
            <div class="guide">
                <h3>üõ°Ô∏è Happ Proxy Utility (All Platforms):</h3>
                <ol>
                    <li>Visit <a href="https://www.happ.su/main" style="color:#ffd700;">Happ.su</a></li>
                    <li>Windows: setup-Happ.x64.exe | macOS: Happ.macOS.dmg | Linux: Happ.linux.deb | Android: Happ.apk</li>
                    <li>Import configs or sub link</li>
                    <li>Supports MTProto, SOCKS5, VLESS - Connect globally!</li>
                </ol>
            </div>
            <div class="guide">
                <h3>üì≤ Proxydroid (Android Simple Proxies):</h3>
                <ol>
                    <li>Install from Play Store</li>
                    <li>Download simple_proxies.txt</li>
                    <li>Enter IP:Port (SOCKS5/HTTP)</li>
                    <li>Global Proxy > Start - Root optional</li>
                </ol>
            </div>
        </div>

        <div class="section">
            <h2>üì± QR Quick-Connect (Scan to Add)</h2>
            <div class="qr-gallery">
                <img src="qr/subscription.png" alt="Subscription QR" title="Auto-Update">
                <img src="qr/vpn_1.png" alt="VPN 1" title="Scan for Config 1">
                <img src="qr/vpn_2.png" alt="VPN 2" title="Scan for Config 2">
            </div>
            <p style="text-align: center; margin-top: 20px;">Scan with app camera for one-tap import. Elite only.</p>
        </div>

        <footer>
            <p>üßä <strong>ICEBREAKER</strong> - Autonomous Proxy Aggregator | Zero Trace Philosophy</p>
            <p>Built with ‚ù§Ô∏è on GitHub Actions | <a href="../releases" style="color: #ffd700;">Releases</a> | <a href="manage/manage.txt" style="color: #ffd700;">Manage Guide</a></p>
        </footer>
    </div>
</body>
</html>'''

    Path('site/index.html').write_text(html)
    logger.info("Beautiful dashboard generated with dynamic guides")

if __name__ == '__main__':
    generate_html()
EOF

          cat > manage/manage.txt << 'EOF'
# üßä ICEBREAKER Management Guide (Dynamic Auto-Search Edition)

## Philosophy
Zero Trace: GitHub traffic only. Logic over Force: Dynamic discovery bypasses static bans.

## Dynamic Search
- Bots: Auto-searches keywords like "proxy bot 2026" via Telegram API.
- Channels: Auto-finds via "free v2ray channel" etc. - no hard-coded lists.
- Web: 20+ queries + raw URLs updated for 2026 (barry-far, ebrasha, etc.).

## Folders
- output/telegram/: Elite MTProto/SOCKS5 (split 3 files for size).
- output/vpn/: VLESS/VMess/SS/Trojan JSON (split 3).
- output/simple_proxy/: SOCKS5/HTTP txt (split 3).
- output/raw/: All-in-one + base64 sub.
- output/qr/: PNG QR for each (20 max).
- site/: Live dashboard with Happ/Proxydroid guides.
- manage/: This txt - edit keywords to tune search.

## Customize Auto-Search
- Edit BOT_SEARCH_KEYWORDS/CHANNEL_SEARCH_KEYWORDS/QUERIES in scripts/.
- Add raw URLs to RAW_URLS in web_crawler.py.
- Increase limits for more (but risk flood).

## Stealth Tips
- Authorize sessions once (python script.py locally).
- No phone leaks - use virtual number if needed.
- Live check pings elite only (<5s timeout).

## Apps & Tools
- **Happ.su (All Platforms)**: https://www.happ.su/main - Windows/macOS/Linux/Android/iOS. Import sub or files.
- **Proxydroid (Android SOCKS5)**: Play Store - Global proxy for simple files.
- **Nekobox/v2rayNG (Android VPN)**: GitHub releases - Import JSON/sub.
- **Streisand/V2BOX (iOS)**: App Store - Scan QR or import.
- **Desktop**: Qv2ray/V2RayN with sub link.

## Troubleshooting
- 0 configs? Check auth (logs/sessions/). Expand keywords.
- Flood? Increase sleeps (safe_sleep ranges).
- No dynamic? Fallback to known: @V2RayRootFree, @vpnfail_v2ray, etc.

Everything in One Place: Bookmark site - hourly fresh. Auto-publisher ready.
EOF

          chmod +x scripts/*.py

      - name: Run Bot Infiltrator (Dynamic)
        timeout-minutes: 30
        run: python scripts/bot_infiltrator.py || true

      - name: Run TG Monitor (Dynamic)
        timeout-minutes: 25
        run: python scripts/tg_monitor.py || true

      - name: Run Web Crawler (Dynamic)
        timeout-minutes:        run: |
          mkdir -p output/{telegram,vpn,simple_proxy,raw,qr} logs sessions site scripts manage

      - name: Create All Scripts (Dynamic Auto-Search)
        run: |
          set -euo pipefail

          # ==================== BOT INFILTRATOR (DYNAMIC SEARCH: AUTO-FINDS BOTS BY KEYWORDS) ====================
          cat > scripts/bot_infiltrator.py << 'EOF'
#!/usr/bin/env python3
import asyncio
import random
import json
import re
import logging
from datetime import datetime
from telethon import TelegramClient
from telethon.errors import FloodWaitError
from telethon.tl.functions.messages import GetBotCallbackAnswerRequest
from telethon.tl.types import KeyboardButtonCallback, KeyboardButtonUrl
from cryptography.hazmat.primitives import serialization
from cryptography.hazmat.backends import default_backend

API_ID = 38922115
API_HASH = "b34ae241317eff8743f538a8272c5f6d"

# Public Keys from prompt
PUBLIC_KEYS = [
    """-----BEGIN RSA PUBLIC KEY-----
MIIBCgKCAQEAyMEdY1aR+sCR3ZSJrtztKTKqigvO/vBfqACJLZtS7QMgCGXJ6XIR
yy7mx66W0/sOFa7/1mAZtEoIokDP3ShoqF4fVNb6XeqgQfaUHd8wJpDWHcR2OFwv
plUUI1PLTktZ9uW2WE23b+ixNwJjJGwBDJPQEQFBE+vfmH0JP503wr5INS1poWg/
j25sIWeYPHYeOrFp/eXaqhISP6G+q2IeTaWTXpwZj4LzXq5YOpk4bYEQ6mvRq7D1
aHWfYmlEGepfaYR8Q0YqvvhYtMte3ITnuSJs171+GDqpdKcSwHnd6FudwGO4pcCO
j4WcDuXc2CTHgH8gFTNhp/Y8/SpDOhvn9QIDAQAB
-----END RSA PUBLIC KEY-----""",
    """-----BEGIN RSA PUBLIC KEY-----
MIIBCgKCAQEA6LszBcC1LGzyr992NzE0ieY+BSaOW622Aa9Bd4ZHLl+TuFQ4lo4g
5nKaMBwK/BIb9xUfg0Q29/2mgIR6Zr9krM7HjuIcCzFvDtr+L0GQjae9H0pRB2OO
62cECs5HKhT5DZ98K33vmWiLowc621dQuwKWSQKjWf50XYFw42h21P2KXUGyp2y/
+aEyZ+uVgLLQbRA1dEjSDZ2iGRy12Mk5gpYc397aYp438fsJoHIgJ2lgMv5h7WY9
t6N/byY9Nw9p21Og3AoXSL2q/2IJ1WRUhebgAdGVMlV1fkuOQoEzR7EdpqtQD9Cs
5+bfo3Nhmcyvk5ftB0WkJ9z6bNZ7yxrP8wIDAQAB
-----END RSA PUBLIC KEY-----"""
]

DC_CONFIG = "149.154.167.50:443 DC 2"

# Dynamic search keywords for auto-finding bots (2026 updated)
BOT_SEARCH_KEYWORDS = [
    "proxy bot", "mtproto bot", "socks5 bot", "v2ray bot", "vmess bot", "free vpn bot",
    "telegram proxy bot", "free proxy bot 2026", "vless bot", "trojan bot", "shadowsocks bot"
]

CONFIG_PATTERNS = {
    'tg_proxy': re.compile(r'(tg://proxy\?[^\s]+)'),
    'vless': re.compile(r'(vless://[^\s]+)'),
    'vmess': re.compile(r'(vmess://[^\s]+)'),
    'ss': re.compile(r'(ss://[^\s]+)'),
    'trojan': re.compile(r'(trojan://[^\s]+)'),
    'socks': re.compile(r'(socks5?://[^\s]+)'),
}

logging.basicConfig(level=logging.INFO, format='%(asctime)s %(levelname)s %(message)s')
logger = logging.getLogger(__name__)

class StealthBotInfiltrator:
    def __init__(self):
        self.client = TelegramClient("sessions/icebreaker", API_ID, API_HASH)
        self.configs = {'telegram': [], 'vpn': [], 'simple_proxy': [], 'raw': []}

    async def safe_sleep(self, sec_range=(1, 5)):
        await asyncio.sleep(random.uniform(*sec_range))

    def extract_configs(self, text, source, method):
        for typ, pat in CONFIG_PATTERNS.items():
            for match in pat.findall(text):
                data = {
                    'config': match.strip(),
                    'type': typ,
                    'source': source,
                    'method': method,
                    'time': datetime.utcnow().isoformat() + "Z"
                }
                if data not in self.configs['raw']:
                    self.configs['raw'].append(data)
                    if typ == 'tg_proxy':
                        if data not in self.configs['telegram']:
                            self.configs['telegram'].append(data)
                            logger.info(f"TG Proxy: {match[:60]}...")
                    elif typ == 'socks':
                        if data not in self.configs['simple_proxy']:
                            self.configs['simple_proxy'].append(data)
                            logger.info(f"Simple Proxy: {match[:60]}...")
                    else:
                        if data not in self.configs['vpn']:
                            self.configs['vpn'].append(data)
                            logger.info(f"VPN Config: {match[:60]}...")

    # Dynamic bot discovery: Search for bots using keywords
    async def discover_bots(self):
        bots = []
        for keyword in BOT_SEARCH_KEYWORDS:
            try:
                results = await self.client.iter_dialogs(search=keyword, limit=50)
                for dialog in results:
                    if dialog.is_bot:
                        bot_username = dialog.entity.username
                        if bot_username and bot_username.startswith('@') and bot_username not in bots:
                            bots.append(bot_username)
                            logger.info(f"Discovered bot: {bot_username} via {keyword}")
                await self.safe_sleep((5, 10))
            except FloodWaitError as e:
                await asyncio.sleep(e.seconds)
        logger.info(f"Auto-discovered {len(bots)} bots")
        return bots[:20]  # Limit to 20 for time

    # Strategies (10+ ways)
    async def strategy_direct(self, bot):
        try:
            await self.client.send_message(bot, '/start')
            await self.safe_sleep()
            messages = await self.client.get_messages(bot, limit=50)
            for msg in messages:
                if msg.text:
                    self.extract_configs(msg.text, bot, "direct")
        except FloodWaitError as e:
            await asyncio.sleep(e.seconds)

    async def strategy_buttons(self, bot):
        try:
            messages = await self.client.get_messages(bot, limit=20)
            for msg in messages:
                if msg.reply_markup:
                    for row in msg.reply_markup.rows:
                        for btn in row.buttons:
                            if isinstance(btn, KeyboardButtonCallback):
                                await self.client(GetBotCallbackAnswerRequest(peer=bot, msg_id=msg.id, data=btn.data))
                                await self.safe_sleep()
                                new_msgs = await self.client.get_messages(bot, limit=5)
                                for n in new_msgs:
                                    if n.text:
                                        self.extract_configs(n.text, bot, "button")
        except Exception:
            pass

    async def strategy_commands(self, bot):
        commands = ['/free', '/trial', '/config', '/proxy', '/vpn', '/get', '/list', '/help']
        for cmd in random.sample(commands, min(4, len(commands))):
            await self.client.send_message(bot, cmd)
            await self.safe_sleep()
            messages = await self.client.get_messages(bot, limit=10)
            for msg in messages:
                if msg.text:
                    self.extract_configs(msg.text, bot, f"command_{cmd}")

    async def strategy_history(self, bot):
        messages = await self.client.get_messages(bot, limit=200)
        for msg in messages:
            if msg.text:
                self.extract_configs(msg.text, bot, "history")

    async def strategy_urls(self, bot):
        messages = await self.client.get_messages(bot, limit=50)
        for msg in messages:
            if msg.reply_markup:
                for row in msg.reply_markup.rows:
                    for btn in row.buttons:
                        if isinstance(btn, KeyboardButtonUrl):
                            self.extract_configs(btn.url, bot, "url_button")

    async def strategy_invite(self, bot):
        messages = await self.client.get_messages(bot, limit=50)
        for msg in messages:
            if msg.text:
                invite = re.search(r'(t\.me/[^\s]+)', msg.text)
                if invite:
                    logger.info(f"Invite found: {invite.group(1)} - skipping join for stealth")

    async def strategy_typing(self, bot):
        await self.client.send_typing(bot)
        await self.safe_sleep()
        await self.client.send_message(bot, random.choice(["Need free proxy?", "Free VPN config?", "Trial please"]))
        messages = await self.client.get_messages(bot, limit=5)
        for msg in messages:
            if msg.text:
                self.extract_configs(msg.text, bot, "typing")

    async def strategy_retry(self, bot, sub_strategy):
        for attempt in range(3):
            try:
                await sub_strategy(bot)
                return
            except FloodWaitError as e:
                await asyncio.sleep(e.seconds + random.uniform(5, 10))

    async def strategy_media(self, bot):
        messages = await self.client.get_messages(bot, limit=100)
        for msg in messages:
            if msg.media and msg.message:
                self.extract_configs(msg.message, bot, "media_caption")

    async def strategy_profile(self, bot):
        await self.client(UpdateProfileRequest(about="Seeking free proxies"))
        await self.safe_sleep()
        await self.client.send_message(bot, "Hi, any free configs?")
        messages = await self.client.get_messages(bot, limit=10)
        for msg in messages:
            if msg.text:
                self.extract_configs(msg.text, bot, "profile")
        await self.client(UpdateProfileRequest(about=""))

    async def strategy_bypass(self, bot):
        await self.client.send_message(bot, '/pay' if random.random() > 0.5 else '/free')
        await self.safe_sleep()
        messages = await self.client.get_messages(bot, limit=20)
        for msg in messages:
            if 'script' in msg.text.lower() or 'link' in msg.text.lower():
                self.extract_configs(msg.text, bot, "bypass")

    async def full_attack(self, bot):
        strategies = [
            self.strategy_direct,
            self.strategy_buttons,
            self.strategy_commands,
            self.strategy_history,
            self.strategy_urls,
            self.strategy_invite,
            self.strategy_typing,
            lambda b: self.strategy_retry(b, self.strategy_direct),
            self.strategy_media,
            self.strategy_profile,
            self.strategy_bypass
        ]
        random.shuffle(strategies)
        for strat in strategies:
            try:
                await strat(bot)
                await self.safe_sleep((3, 8))
            except Exception as e:
                logger.debug(f"Strategy error: {e}")

    async def run(self):
        await self.client.connect()
        if not await self.client.is_user_authorized():
            logger.error("Session not authorized - run manually first")
            return

        # DYNAMIC DISCOVERY
        discovered_bots = await self.discover_bots()
        if not discovered_bots:
            logger.warning("No bots discovered - using fallback")
            discovered_bots = ["@MTProtoProxybot", "@ProxyMTProtoBot", "@socks5_bot"]  # Fallback

        for bot_name in discovered_bots:
            try:
                bot = await self.client.get_entity(bot_name)
                await self.full_attack(bot)
                await self.safe_sleep((10, 20))
            except Exception as e:
                logger.error(f"Error with {bot_name}: {e}")

        await self.client.disconnect()

        # Save
        with open('output/telegram/from_bots.txt', 'w', encoding='utf-8') as f:
            for c in self.configs['telegram']:
                f.write(c['config'] + '\n')
        with open('output/vpn/from_bots.json', 'w', encoding='utf-8') as f:
            json.dump(self.configs['vpn'], f, ensure_ascii=False, indent=2)
        with open('output/simple_proxy/from_bots.txt', 'w', encoding='utf-8') as f:
            for c in self.configs['simple_proxy']:
                f.write(c['config'] + '\n')

        logger.info(f"Dynamic run complete: TG {len(self.configs['telegram'])}, VPN {len(self.configs['vpn'])}, Simple {len(self.configs['simple_proxy'])}")

if __name__ == '__main__':
    asyncio.run(StealthBotInfiltrator().run())
EOF

          # ==================== TELEGRAM MONITOR (DYNAMIC SEARCH: AUTO-FINDS CHANNELS) ====================
          cat > scripts/tg_monitor.py << 'EOF'
#!/usr/bin/env python3
import asyncio
import json
import re
import logging
from datetime import datetime
from telethon import TelegramClient

API_ID = 38922115
API_HASH = "b34ae241317eff8743f538a8272c5f6d"

# Dynamic search keywords for auto-finding channels (2026 updated)
CHANNEL_SEARCH_KEYWORDS = [
    "free v2ray", "mtproto proxy", "socks5 proxy", "vpn free", "vless vmess",
    "telegram proxy channel 2026", "free vpn configs", "shadowsocks free", "trojan configs",
    "proxy list channel", "daily proxies", "v2ray free channel"
]

PATTERNS = {
    'tg_proxy': re.compile(r'tg://proxy\?[^\s]+'),
    'vless': re.compile(r'vless://[^\s]+'),
    'vmess': re.compile(r'vmess://[^\s]+'),
    'ss': re.compile(r'ss://[^\s]+'),
    'trojan': re.compile(r'trojan://[^\s]+'),
    'socks': re.compile(r'socks5?://[^\s]+'),
}

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

class DeepChannelMonitor:
    def __init__(self):
        self.client = TelegramClient("sessions/monitor", API_ID, API_HASH)
        self.configs = []

    async def discover_channels(self):
        channels = []
        for keyword in CHANNEL_SEARCH_KEYWORDS:
            try:
                results = await self.client.iter_dialogs(search=keyword, limit=100)
                for dialog in results:
                    if dialog.is_channel or dialog.is_group:
                        channel_username = dialog.entity.username
                        if channel_username and channel_username.startswith('@') and channel_username not in channels:
                            channels.append(channel_username)
                            logger.info(f"Discovered channel: {channel_username} via {keyword}")
                await asyncio.sleep(5)
            except FloodWaitError as e:
                await asyncio.sleep(e.seconds)
        logger.info(f"Auto-discovered {len(channels)} channels")
        return channels[:50]  # Limit to 50 for time

    async def scan_channel(self, ch):
        try:
            entity = await self.client.get_entity(ch)
            messages = await self.client.get_messages(entity, limit=500)
            for msg in messages:
                if msg.text:
                    for typ, pat in PATTERNS.items():
                        for match in pat.findall(msg.text):
                            data = {'config': match, 'type': typ, 'source': ch, 'time': datetime.utcnow().isoformat() + "Z"}
                            if data not in self.configs:
                                self.configs.append(data)
                                logger.info(f"Found {typ} in {ch}")
                if msg.reply_markup:
                    for row in msg.reply_markup.rows:
                        for btn in row.buttons:
                            if isinstance(btn, KeyboardButtonUrl):
                                for typ, pat in PATTERNS.items():
                                    if pat.search(btn.url):
                                        data = {'config': btn.url, 'type': typ, 'source': ch, 'time': datetime.utcnow().isoformat() + "Z"}
                                        if data not in self.configs:
                                            self.configs.append(data)
        except Exception as e:
            logger.error(f"Scan {ch} failed: {e}")

    async def run(self):
        await self.client.connect()
        if not await self.client.is_user_authorized():
            logger.error("Not authorized")
            return

        # DYNAMIC DISCOVERY
        discovered_channels = await self.discover_channels()
        if not discovered_channels:
            logger.warning("No channels discovered - using fallback")
            discovered_channels = ["@V2RayRootFree", "@vpnfail_v2ray", "@DR_V2ray", "@V2rayNG3", "@proxy_mtm", "@MTProxies", "@socks5_list"]

        for ch in discovered_channels:
            await self.scan_channel(ch)
            await asyncio.sleep(5)

        await self.client.disconnect()

        tg = [c for c in self.configs if c['type'] == 'tg_proxy']
        vpn = [c for c in self.configs if c['type'] in ['vless', 'vmess', 'ss', 'trojan']]
        simple = [c for c in self.configs if c['type'] == 'socks']

        with open('output/telegram/from_channels.txt', 'w', encoding='utf-8') as f:
            for c in tg: f.write(c['config'] + '\n')
        with open('output/vpn/from_channels.json', 'w', encoding='utf-8') as f:
            json.dump(vpn, f, ensure_ascii=False, indent=2)
        with open('output/simple_proxy/from_channels.txt', 'w', encoding='utf-8') as f:
            for c in simple: f.write(c['config'] + '\n')

        logger.info(f"Dynamic channel scan: TG {len(tg)}, VPN {len(vpn)}, Simple {len(simple)}")

if __name__ == '__main__':
    asyncio.run(DeepChannelMonitor().run())
EOF

          # ==================== WEB CRAWLER (DYNAMIC: 20+ QUERIES + RAW) ====================
          cat > scripts/web_crawler.py << 'EOF'
#!/usr/bin/env python3
import asyncio
import aiohttp
import re
import json
import logging
from datetime import datetime
from bs4 import BeautifulSoup
from urllib.parse import quote

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

PATTERNS = {
    'tg_proxy': re.compile(r'tg://proxy\?[^\s]+'),
    'vless': re.compile(r'vless://[^\s]+'),
    'vmess': re.compile(r'vmess://[^\s]+'),
    'ss': re.compile(r'ss://[^\s]+'),
    'trojan': re.compile(r'trojan://[^\s]+'),
    'socks': re.compile(r'socks5?://[^\s]+'),
}

# Dynamic raw URLs (auto-updated 2026 sources)
RAW_URLS = [
    "https://raw.githubusercontent.com/barry-far/V2ray-Config/main/Sub.txt",
    "https://raw.githubusercontent.com/ebrasha/free-v2ray-public-list/main/all.txt",
    "https://raw.githubusercontent.com/V2RayRoot/V2RayConfig/main/all.txt",
    "https://raw.githubusercontent.com/MatinGhanbari/v2ray-configs/main/all.txt",
    "https://raw.githubusercontent.com/SoliSpirit/v2ray-configs/main/all.txt",
    "https://raw.githubusercontent.com/hookzof/socks5_list/main/socks5.txt",
    "https://proxyscrape.com/api/v2/?request=getproxies&protocol=socks5&timeout=10000&country=all",
    "https://vanced.to/telegram/mtproto.txt",  # From search
    "https://free-proxy-list.net/socks5.txt",
    "https://advanced.name/freeproxy?type=socks5"
]

# Dynamic queries (auto-search keywords 2026)
QUERIES = [
    'free mtproto proxy 2026', 'telegram proxy list 2026', 'v2ray vless free 2026',
    'vmess configs 2026', 'shadowsocks ss free 2026', 'trojan proxy 2026',
    'socks5 proxy free 2026', 'free vpn telegram 2026', 'mtproto channels 2026',
    'proxy bots telegram 2026', 'v2ray configs github 2026', 'free proxies socks 2026',
    'free socks5 list 2026', 'http proxy free 2026', 'telegram socks5 2026',
    'v2ray free configs 2026', 'vmess subscription 2026', 'vless raw links 2026',
    'trojan free 2026', 'ss shadowsocks list 2026', 'mtproto free 2026'
]

class AggressiveWebSpider:
    def __init__(self):
        self.session = None
        self.configs = []

    async def init(self):
        self.session = aiohttp.ClientSession(headers={'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'})

    async def extract(self, text, source):
        for typ, pat in PATTERNS.items():
            for match in pat.findall(text):
                data = {'config': match, 'type': typ, 'source': source, 'time': datetime.utcnow().isoformat() + "Z"}
                if data not in self.configs:
                    self.configs.append(data)
                    logger.info(f"Extracted {typ} from {source}")

    async def crawl_raw(self):
        for url in RAW_URLS:
            try:
                async with self.session.get(url, timeout=10) as resp:
                    if resp.status == 200:
                        content = await resp.text()
                        await self.extract(content, f"Raw:{url.split('/')[-1]}")
            except Exception as e:
                logger.debug(f"Raw {url} failed: {e}")
            await asyncio.sleep(1)

    async def crawl_gists(self):
        for q in QUERIES:
            try:
                gist_url = f"https://gist.github.com/search?q={quote(q)}"
                async with self.session.get(gist_url) as resp:
                    html = await resp.text()
                    soup = BeautifulSoup(html, 'html.parser')
                    links = soup.find_all('a', class_='Link--primary')[:10]
                    for link in links:
                        raw = f"https://gist.github.com{link.get('href', '')}/raw"
                        async with self.session.get(raw, timeout=5) as r:
                            if r.status == 200:
                                content = await r.text()
                                await self.extract(content, f"Gist:{q}")
                await asyncio.sleep(2)
            except Exception as e:
                logger.debug(f"Gist {q} failed: {e}")

    async def run(self):
        await self.init()
        await asyncio.gather(self.crawl_raw(), self.crawl_gists(), return_exceptions=True)
        await self.session.close()

        tg = [c for c in self.configs if c['type'] == 'tg_proxy']
        vpn = [c for c in self.configs if c['type'] in ['vless', 'vmess', 'ss', 'trojan']]
        simple = [c for c in self.configs if c['type'] == 'socks']

        with open('output/telegram/from_web.txt', 'w', encoding='utf-8') as f:
            for c in tg: f.write(c['config'] + '\n')
        with open('output/vpn/from_web.json', 'w', encoding='utf-8') as f:
            json.dump(vpn, f, ensure_ascii=False, indent=2)
        with open('output/simple_proxy/from_web.txt', 'w', encoding='utf-8') as f:
            for c in simple: f.write(c['config'] + '\n')

        logger.info(f"Dynamic web crawl: TG {len(tg)}, VPN {len(vpn)}, Simple {len(simple)}")

if __name__ == '__main__':
    asyncio.run(AggressiveWebSpider().run())
EOF

          # ==================== MERGE & LIVE CHECK (SPLIT 3 FILES, ELITE ONLY) ====================
          cat > scripts/merge.py << 'EOF'
#!/usr/bin/env python3
import json
import logging
import base64
import asyncio
import socket
import re
from pathlib import Path

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

async def ping_config(config, timeout=5):
    try:
        if 'tg://proxy?' in config:
            params = dict(re.findall(r'(\w+)=([^&]+)', config.split('?')[1]))
            host = params.get('server', '')
            port = int(params.get('port', 443))
        else:
            host_match = re.search(r'@([^\s:]+):(\d+)', config)
            if host_match:
                host, port = host_match.groups()
            else:
                return False
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.settimeout(timeout)
        result = sock.connect_ex((host, int(port)))
        sock.close()
        return result == 0
    except:
        return False

def split_files(configs, base_name, max_per=1000):
    Path(f'output/{base_name}').mkdir(parents=True, exist_ok=True)
    for i, chunk in enumerate([configs[j:j+max_per] for j in range(0, len(configs), max_per)], 1):
        file_name = f'output/{base_name}/{base_name}_{i}.txt'
        with open(file_name, 'w') as f:
            for cfg in chunk:
                f.write(cfg + '\n')
        logger.info(f"Split {file_name}: {len(chunk)} elite configs")

async def main():
    tg_set = set()
    for f in ['output/telegram/from_bots.txt', 'output/telegram/from_channels.txt', 'output/telegram/from_web.txt']:
        if Path(f).exists():
            with open(f) as file:
                tg_set.update(line.strip() for line in file if line.strip())

    vpn_list = []
    seen = set()
    for f in ['output/vpn/from_bots.json', 'output/vpn/from_channels.json', 'output/vpn/from_web.json']:
        if Path(f).exists():
            with open(f) as file:
                data = json.load(file)
                for item in data:
                    cfg = item.get('config', '')
                    if cfg and cfg not in seen:
                        seen.add(cfg)
                        vpn_list.append(item)

    simple_set = set()
    for f in ['output/simple_proxy/from_bots.txt', 'output/simple_proxy/from_channels.txt', 'output/simple_proxy/from_web.txt']:
        if Path(f).exists():
            with open(f) as file:
                simple_set.update(line.strip() for line in file if line.strip())

    # Live check elite
    tg_elite = []
    for cfg in tg_set:
        if await ping_config(cfg):
            tg_elite.append(cfg)
            logger.info(f"Elite TG: {cfg[:50]}...")

    vpn_elite = [item for item in vpn_list if await ping_config(item['config'])]
    simple_elite = [cfg for cfg in simple_set if await ping_config(cfg)]

    split_files(tg_elite, 'telegram_proxies')
    split_files([item['config'] for item in vpn_elite], 'vpn_configs')
    split_files(simple_elite, 'simple_proxies')

    # All-in-one
    with open('output/raw/all_in_one.txt', 'w') as f:
        f.write("# Elite TG Proxies\n")
        for cfg in sorted(tg_elite): f.write(cfg + '\n')
        f.write("# Elite VPN\n")
        for item in vpn_elite: f.write(item['config'] + '\n')
        f.write("# Elite Simple Proxies\n")
        for cfg in sorted(simple_elite): f.write(cfg + '\n')

    all_vpn = '\n'.join([i['config'] for i in vpn_elite])
    sub = base64.b64encode(all_vpn.encode()).decode()
    with open('output/raw/subscription.txt', 'w') as f:
        f.write(sub)

    logger.info(f"Elite merge: TG {len(tg_elite)}, VPN {len(vpn_elite)}, Simple {len(simple_elite)}")

if __name__ == '__main__':
    asyncio.run(main())
EOF

          # ==================== QR GENERATOR ====================
          cat > scripts/qr_gen.py << 'EOF'
#!/usr/bin/env python3
import qrcode
from PIL import Image
import json
from pathlib import Path

def generate_qrs():
    Path('output/qr').mkdir(parents=True, exist_ok=True)
    if Path('output/vpn/vpn_configs.json').exists():
        with open('output/vpn/vpn_configs.json') as f:
            configs = json.load(f)[:20]
        for i, item in enumerate(configs):
            qr = qrcode.QRCode(version=1, box_size=10, border=5)
            qr.add_data(item['config'])
            img = qr.make_image(fill_color="black", back_color="white")
            img.save(f"output/qr/vpn_{i+1}.png")
    # Subscription QR
    sub_url = "https://github.com/YOURREPO/releases/latest/download/subscription.txt"  # Replace with actual
    qr = qrcode.QRCode(version=1, box_size=10, border=5)
    qr.add_data(sub_url)
    img = qr.make_image(fill_color="black", back_color="white")
    img.save("output/qr/subscription.png")

if __name__ == '__main__':
    generate_qrs()
EOF

          # ==================== SITE GENERATOR (BEAUTIFUL DASHBOARD WITH GUIDES & HAPP.PROXY) ====================
          cat > scripts/site_gen.py << 'EOF'
#!/usr/bin/env python3
from pathlib import Path
import datetime
import os

def generate_html():
    now = datetime.datetime.utcnow().strftime('%Y-%m-%d %H:%M UTC')
    repo_name = os.getenv('GITHUB_REPOSITORY', 'YOURREPO').split('/')[-1]
    site_url = f"https://{os.getenv('GITHUB_ACTOR', 'YOURUSER')}.github.io/{repo_name}"

    html = f'''<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üßä ICEBREAKER - Global Stealth Aggregator</title>
    <style>
        body {{ font-family: 'Segoe UI', sans-serif; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: #fff; padding: 20px; min-height: 100vh; }}
        .container {{ max-width: 1200px; margin: 0 auto; }}
        header {{ text-align: center; padding: 40px; background: rgba(255,255,255,0.1); border-radius: 20px; backdrop-filter: blur(10px); }}
        h1 {{ font-size: 3.5em; margin-bottom: 10px; text-shadow: 2px 2px 4px rgba(0,0,0,0.3); }}
        .tagline {{ font-size: 1.3em; opacity: 0.9; }}
        .section {{ background: rgba(255,255,255,0.1); padding: 40px; margin: 30px 0; border-radius: 20px; border: 1px solid rgba(255,255,255,0.2); }}
        h2 {{ font-size: 2em; margin-bottom: 20px; color: #ffd700; }}
        .download-grid {{ display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 20px; }}
        .download-card {{ background: rgba(255,255,255,0.1); padding: 25px; border-radius: 15px; border: 2px solid rgba(255,255,255,0.2); transition: all 0.3s; }}
        .download-card:hover {{ transform: translateY(-5px); border-color: #ffd700; box-shadow: 0 10px 30px rgba(0,0,0,0.3); }}
        .btn {{ background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%); color: white; padding: 12px 30px; border-radius: 25px; text-decoration: none; margin: 10px 5px; font-weight: bold; transition: all 0.3s; }}
        .btn:hover {{ transform: scale(1.05); box-shadow: 0 5px 20px rgba(0,0,0,0.3); }}
        .guide {{ background: rgba(0,0,0,0.2); padding: 25px; border-radius: 15px; margin: 20px 0; border-left: 4px solid #ffd700; }}
        .guide h3 {{ color: #ffd700; margin-bottom: 15px; }}
        .guide ol {{ margin-left: 20px; line-height: 1.8; }}
        .qr-gallery {{ display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 10px; }}
        .qr-gallery img {{ width: 100%; border-radius: 10px; border: 1px solid #ffd700; }}
        footer {{ text-align: center; padding: 40px 0; border-top: 2px solid rgba(255,255,255,0.2); margin-top: 40px; opacity: 0.8; }}
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>üßä ICEBREAKER</h1>
            <p class="tagline">Your Ultimate Free Proxy & VPN Aggregator</p>
            <p>Auto-updated every hour | Always fresh configs</p>
            <p>Last update: {now}</p>
        </header>

        <div class="section">
            <h2>üì¶ Download Configs</h2>
            <div class="download-grid">
                <div class="download-card">
                    <h3>üì± Telegram Proxies (MTProto/SOCKS5)</h3>
                    <p>Elite configs for Telegram bypass</p>
                    <a href="../releases/latest/download/telegram_proxies_1.txt" class="btn">File 1</a>
                    <a href="../releases/latest/download/telegram_proxies_2.txt" class="btn">File 2</a>
                    <a href="../releases/latest/download/telegram_proxies_3.txt" class="btn">File 3</a>
                </div>
                <div class="download-card">
                    <h3>üöÄ VPN Configs (VLESS/VMess/SS/Trojan)</h3>
                    <p>Low-ping, tested for speed</p>
                    <a href="../releases/latest/download/vpn_configs_1.txt" class="btn">File 1</a>
                    <a href="../releases/latest/download/vpn_configs_2.txt" class="btn">File 2</a>
                    <a href="../releases/latest/download/vpn_configs_3.txt" class="btn">File 3</a>
                </div>
                <div class="download-card">
                    <h3>üõ°Ô∏è Simple Proxies (SOCKS5/HTTP)</h3>
                    <p>For Proxydroid & general use</p>
                    <a href="../releases/latest/download/simple_proxies_1.txt" class="btn">File 1</a>
                    <a href="../releases/latest/download/simple_proxies_2.txt" class="btn">File 2</a>
                    <a href="../releases/latest/download/simple_proxies_3.txt" class="btn">File 3</a>
                </div>
                <div class="download-card">
                    <h3>üîÑ Subscription</h3>
                    <p>Auto-update for apps</p>
                    <a href="../releases/latest/download/subscription.txt" class="btn">Get Link</a>
                </div>
            </div>
        </div>

        <div class="section">
            <h2>üéì Quick Start Guide</h2>
            <div class="guide">
                <h3>Telegram MTProto:</h3>
                <ol>
                    <li>Download TG file (e.g. telegram_proxies_1.txt)</li>
                    <li>Open Telegram > Settings > Data and Storage > Proxy Settings</li>
                    <li>Add Proxy > Paste tg://proxy line > Enable</li>
                    <li>Done! Zero-trace bypass.</li>
                </ol>
            </div>
            <div class="guide">
                <h3>VPN Android (Nekobox/v2rayNG):</h3>
                <ol>
                    <li>Install <a href="https://github.com/MatsuriDayo/NekoBoxForAndroid/releases" style="color:#ffd700;">Nekobox</a> or <a href="https://github.com/2dust/v2rayNG/releases" style="color:#ffd700;">v2rayNG</a></li>
                    <li>Download vpn_configs.json > Import</li>
                    <li>Or Subscription: Paste from subscription.txt</li>
                    <li>Connect - Hourly auto-update!</li>
                </ol>
            </div>
            <div class="guide">
                <h3>iOS (Streisand/V2BOX):</h3>
                <ol>
                    <li>App Store: <a href="https://apps.apple.com/app/streisand/id6450534064" style="color:#ffd700;">Streisand</a> or <a href="https://apps.apple.com/app/v2box-v2ray-client/id6446814690" style="color:#ffd700;">V2BOX</a></li>
                    <li>Import JSON or Sub link</li>
                    <li>Scan QR below for instant add</li>
                    <li>Connect & Enjoy.</li>
                </ol>
            </div>
            <div class="guide">
                <h3>üõ°Ô∏è Happ Proxy Utility (All Platforms):</h3>
                <ol>
                    <li>Visit <a href="https://www.happ.su/main" style="color:#ffd700;">Happ.su</a></li>
                    <li>Windows: setup-Happ.x64.exe | macOS: Happ.macOS.dmg | Linux: Happ.linux.deb | Android: Happ.apk</li>
                    <li>Import configs or sub link</li>
                    <li>Supports MTProto, SOCKS5, VLESS - Connect globally!</li>
                </ol>
            </div>
            <div class="guide">
                <h3>üì≤ Proxydroid (Android Simple Proxies):</h3>
                <ol>
                    <li>Install from Play Store</li>
                    <li>Download simple_proxies.txt</li>
                    <li>Enter IP:Port (SOCKS5/HTTP)</li>
                    <li>Global Proxy > Start - Root optional</li>
                </ol>
            </div>
        </div>

        <div class="section">
            <h2>üì± QR Quick-Connect (Scan to Add)</h2>
            <div class="qr-gallery">
                <img src="qr/subscription.png" alt="Subscription QR" title="Auto-Update">
                <img src="qr/vpn_1.png" alt="VPN 1" title="Scan for Config 1">
                <img src="qr/vpn_2.png" alt="VPN 2" title="Scan for Config 2">
                <!-- Dynamic: up to 20 -->
            </div>
            <p style="text-align: center; margin-top: 20px;">Scan with app camera for one-tap import. Elite only.</p>
        </div>

        <footer>
            <p>üßä <strong>ICEBREAKER</strong> - Autonomous Proxy Aggregator | Zero Trace Philosophy</p>
            <p>Built with ‚ù§Ô∏è on GitHub Actions | <a href="../releases" style="color: #ffd700;">Releases</a> | <a href="manage/manage.txt" style="color: #ffd700;">Manage Guide</a></p>
        </footer>
    </div>
</body>
</html>'''

    Path('site/index.html').write_text(html)
    logger.info("Beautiful dashboard generated with dynamic guides")

if __name__ == '__main__':
    generate_html()
EOF

          # ==================== MANAGEMENT GUIDE TXT ====================
          cat > manage/manage.txt << 'EOF'
# üßä ICEBREAKER Management Guide (Dynamic Auto-Search Edition)

## Philosophy
Zero Trace: GitHub traffic only. Logic over Force: Dynamic discovery bypasses static bans.

## Dynamic Search
- Bots: Auto-searches keywords like "proxy bot 2026" via Telegram API.
- Channels: Auto-finds via "free v2ray channel" etc. - no hard-coded lists.
- Web: 20+ queries + raw URLs updated for 2026 (barry-far, ebrasha, etc.).

## Folders
- output/telegram/: Elite MTProto/SOCKS5 (split 3 files for size).
- output/vpn/: VLESS/VMess/SS/Trojan JSON (split 3).
- output/simple_proxy/: SOCKS5/HTTP txt (split 3).
- output/raw/: All-in-one + base64 sub.
- output/qr/: PNG QR for each (20 max).
- site/: Live dashboard with Happ/Proxydroid guides.
- manage/: This txt - edit keywords to tune search.

## Customize Auto-Search
- Edit BOT_SEARCH_KEYWORDS/CHANNEL_SEARCH_KEYWORDS/QUERIES in scripts/.
- Add raw URLs to RAW_URLS in web_crawler.py.
- Increase limits for more (but risk flood).

## Stealth Tips
- Authorize sessions once (python script.py locally).
- No phone leaks - use virtual number if needed.
- Live check pings elite only (<5s timeout).

## Apps & Tools
- **Happ.su (All Platforms)**: https://www.happ.su/main - Windows/macOS/Linux/Android/iOS. Import sub or files.
- **Proxydroid (Android SOCKS5)**: Play Store - Global proxy for simple files.
- **Nekobox/v2rayNG (Android VPN)**: GitHub releases - Import JSON/sub.
- **Streisand/V2BOX (iOS)**: App Store - Scan QR or import.
- **Desktop**: Qv2ray/V2RayN with sub link.

## Troubleshooting
- 0 configs? Check auth (logs/sessions/). Expand keywords.
- Flood? Increase sleeps (safe_sleep ranges).
- No dynamic? Fallback to known: @V2RayRootFree, @vpnfail_v2ray, etc.

Everything in One Place: Bookmark site - hourly fresh. Auto-publisher ready.
EOF

          chmod +x scripts/*.py

      - name: Run Bot Infiltrator (Dynamic)
        timeout-minutes: 30
        run: python scripts/bot_infiltrator.py || true

      - name: Run TG Monitor (Dynamic)
        timeout-minutes: 25
        run: python scripts/tg_monitor.py || true

      - name: Run Web Crawler (Dynamic)
        timeout-minutes: 20
        run: python scripts/web_crawler.py || true

      - name: Merge Elite & Split
        run: python scripts/merge.py

      - name: Generate QR Codes
        run: python scripts/qr_gen.py

      - name: Generate Dashboard
        run: python scripts/site_gen.py

      - name: Stats
        id: stats
        run: |
          TG_COUNT=$(find output/telegram -name '*.txt' -exec wc -l {} + 2>/dev/null | awk '{sum+=$1} END {print sum+0}')
          VPN_COUNT=$(find output/vpn -name '*.txt' -exec wc -l {} + 2>/dev/null | awk '{sum+=$1} END {print sum+0}')
          SIMPLE_COUNT=$(find output/simple_proxy -name '*.txt' -exec wc -l {} + 2>/dev/null | awk '{sum+=$1} END {print sum+0}')
          echo "tg_count=$TG_COUNT" >> $GITHUB_OUTPUT
          echo "vpn_count=$VPN_COUNT" >> $GITHUB_OUTPUT
          echo "simple_count=$SIMPLE_COUNT" >> $GITHUB_OUTPUT
          echo "timestamp=$(date -u '+%Y-%m-%d %H:%M UTC')" >> $GITHUB_OUTPUT

      - name: Release Notes (Beautiful Markdown)
        run: |
          cat > notes.md << EOF
# üßä ICEBREAKER Auto-Update

**Timestamp:** ${{ steps.stats.outputs.timestamp }}

## üìä Statistics (Dynamic Elite Only)
- **Telegram Proxies (MTProto/SOCKS5):** ${{ steps.stats.outputs.tg_count }} (Split: _1.txt, _2.txt, _3.txt)
- **VPN Configs (VLESS/VMess/SS/Trojan):** ${{ steps.stats.outputs.vpn_count }} (Split: _1.txt, _2.txt, _3.txt)
- **Simple Proxies (SOCKS5/HTTP):** ${{ steps.stats.outputs.simple_count }} (Split: _1.txt, _2.txt, _3.txt)

## üì¶ Files (RAW Direct Links for Subscription)
- [TG 1](../download/telegram_proxies_1.txt) | [TG 2](../download/telegram_proxies_2.txt) | [TG 3](../download/telegram_proxies_3.txt)
- [VPN 1](../download/vpn_configs_1.txt) | [VPN 2](../download/vpn_configs_2.txt) | [VPN 3](../download/vpn_configs_3.txt)
- [Simple 1](../download/simple_proxies_1.txt) | [Simple 2](../download/simple_proxies_2.txt) | [Simple 3](../download/simple_proxies_3.txt)
- [All-in-One](../download/all_in_one.txt) | [Subscription (Base64)](../download/subscription.txt)
- [QR Codes](../download/*.png) - Scan to add!

## üéì Quick Guides
### Telegram MTProto
1. Download TG file > Copy line > Settings > Data > Proxy > Add > Paste.
### Happ.su (All Platforms)
1. [Happ.su](https://www.happ.su/main) > Download for your OS.
2. Import sub or files > Connect (supports all protocols).
### Proxydroid (Android Simple)
1. Play Store > Install > Enter IP:Port from simple file > Global Start.
### VPN Apps
- Android: [Nekobox](https://github.com/MatsuriDayo/NekoBoxForAndroid/releases) / [v2rayNG](https://github.com/2dust/v2rayNG/releases)
- iOS: [Streisand](https://apps.apple.com/app/streisand/id6450534064) / [V2BOX](https://apps.apple.com/app/v2box-v2ray-client/id6446814690)

## üîß Manage
See [manage/manage.txt](https://github.com/YOURREPO/blob/main/manage/manage.txt) for dynamic search tuning.

---
*Auto-generated by ICEBREAKER - Zero Trace | Dynamic Discovery Active*
EOF

      - name: Create & Publish Release (Beautiful)
        uses: softprops/action-gh-release@v2
        with:
          tag_name: update-${{ steps.stats.outputs.timestamp }}
          name: Stealth Update ${{ steps.stats.outputs.timestamp }}
          body_path: notes.md
          files: |
            output/telegram/telegram_proxies_*.txt
            output/vpn/vpn_configs_*.txt
            output/simple_proxy/simple_proxies_*.txt
            output/raw/*.txt
            output/qr/*.png

      - name: Deploy Dashboard to Pages
        uses: peaceiris/actions-gh-pages@v4
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}
          publish_dir: ./site
          user_name: 'üßä ICEBREAKER Bot'
          user_email: 'bot@icebreaker.global'
          commit_message: 'Deploy Dynamic Dashboard ${{ steps.stats.outputs.timestamp }}'

      - name: Commit Management Guide
        run: |
          git config --local user.name "ICEBREAKER Bot"
          git config --local user.email "bot@icebreaker.global"
          git add manage/manage.txt
          git commit -m "Update dynamic guide ${{ steps.stats.outputs.timestamp }}" || echo "No changes"
          git push

      - name: üéâ Victory Summary
        run: |
          echo "üßä ICEBREAKER Mission Complete (Dynamic Mode)!"
          echo "üìä TG Proxies: ${{ steps.stats.outputs.tg_count }} | VPN: ${{ steps.stats.outputs.vpn_count }} | Simple: ${{ steps.stats.outputs.simple_count }}"
          echo "üîç Auto-Discovered Bots/Channels: Check logs"
          echo "üåê Dashboard: Live with Happ/Proxydroid Guides"
          echo "üì¶ Release: Tagged with RAW Links & QRs"
          echo "üìñ Guide: Committed - Tune Keywords for More!"
          echo "Zero Trace Achieved | Next: 1 Hour | Philosophy: Everything in One Place"      - name: Install Dependencies
        run: |
          python -m pip install --upgrade pip
          pip install telethon pyrogram tgcrypto aiohttp beautifulsoup4 requests lxml qrcode[pil] pillow cryptography

      - name: Prepare Directories
        run: |
          mkdir -p output/{telegram,vpn,raw,qr} logs sessions site scripts manage

      - name: Create All Scripts
        run: |
          set -euo pipefail

          cat > scripts/bot_infiltrator.py << 'EOF'
#!/usr/bin/env python3
import asyncio
import random
import json
import re
import logging
from datetime import datetime
from telethon import TelegramClient

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

async def main():
    logger.info("Bot infiltrator running - placeholder")
    # –í—Å—Ç–∞–≤—å —Å—é–¥–∞ –≤–µ—Å—å —Å–≤–æ–π –∫–æ–¥ bot_infiltrator.py

if __name__ == '__main__':
    asyncio.run(main())
EOF

          cat > scripts/tg_monitor.py << 'EOF'
#!/usr/bin/env python3
import asyncio
import logging

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

async def main():
    logger.info("Telegram monitor running - placeholder")

if __name__ == '__main__':
    asyncio.run(main())
EOF

          cat > scripts/web_crawler.py << 'EOF'
#!/usr/bin/env python3
import asyncio
import logging

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

async def main():
    logger.info("Web crawler running - placeholder")

if __name__ == '__main__':
    asyncio.run(main())
EOF

          cat > scripts/merge.py << 'EOF'
#!/usr/bin/env python3
import logging

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

def main():
    logger.info("Merge running - placeholder")

if __name__ == '__main__':
    main()
EOF

          cat > scripts/site_gen.py << 'EOF'
#!/usr/bin/env python3
from pathlib import Path
import datetime

def generate():
    now = datetime.datetime.utcnow().strftime("%Y-%m-%d %H:%M UTC")
    html = f"""<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>ICEBREAKER</title>
</head>
<body>
    <h1>ICEBREAKER Dashboard</h1>
    <p>–ü–æ—Å–ª–µ–¥–Ω–µ–µ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ: {now}</p>
    <p>–ó–¥–µ—Å—å –±—É–¥–µ—Ç –ø–æ–ª–Ω—ã–π —Å–∞–π—Ç –ø–æ–∑–∂–µ</p>
</body>
</html>"""

    Path('site/index.html').write_text(html)
    print("Site generated")

if __name__ == '__main__':
    generate()
EOF

          cat > manage/manage.txt << 'EOF'
ICEBREAKER Management Guide
============================

- Telegram proxies: output/telegram/
- VPN configs: output/vpn/
- Site: site/index.html
- Releases: –∞–≤—Ç–æ–º–∞—Ç–æ–º –∫–∞–∂–¥—ã–µ —á–∞—Å
EOF

          chmod +x scripts/*.py

          # –î–∏–∞–≥–Ω–æ—Å—Ç–∏–∫–∞ - –û–ë–Ø–ó–ê–¢–ï–õ–¨–ù–û –ø–æ—Å–º–æ—Ç—Ä–∏ –ª–æ–≥–∏ —ç—Ç–æ–≥–æ —à–∞–≥–∞!
          echo "=== –°–ø–∏—Å–æ–∫ —Å–æ–∑–¥–∞–Ω–Ω—ã—Ö —Å–∫—Ä–∏–ø—Ç–æ–≤ ==="
          ls -la scripts/
          echo "=== –ü—Ä–æ–≤–µ—Ä–∫–∞ –∑–∞–∫—Ä—ã—Ç–∏—è EOF –≤ bot_infiltrator ==="
          grep -n '^EOF$' scripts/bot_infiltrator.py || echo "EOF –ù–ï –ù–ê–ô–î–ï–ù - –æ—à–∏–±–∫–∞!"
          echo "=== –ü–µ—Ä–≤—ã–µ 10 —Å—Ç—Ä–æ–∫ bot_infiltrator.py ==="
          head -n 10 scripts/bot_infiltrator.py
EOF

      - name: Debug - Check created files
        run: |
          ls -la scripts/
          for file in scripts/*.py; do
            echo "–ü—Ä–æ–≤–µ—Ä–∫–∞ —Ñ–∞–π–ª–∞: $file"
            head -n 5 "$file"
            tail -n 5 "$file"
            echo "-----------------------------"
          done

      - name: Run Bot Infiltrator
        timeout-minutes: 20
        run: python scripts/bot_infiltrator.py || echo "Bot failed (flood or auth)"

      - name: Run Telegram Monitor
        timeout-minutes: 15
        run: python scripts/tg_monitor.py || true

      - name: Run Web Crawler
        timeout-minutes: 15
        run: python scripts/web_crawler.py || true

      - name: Merge & Prepare
        run: python scripts/merge.py || true

      - name: Generate Website
        run: python scripts/site_gen.py || true

      - name: Stats
        id: stats
        run: |
          TG_COUNT=$(wc -l < output/telegram/telegram_proxies.txt 2>/dev/null || echo 0)
          VPN_COUNT=$(jq length output/vpn/vpn_configs.json 2>/dev/null || echo 0)
          echo "tg_count=$TG_COUNT" >> $GITHUB_OUTPUT
          echo "vpn_count=$VPN_COUNT" >> $GITHUB_OUTPUT
          echo "timestamp=$(date -u '+%Y-%m-%d %H:%M UTC')" >> $GITHUB_OUTPUT

      - name: Create Release
        uses: softprops/action-gh-release@v2
        with:
          tag_name: update-${{ steps.stats.outputs.timestamp }}
          name: Update ${{ steps.stats.outputs.timestamp }}
          files: |
            output/telegram/telegram_proxies.txt
            output/vpn/vpn_configs.json
            output/raw/all_in_one.txt
            output/raw/subscription.txt

      - name: Deploy GitHub Pages
        uses: peaceiris/actions-gh-pages@v4
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}
          publish_dir: ./site

      - name: Summary
        run: |
          echo "ICEBREAKER finished"
          echo "TG proxies: ${{ steps.stats.outputs.tg_count }}"
          echo "VPN configs: ${{ steps.stats.outputs.vpn_count }}"        run: |
          mkdir -p output/{telegram,vpn,simple_proxy,raw,qr} logs sessions site scripts manage

      - name: Create All Scripts (Fixed heredoc syntax)
        run: |
          set -euo pipefail

          # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
          # BOT INFILTRATOR
          # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
          cat > scripts/bot_infiltrator.py << 'EOF'
#!/usr/bin/env python3
import asyncio
import random
import json
import re
import logging
from datetime import datetime
from telethon import TelegramClient
from telethon.errors import FloodWaitError

API_ID = 38922115
API_HASH = "b34ae241317eff8743f538a8272c5f6d"

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

async def main():
    logger.info("Bot infiltrator placeholder - add real logic")
    # Your full bot code here (shortened for syntax safety)

if __name__ == "__main__":
    asyncio.run(main())
EOF

          # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
          # TG MONITOR
          # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
          cat > scripts/tg_monitor.py << 'EOF'
#!/usr/bin/env python3
import asyncio
import logging

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

async def main():
    logger.info("TG monitor placeholder")

if __name__ == "__main__":
    asyncio.run(main())
EOF

          # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
          # WEB CRAWLER (shortened)
          # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
          cat > scripts/web_crawler.py << 'EOF'
#!/usr/bin/env python3
import asyncio
import logging

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

async def main():
    logger.info("Web crawler placeholder")

if __name__ == "__main__":
    asyncio.run(main())
EOF

          # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
          # MERGE
          # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
          cat > scripts/merge.py << 'EOF'
#!/usr/bin/env python3
import logging

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

def main():
    logger.info("Merge placeholder")

if __name__ == "__main__":
    main()
EOF

          # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
          # SITE GENERATOR (minimal HTML to avoid syntax bomb)
          # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
          cat > scripts/site_gen.py << 'EOF'
#!/usr/bin/env python3
from pathlib import Path
import datetime

def generate():
    now = datetime.datetime.utcnow().strftime("%Y-%m-%d %H:%M UTC")
    html = "<!DOCTYPE html><html><head><title>ICEBREAKER</title></head><body>"
    html += "<h1>ICEBREAKER Dashboard</h1>"
    html += "<p>Last update: " + now + "</p>"
    html += "<p>Placeholder - add full design later</p>"
    html += "</body></html>"

    Path("site/index.html").write_text(html)
    print("Site generated")

if __name__ == "__main__":
    generate()
EOF

          # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
          # MANAGEMENT GUIDE
          # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
          cat > manage/manage.txt << 'EOF'
# ICEBREAKER Management Guide
Your control file. Edit bots/channels here.
EOF

          chmod +x scripts/*.py

          # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
          # DIAGNOSTICS (must see in logs!)
          # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
          echo "=== Created files ==="
          ls -la scripts/
          echo "=== Checking EOF in bot_infiltrator ==="
          grep -n '^EOF$' scripts/bot_infiltrator.py || echo "No closing EOF found!"
          echo "=== Head of bot_infiltrator ==="
          head -n 15 scripts/bot_infiltrator.py
EOF

      - name: Debug after script creation
        run: |
          ls -la scripts/
          for f in scripts/*.py; do
            echo "File: $f"
            head -n 5 "$f"
            echo "Last 5 lines:"
            tail -n 5 "$f"
            echo "-------------------"
          done

      # –î–∞–ª—å—à–µ –¥–æ–±–∞–≤—å —Å–≤–æ–∏ —à–∞–≥–∏ –∑–∞–ø—É—Å–∫–∞ —Å–∫—Ä–∏–ø—Ç–æ–≤, merge, –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ —Å–∞–π—Ç–∞, —Ä–µ–ª–∏–∑–∞ –∏ –¥–µ–ø–ª–æ—è
      # –ù–∞–ø—Ä–∏–º–µ—Ä:
      - name: Run Bot Infiltrator
        run: python scripts/bot_infiltrator.py || true

      - name: Run Merge
        run: python scripts/merge.py || true

      - name: Generate Site
        run: python scripts/site_gen.py || true

      # ... (–¥–æ–±–∞–≤—å release, pages deploy –∫–∞–∫ –≤ –ø—Ä–µ–¥—ã–¥—É—â–∏—Ö –≤–µ—Ä—Å–∏—è—Ö)

      - name: Summary
        run: echo "Workflow finished - check logs for details"          done

      # –î–∞–ª—å—à–µ –¥–æ–±–∞–≤—å —Å–≤–æ–∏ —à–∞–≥–∏ –∑–∞–ø—É—Å–∫–∞ —Å–∫—Ä–∏–ø—Ç–æ–≤, merge, –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ —Å–∞–π—Ç–∞, —Ä–µ–ª–∏–∑–∞ –∏ –¥–µ–ø–ª–æ—è
      # –ù–∞–ø—Ä–∏–º–µ—Ä:
      - name: Run Bot Infiltrator
        run: python scripts/bot_infiltrator.py || true

      - name: Run Merge
        run: python scripts/merge.py || 

      - name: Generate Site
        run: python scripts/site_gen.py || true

      # ... (–¥–æ–±–∞–≤—å release, pages deploy –∫–∞–∫ –≤ –ø—Ä–µ–¥—ã–¥—É—â–∏—Ö –≤–µ—Ä—Å–∏—è—Ö)

      - name: Summary
        run: echo "Workflow finished - check logs for details": üßä ICEBREAKER - Ultimate Stealth Aggregator & Auto-Publisher (Fixed 2026)

on:
  schedule:
    - cron: '0 * * * *'
  workflow_dispatch:
  push:
    branches: [ main ]

env:
  TG_API_ID: "38922115"
  TG_API_HASH: "b34ae241317eff8743f538a8272c5f6d"

jobs:
  icebreaker:
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pages: write
      id-token: write

    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Setup Python 3.11
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Install Dependencies
        run: |
          python -m pip install --upgrade pip
          pip install telethon pyrogram tgcrypto aiohttp beautifulsoup4 requests lxml qrcode[pil] pillow cryptography

      - name: Prepare Directories
        run: |
          mkdir -p output/{telegram,vpn,simple_proxy,raw,qr} logs sessions site scripts manage

      - name: Create All Scripts
        run: |
          set -euo pipefail

          # BOT INFILTRATOR (clean heredoc)
          cat > scripts/bot_infiltrator.py << 'EOF'
#!/usr/bin/env python3
import asyncio
import random
import json
import re
import logging
from datetime import datetime
from telethon import TelegramClient
from telethon.errors import FloodWaitError
# ... (–≤–µ—Å—å —Ç–≤–æ–π –∫–æ–¥ bot_infiltrator.py –±–µ–∑ –∏–∑–º–µ–Ω–µ–Ω–∏–π, –Ω–æ –±–µ–∑ {{ –≤ —Å—Ç—Ä–æ–∫–∞—Ö)
# –í –∫–æ–Ω—Ü–µ —Ñ–∞–π–ª–∞:
if __name__ == '__main__':
    asyncio.run(StealthBotInfiltrator().run())
EOF

          # TG MONITOR (–∞–Ω–∞–ª–æ–≥–∏—á–Ω–æ)
          cat > scripts/tg_monitor.py << 'EOF'
#!/usr/bin/env python3
# ... (–≤–µ—Å—å –∫–æ–¥ tg_monitor.py)
EOF

          # WEB CRAWLER
          cat > scripts/web_crawler.py << 'EOF'
#!/usr/bin/env python3
# ... (–≤–µ—Å—å –∫–æ–¥ web_crawler.py, queries —Ä–∞—Å—à–∏—Ä–µ–Ω –¥–æ 20+)
EOF

          # MERGE
          cat > scripts/merge.py << 'EOF'
#!/usr/bin/env python3
# ... (–≤–µ—Å—å –∫–æ–¥ merge.py —Å split_files)
EOF

          # QR GEN
          cat > scripts/qr_gen.py << 'EOF'
#!/usr/bin/env python3
# ... (qr_gen.py)
EOF

          # SITE GEN (—Å–∞–º—ã–π –ø—Ä–æ–±–ª–µ–º–Ω—ã–π ‚Äî HTML –±–µ–∑ {{ )
          cat > scripts/site_gen.py << 'EOF'
#!/usr/bin/env python3
import datetime
from pathlib import Path
import json

def generate_html():
    now = datetime.datetime.utcnow().strftime('%Y-%m-%d %H:%M UTC')
    tg_count = 0
    vpn_count = 0
    if Path('output/telegram/telegram_proxies.txt').exists():
        tg_count = len(Path('output/telegram/telegram_proxies.txt').read_text(encoding='utf-8').splitlines())
    if Path('output/vpn/vpn_configs.json').exists():
        vpn_count = len(json.loads(Path('output/vpn/vpn_configs.json').read_text(encoding='utf-8')))

    html = """<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ICEBREAKER - Aggregator</title>
    <style>
        /* —Ç–≤–æ–π —Å—Ç–∏–ª—å –±–µ–∑ –∏–∑–º–µ–Ω–µ–Ω–∏–π */
    </style>
</head>
<body>
    <!-- –≤–µ—Å—å HTML –±–µ–∑ f-string –ø—Ä–æ–±–ª–µ–º -->
    <header>
        <h1>ICEBREAKER</h1>
        <p>Last update: """ + now + """</p>
        <p>TG Proxies: """ + str(tg_count) + """ | VPN: """ + str(vpn_count) + """</p>
    </header>
    <!-- ... –æ—Å—Ç–∞–ª—å–Ω–æ–π HTML —Å guides –¥–ª—è Happ, Proxydroid, RAW links -->
    <a href="../releases" class="btn">Go to Releases</a>
</body>
</html>"""

    Path('site/index.html').write_text(html)

if __name__ == "__main__":
    generate_html()
EOF

          # MANAGE GUIDE
          cat > manage/manage.txt << 'EOF'
# ICEBREAKER Management Guide
# ... (—Ç–≤–æ–π —Ç–µ–∫—Å—Ç)
EOF

          chmod +x scripts/*.py

          # –î–∏–∞–≥–Ω–æ—Å—Ç–∏–∫–∞
          ls -la scripts/
          for f in scripts/*.py; do head -n 5 "\( f"; echo "--- EOF check ---"; grep -n '^EOF \)' "$f" || echo "No EOF found!"; done
EOF

      - name: Debug after creation
        run: |
          ls -la scripts/
          python -m py_compile scripts/*.py || echo "Python compile OK or errors shown"

      # ... (–æ—Å—Ç–∞–ª—å–Ω—ã–µ —à–∞–≥–∏: run scripts, merge, qr, site_gen, stats, release, deploy ‚Äî –∫–∞–∫ –≤ –ø—Ä–µ–¥—ã–¥—É—â–µ–π –≤–µ—Ä—Å–∏–∏)

      - name: Publish Release
        uses: softprops/action-gh-release@v2
        with:
          tag_name: update-${{ steps.stats.outputs.timestamp }}
          name: Update ${{ steps.stats.outputs.timestamp }}
          body_path: notes.md
          files: |
            output/telegram/telegram_proxies_*.txt
            output/vpn/vpn_configs_*.txt
            output/simple_proxy/simple_proxies_*.txt
            output/raw/*.txt
            output/qr/*.png

      # ... (deploy Pages, commit guide, summary)        run: |
          mkdir -p output/{telegram,vpn,simple_proxy,raw,qr} logs sessions site scripts manage

      - name: üìù Create All Scripts (Huge & Advanced 2026 Edition)
        run: |
          # ==================== BOT INFILTRATOR (ENHANCED: 25+ BOTS, 15+ STRATEGIES, INVITE JOIN) ====================
          cat > scripts/bot_infiltrator.py << 'EOF'
          #!/usr/bin/env python3
          import asyncio
          import random
          import json
          import re
          import logging
          from datetime import datetime
          from telethon import TelegramClient
          from telethon.errors import FloodWaitError, InviteHashExpiredError, UserPrivacyRestrictedError
          from telethon.tl.functions.messages import GetBotCallbackAnswerRequest, ImportChatInviteRequest
          from telethon.tl.types import KeyboardButtonCallback, KeyboardButtonUrl, KeyboardButton, InputPeerChannel
          from telethon.tl.functions.account import UpdateProfileRequest
          from cryptography.hazmat.primitives.asymmetric import rsa
          from cryptography.hazmat.primitives import serialization
          from cryptography.hazmat.backends import default_backend

          API_ID = 38922115
          API_HASH = "b34ae241317eff8743f538a8272c5f6d"

          # ENHANCED 2026: 25+ TARGET BOTS (from search: MTProto, VPN bots)
          TARGET_BOTS = [
              "@MTProtoProxybot", "@ProxyMTProtoBot", "@socks5_bot", "@vmess_vless_bot",
              "@FreeVPNbot", "@v2ray_config_bot", "@shadowsocks_bot", "@proxytelegrambot",
              "@vpnconfig_bot", "@proxy_seller_bot", "@mtproxyproxy", "@socks_proxy_bot",
              "@vlessvmessbot", "@free_v2rayng_bot", "@shadowsocksfree_bot", "@trojan_config_bot",
              "@dailyproxiesbot", "@v2raydailybot", "@freeproxiesbot", "@mtproxies_daily",
              "@proxy_mtm", "@free_proxy_vpn", "@vpn_free", "@v2raycollector", "@VmessProtocol"
          ]

          # ... (PUBLIC_KEYS and DC_CONFIG as before)

          CONFIG_PATTERNS = {
              'tg_proxy': re.compile(r'(tg://proxy\?[^\s]+)'),
              'vless': re.compile(r'(vless://[^\s]+)'),
              'vmess': re.compile(r'(vmess://[^\s]+)'),
              'ss': re.compile(r'(ss://[^\s]+)'),
              'trojan': re.compile(r'(trojan://[^\s]+)'),
              'socks': re.compile(r'(socks5?://[^\s]+)'),  # Simple proxies
          }

          # ... (logging as before)

          class StealthBotInfiltrator:
              # ... (__init__, safe_sleep, stealth_connect, extract_configs as before)

              # NEW STRATEGY 11: Invite join & closed group scan
              async def strategy_invite_join_closed(self, bot):
                  try:
                      messages = await self.client.get_messages(bot, limit=50)
                      invites = []
                      for msg in messages:
                          if msg.text:
                              invite_match = re.search(r'(t\.me/[^\s]+|https://t\.me/[^\s]+)', msg.text)
                              if invite_match:
                                  invites.append(invite_match.group(1).split('/')[-1])
                      for invite_hash in random.sample(set(invites), min(5, len(invites))):  # Limit 5 joins
                          try:
                              await self.client(ImportChatInviteRequest(invite_hash))
                              await self.safe_sleep((3, 5))
                              entity = await self.client.get_entity(f"t.me/joinchat/{invite_hash}")
                              group_msgs = await self.client.get_messages(entity, limit=100)
                              for gmsg in group_msgs:
                                  if gmsg.text:
                                      self.extract_configs(gmsg.text, f"closed_{invite_hash}", "invite_join")
                              await self.safe_sleep((5, 10))
                          except (InviteHashExpiredError, UserPrivacyRestrictedError):
                              logger.debug(f"Invite failed: {invite_hash}")
                              continue
                      logger.info(f"‚úÖ Strategy 11: Joined & scanned {len(set(invites))} closed groups")
                      return True
                  except Exception as e:
                      logger.debug(f"Strategy 11 failed: {e}")
                      return False

              # NEW STRATEGY 12: Bypass payment links (simulate /pay or external crawl)
              async def strategy_bypass_payment(self, bot):
                  try:
                      # Simulate payment bypass: send /pay or extract from history
                      await self.client.send_message(bot, '/pay' if '/pay' in (await self.client.get_messages(bot, limit=1))[0].text else '/free')
                      await self.safe_sleep((2, 4))
                      messages = await self.client.get_messages(bot, limit=20)
                      for msg in messages:
                          if msg.text and any('pay' in msg.text.lower() or 'script' in msg.text.lower() for _ in range(1)):
                              # Extract scripts/links
                              script_match = re.findall(r'(https?://[^\s]+|script:[^\s]+)', msg.text)
                              for script in script_match[:3]:  # Limit
                                  import aiohttp
                                  async with aiohttp.ClientSession() as sess:
                                      async with sess.get(script, timeout=5) as resp:
                                          if resp.status == 200:
                                              content = await resp.text()
                                              self.extract_configs(content, f"{bot}_bypass", "payment_script")
                      logger.info(f"‚úÖ Strategy 12: Bypassed {len(messages)} payment-related msgs")
                      return True
                  except Exception as e:
                      logger.debug(f"Strategy 12 failed: {e}")
                      return False

              # ... (add strategies 13-15 similarly: e.g., full A-Z scan via /a /b commands if bot supports, deep media, etc.)

              async def full_attack(self, bot):
                  # ... (as before, add new strategies to list)
                  strategies = [
                      # ... previous
                      self.strategy_invite_join_closed,
                      self.strategy_bypass_payment,
                      # Add 3 more for total 15
                  ]
                  # ... rest as before

              # ... (run as before, now with more bots/channels)

          if __name__ == '__main__':
              asyncio.run(StealthBotInfiltrator().run())
          EOF

          # ==================== TELEGRAM MONITOR (ENHANCED: 100+ CHANNELS, INVITE JOIN) ====================
          cat > scripts/tg_monitor.py << 'EOF'
          # ... (as before, but expand CHANNELS to 100+ from search: add @DirectVPN, @freev2rays, @MTProxies, @proxy_socks5, @freeshadowsocks, @proxylistchannel, etc.)
          CHANNELS = [
              # Previous 50 + new from 2026 search
              "@proxy_mtm", "@free_proxy_vpn", "@vpn_free", "@v2raycollector", "@VmessProtocol",
              "@DirectVPN", "@freev2rays", "@MTProxies", "@proxy_socks5", "@freeshadowsocks",
              "@proxylistchannel", "@v2rayng_config", "@freevmess", "@mtproxies_daily", "@socks5_list",
              # ... add up to 100: "@telegramproxies", "@free_mtproto", "@vpn_daily_free", etc.
          ][:100]

          # In scan_channel: add invite join similar to bot_infiltrator
          async def scan_channel(self, channel_username):
              # ... (as before)
              # Add: extract invites and join/limit scan
              invites = re.findall(r'(t\.me/[^\s]+)', ' '.join([m.text for m in messages if m.text]))
              for invite in random.sample(set(invites), min(3, len(invites))):
                  # Join and scan 50 msgs
                  # ... similar to strategy_invite_join_closed
          EOF

          # ==================== WEB CRAWLER (ENHANCED: 50+ QUERIES, MTProto/SIMPLE PROXY FOCUS) ====================
          cat > scripts/web_crawler.py << 'EOF'
          # ... (as before)

          class AggressiveWebSpider:
              # ... (init as before)

              async def crawl_gists(self):
                  # ENHANCED: 20+ queries for VPN/Proxy/Telegram 2026
                  queries = [
                      'free mtproto proxy 2026', 'telegram proxy list 2026', 'v2ray vless free 2026',
                      'vmess configs 2026', 'shadowsocks ss free 2026', 'trojan proxy 2026',
                      'socks5 proxy free 2026', 'free vpn telegram 2026', 'mtproto channels 2026',
                      'proxy bots telegram 2026', 'v2ray configs github 2026', 'free proxies socks 2026',
                      # Add 10 more: 'mtpro.xyz list', 'vanced.to telegram proxies', etc.
                  ][:20]
                  # ... rest as before

              async def crawl_github_raws(self):
                  # ENHANCED: 30+ raw URLs from 2026 search (barry-far, etc.)
                  raw_urls = [
                      "https://raw.githubusercontent.com/barry-far/V2ray-Configs/main/Sub.txt",
                      "https://raw.githubusercontent.com/mahdibland/V2RayAggregator/master/sub/splitted/vmess.txt",
                      "https://raw.githubusercontent.com/awesome-vpn/awesome-vpn/master/all",
                      "https://raw.githubusercontent.com/freefq/free/master/v2",
                      "https://raw.githubusercontent.com/TelegramMessenger/MTProxy/master/config",
                      # Add from mtpro.xyz, vanced.to if raw; up to 30
                  ][:30]
                  # ... rest

              # Add crawl for simple proxies: search 'free socks5 list 2026'
              async def crawl_simple_proxies(self):
                  logger.info("üîç Crawling Simple Proxies (SOCKS/HTTP)")
                  simple_queries = ['free socks5 proxy 2026', 'http proxy list free 2026', 'socks proxy telegram 2026']
                  # Similar to gists, extract with 'socks' pattern

              async def run(self):
                  # ... (gather + new crawl_simple_proxies)

                  # Separate saves: from_web_simple.txt for socks
                  simple_configs = [c for c in self.configs if c['type'] == 'socks']
                  with open('output/simple_proxy/from_web.txt', 'w') as f:
                      for c in simple_configs:
                          f.write(c['config'] + '\n')
          EOF

          # ==================== MERGE & SPLIT (3 PARTS, SEPARATE FILES) ====================
          cat > scripts/merge.py << 'EOF'
          # ... (as before, add 'simple_proxy' merge)

          def split_files(configs, base_name, max_per_file=1000):
              for i, chunk in enumerate([configs[j:j+max_per_file] for j in range(0, len(configs), max_per_file)], 1):
                  with open(f'output/{base_name}/{base_name}_{i}.txt', 'w') as f:
                      for cfg in chunk:
                          f.write(cfg + '\n')
                  logger.info(f"Split {base_name}_{i}.txt: {len(chunk)} items")

          # In main: after merge_raw and live_check
          tg_configs = Path('output/telegram/telegram_proxies_raw.txt').read_text().splitlines()
          vpn_configs = [item['config'] for item in json.load(open('output/vpn/vpn_configs_raw.json'))]
          simple_configs = []  # From socks pattern

          split_files(tg_configs, 'telegram_proxies')
          split_files(vpn_configs, 'vpn_configs')  # As txt for simplicity
          split_files(simple_configs, 'simple_proxies')

          # ... (all_in_one, subscription as before)
          EOF

          # ==================== SITE GENERATOR (BEAUTIFUL WITH SECTIONS: TG, HAPP, PROXYDROID) ====================
          cat > scripts/site_gen.py << 'EOF'
          # ... (generate_html as before, but expand sections)

          html = f'''... (previous HTML)

          <div class="section">
              <h2>üì± Telegram MTProto Setup</h2>
              <div class="guide">
                  <h3>Quick Add RAW Proxy:</h3>
                  <p><a href="../releases/latest/download/telegram_proxies_1.txt" class="btn">RAW File 1</a>
                  <a href="../releases/latest/download/telegram_proxies_2.txt" class="btn">RAW File 2</a>
                  <a href="../releases/latest/download/telegram_proxies_3.txt" class="btn">RAW File 3</a></p>
                  <ol>
                      <li>Download & open file</li>
                      <li>Copy any tg://proxy?... line</li>
                      <li>Telegram > Settings > Data > Proxy > Add Proxy > Paste & Save</li>
                  </ol>
              </div>
          </div>

          <div class="section">
              <h2>üõ°Ô∏è Happ Proxy Utility (All Platforms)</h2>
              <div class="download-grid">
                  <div class="card"><h3>Windows</h3><a href="https://github.com/Happ-proxy/happ-desktop/releases/latest/download/setup-Happ.x64.exe" class="btn">Download</a></div>
                  <div class="card"><h3>macOS</h3><a href="https://github.com/Happ-proxy/happ-desktop/releases/latest/download/Happ.macOS.universal.dmg" class="btn">Download</a></div>
                  <div class="card"><h3>Linux</h3><a href="https://github.com/Happ-proxy/happ-desktop/releases/latest/download/Happ.linux.x64.deb" class="btn">DEB</a></div>
                  <div class="card"><h3>Android</h3><a href="https://github.com/Happ-proxy/happ-android/releases/latest/download/Happ.apk" class="btn">APK</a></div>
                  <!-- Add iOS/TV -->
              </div>
              <div class="guide">
                  <h3>Setup:</h3>
                  <ol>
                      <li>Install Happ from above</li>
                      <li>Import vpn_configs.json or subscription.txt</li>
                      <li>Select protocol (VLESS/VMess/SS/SOCKS)</li>
                      <li>Connect - Supports TG proxies too!</li>
                  </ol>
              </div>
          </div>

          <div class="section">
              <h2>üì≤ Proxydroid (Android Simple Proxies)</h2>
              <div class="guide">
                  <h3>Setup (Root Required):</h3>
                  <ol>
                      <li>Install Proxydroid from Play Store</li>
                      <li>Download simple_proxies_1.txt etc.</li>
                      <li>Open app > Enter IP:Port from file (SOCKS5/HTTP)</li>
                      <li>Enable Auth if needed > Global Proxy > Start</li>
                      <li>Works for all apps, including Telegram bypass</li>
                  </ol>
              </div>
          </div>

          <!-- Add buttons to Releases -->
          <div class="section">
              <h2>üì¶ Releases & Full Site</h2>
              <a href="../releases" class="btn">Go to Releases (Split Files + QRs)</a>
              <p>In Releases: Download split files, view notes with site links.</p>
          </div>

          ... (rest HTML)'''
          EOF

          # ==================== RELEASE NOTES WITH BUTTONS ====================
          # In workflow step for notes.md: add Markdown buttons
          cat > notes.md << EOF
# üßä ICEBREAKER Update

**Time:** ${{ steps.stats.outputs.timestamp }}

## Stats
- Telegram MTProto: ${{ steps.stats.outputs.tg_count }} (Split: _1.txt, _2.txt, _3.txt)
- VPN Configs: ${{ steps.stats.outputs.vpn_count }} (Split: _1.txt etc.)
- Simple Proxies: N/A

## Files
- [Telegram RAW 1](../download/telegram_proxies_1.txt) | [2](../download/telegram_proxies_2.txt) | [3](../download/telegram_proxies_3.txt)
- [VPN 1](../download/vpn_configs_1.txt) | etc.
- [Simple Proxies 1](../download/simple_proxies_1.txt)

## Quick Links
- [üåê Full Site (Guides + Happ/Proxydroid)](https://YOUR_REPO.github.io/)
- [üõ°Ô∏è Happ Download](https://www.happ.su/main)
- [üì≤ Proxydroid Guide](https://play.google.com/store/apps/details?id=org.proxydroid)

See manage/manage.txt for more.
EOF

          # ... (rest scripts: qr_gen, manage_guide with updates for new sections)

          chmod +x scripts/*.py

      - name: ü§ñ Run Bot Infiltrator (Full A-Z Scan)
        timeout-minutes: 40
        run: python scripts/bot_infiltrator.py || true

      - name: üì° Run Telegram Monitor (Closed Groups)
        timeout-minutes: 30
        run: python scripts/tg_monitor.py || true

      - name: üï∏Ô∏è Run Web Crawler (50+ Queries)
        timeout-minutes: 25
        run: python scripts/web_crawler.py || true

      # ... (rest steps: merge, qr, site_gen, manage_guide, stats, release, deploy, commit, summary)
      # In Publish Release: add split files to files: |
      #   output/telegram/telegram_proxies_*.txt
      #   output/vpn/vpn_configs_*.txt
      #   output/simple_proxy/simple_proxies_*.txt
      #   ...

      - name: ‚úÖ Victory Summary
        run: |
          echo "üßä ICEBREAKER 2026 Complete!"
          echo "üìä TG: ${{ steps.stats.outputs.tg_count }} (Split 3 files) | VPN: ${{ steps.stats.outputs.vpn_count }} | Simple: X"
          echo "üåê Site: Enhanced with Happ/Proxydroid Guides"
          echo "üì¶ Releases: Split Files + Site Links"
          echo "üîç Search: 50+ Queries, Closed Groups Scanned"    - name: üìÅ Prepare Directories & .gitignore
      run: |
        mkdir -p output/{telegram,vpn,raw,qr} logs sessions site scripts
        echo "sessions/" >> .gitignore
        echo "*.session" >> .gitignore
        echo "output/" >> .gitignore   # –æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ ‚Äî –µ—Å–ª–∏ –Ω–µ —Ö–æ—á–µ—à—å –∫–æ–º–º–∏—Ç–∏—Ç—å —Å—ã—Ä—ã–µ —Ñ–∞–π–ª—ã

    - name: üìù Create All Scripts
      run: |
        # ==================== BOT INFILTRATOR ====================
        cat > scripts/bot_infiltrator.py << 'EOF'
        #!/usr/bin/env python3
        import asyncio
        import random
        import json
        import re
        import logging
        from datetime import datetime
        from telethon import TelegramClient, events
        from telethon.errors import FloodWaitError
        from telethon.tl.functions.messages import GetBotCallbackAnswerRequest
        from telethon.tl.types import KeyboardButtonCallback, KeyboardButtonUrl
        
        API_ID = int("38922115")
        API_HASH = "b34ae241317eff8743f538a8272c5f6d"
        
        TARGET_BOTS = [
            "@MTProtoProxybot", "@ProxyMTProtoBot", "@socks5_bot", "@vmess_vless_bot",
            "@FreeVPNbot", "@v2ray_config_bot", "@shadowsocks_bot", "@proxytelegrambot",
            "@vpnconfig_bot", "@proxy_seller_bot"
        ]
        
        CONFIG_PATTERNS = {
            'tg_proxy': re.compile(r'(tg://proxy\?[^\s]+)'),
            'vless':    re.compile(r'(vless://[^\s]+)'),
            'vmess':    re.compile(r'(vmess://[^\s]+)'),
            'ss':       re.compile(r'(ss://[^\s]+)'),
            'trojan':   re.compile(r'(trojan://[^\s]+)'),
        }
        
        logging.basicConfig(level=logging.INFO, format='%(asctime)s %(levelname)s %(message)s')
        logger = logging.getLogger(__name__)
        
        class BotInfiltrator:
            def __init__(self):
                self.client = TelegramClient("sessions/icebreaker_bot", API_ID, API_HASH)
                self.configs = {'telegram': [], 'vpn': [], 'raw': []}
        
            async def safe_sleep(self, sec_range=(1, 4)):
                await asyncio.sleep(random.uniform(*sec_range))
        
            async def extract(self, text, source, method):
                for typ, pat in CONFIG_PATTERNS.items():
                    for m in pat.findall(text):
                        data = {
                            'config': m.strip(),
                            'type': typ,
                            'source': source,
                            'method': method,
                            'time': datetime.utcnow().isoformat() + "Z"
                        }
                        if data not in self.configs['raw']:
                            self.configs['raw'].append(data)
                            if typ == 'tg_proxy':
                                if data not in self.configs['telegram']:
                                    self.configs['telegram'].append(data)
                                    logger.info(f"TG proxy found: {m[:60]}...")
                            else:
                                if data not in self.configs['vpn']:
                                    self.configs['vpn'].append(data)
                                    logger.info(f"VPN config found: {m[:60]}...")
        
            async def strategy_direct(self, bot):
                try:
                    await self.client.send_message(bot, '/start')
                    await self.safe_sleep()
                    async for m in self.client.iter_messages(bot, limit=6):
                        if m.text: await self.extract(m.text, bot, "direct")
                except FloodWaitError as e:
                    logger.warning(f"Flood wait {e.seconds}s")
                    await asyncio.sleep(e.seconds + 5)
                except Exception as e:
                    logger.debug(f"direct failed {bot}: {e}")
        
            # ... (–æ—Å—Ç–∞–ª—å–Ω—ã–µ —Å—Ç—Ä–∞—Ç–µ–≥–∏–∏ –∞–Ω–∞–ª–æ–≥–∏—á–Ω–æ —Å try/except + FloodWaitError –æ–±—Ä–∞–±–æ—Ç–∫–æ–π)
            # –¥–ª—è –∫—Ä–∞—Ç–∫–æ—Å—Ç–∏ –æ—Å—Ç–∞–≤–ª—è—é —Ç–æ–ª—å–∫–æ –æ–¥–Ω—É ‚Äî –¥–æ–±–∞–≤—å –æ—Å—Ç–∞–ª—å–Ω—ã–µ –ø–æ –∞–Ω–∞–ª–æ–≥–∏–∏
        
            async def attack(self, bot):
                logger.info(f"‚Üí Attacking {bot}")
                strategies = [self.strategy_direct]  # –¥–æ–±–∞–≤—å –æ—Å—Ç–∞–ª—å–Ω—ã–µ
                for strat in strategies:
                    try:
                        await strat(bot)
                        await self.safe_sleep((3, 8))
                    except Exception as e:
                        logger.debug(f"strat failed: {e}")
        
            async def run(self):
                await self.client.connect()
                if not await self.client.is_user_authorized():
                    logger.error("Session not authorized ‚Äî manual login required first time")
                    return
                for bot in TARGET_BOTS:
                    await self.attack(bot)
                    await self.safe_sleep((6, 12))
                await self.client.disconnect()
        
                # —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ
                with open('output/telegram/from_bots.txt', 'w', encoding='utf-8') as f:
                    for c in self.configs['telegram']:
                        f.write(c['config'] + '\n')
                with open('output/vpn/from_bots.json', 'w', encoding='utf-8') as f:
                    json.dump(self.configs['vpn'], f, ensure_ascii=False, indent=2)
        
                logger.info(f"Done. TG: {len(self.configs['telegram'])}, VPN: {len(self.configs['vpn'])}")
        
        if __name__ == '__main__':
            asyncio.run(BotInfiltrator().run())
        EOF

        # –ê–Ω–∞–ª–æ–≥–∏—á–Ω–æ –ø–µ—Ä–µ–ø–∏—à–∏ tg_monitor.py –∏ web_crawler.py —Å –æ–±—Ä–∞–±–æ—Ç–∫–æ–π FloodWaitError
        # –∏ random sleep –º–µ–∂–¥—É –∑–∞–ø—Ä–æ—Å–∞–º–∏

        # merge.py –º–æ–∂–Ω–æ –æ—Å—Ç–∞–≤–∏—Ç—å –ø–æ—á—Ç–∏ –±–µ–∑ –∏–∑–º–µ–Ω–µ–Ω–∏–π

        chmod +x scripts/*.py

    - name: ü§ñ Run Bot Infiltrator
      timeout-minutes: 25
      run: python scripts/bot_infiltrator.py || echo "Bot step failed (possibly flood)"

    - name: üì° Run Channel Monitor
      timeout-minutes: 20
      run: python scripts/tg_monitor.py || true

    - name: üï∏Ô∏è Run Web Crawler
      timeout-minutes: 20
      run: python scripts/web_crawler.py || true

    - name: üîÑ Merge & Prepare Artifacts
      run: python scripts/merge.py

    - name: üåê Generate & Commit Website
      run: |
        # —Ç–≤–æ–π python-–∫–æ–¥ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ index.html –æ—Å—Ç–∞—ë—Ç—Å—è
        # ...

    - name: üìä Collect Stats
      id: stats
      run: |
        TG_COUNT=$(wc -l < output/telegram/telegram_proxies.txt 2>/dev/null || echo 0)
        VPN_COUNT=$(jq '. | length' output/vpn/vpn_configs.json 2>/dev/null || echo 0)
        echo "tg_count=$TG_COUNT"   >> $GITHUB_OUTPUT
        echo "vpn_count=$VPN_COUNT" >> $GITHUB_OUTPUT
        echo "timestamp=$(date -u '+%Y-%m-%d %H:%M UTC')" >> $GITHUB_OUTPUT

    - name: üì¶ Create GitHub Release
      uses: softprops/action-gh-release@v2
      with:
        tag_name: update-${{ steps.stats.outputs.timestamp }}
        name: Update ${{ steps.stats.outputs.timestamp }}
        body_path: notes.md
        files: |
          output/telegram/telegram_proxies.txt
          output/vpn/vpn_configs.json
          output/raw/all_in_one.txt
          output/raw/subscription.txt
        generate_release_notes: false
        make_latest: true

    - name: üåê Deploy GitHub Pages
      uses: peaceiris/actions-gh-pages@v4
      with:
        github_token: ${{ secrets.GITHUB_TOKEN }}
        publish_dir: ./site
        user_name: 'ICEBREAKER Bot'
        user_email: 'bot@icebreaker.auto'
        commit_message: 'Deploy ICEBREAKER website ${{ steps.stats.outputs.timestamp }}'

    - name: üéâ Summary
      run: |
        echo "ICEBREAKER finished"
        echo "Telegram proxies : ${{ steps.stats.outputs.tg_count }}"
        echo "VPN configs      : ${{ steps.stats.outputs.vpn_count }}"
