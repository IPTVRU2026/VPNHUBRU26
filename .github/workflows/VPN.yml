name: üßä ICEBREAKER - Global Stealth Aggregator

on:
  schedule:
    - cron: '23 */1 * * *'
  workflow_dispatch:
  push:
    branches: [ main ]

permissions:
  contents: write
  pages: write
  id-token: write

concurrency:
  group: "icebreaker"
  cancel-in-progress: true

jobs:
  stealth-harvest:
    runs-on: ubuntu-latest
    timeout-minutes: 35
    
    steps:
    - name: ‚è≥ Random stealth delay
      run: |
        DELAY=$(( RANDOM % 300 + 60 ))
        echo "Waiting for $DELAY seconds..."
        sleep $DELAY
    
    - name: üì• Checkout repository
      uses: actions/checkout@v4
      with:
        fetch-depth: 1
    
    - name: üêç Setup Python
      uses: actions/setup-python@v5
      with:
        python-version: '3.11'
    
    - name: üì¶ Install dependencies
      run: |
        pip install --upgrade pip
        pip install telethon pyrogram tgcrypto aiohttp beautifulsoup4 requests qrcode[pil] pillow cryptography fake-useragent colorama
        
    - name: üîë Setup Telegram credentials
      run: |
        cat > telegram_config.py << 'EOF'
# Telegram API credentials
API_ID = 38922115
API_HASH = "b34ae241317eff8743f538a8272c5f6d"

# DC 2 Configuration
DC_IP = "149.154.167.50"
DC_PORT = 443
DC_PUBLIC_KEY = """-----BEGIN RSA PUBLIC KEY-----
MIIBCgKCAQEA6LszBcC1LGzyr992NzE0ieY+BSaOW622Aa9Bd4ZHLl+TuFQ4lo4g
5nKaMBwK/BIb9xUfg0Q29/2mgIR6Zr9krM7HjuIcCzFvDtr+L0GQjae9H0pRB2OO
62cECs5HKhT5DZ98K33vmWiLowc621dQuwKWSQKjWf50XYFw42h21P2KXUGyp2y/
+aEyZ+uVgLLQbRA1dEjSDZ2iGRy12Mk5gpYc397aYp438fsJoHIgJ2lgMv5h7WY9
t6N/byY9Nw9p21Og3AoXSL2q/2IJ1WRUhebgAdGVMlV1fkuOQoEzR7EdpqtQD9Cs
5+bfo3Nhmcyvk5ftB0WkJ9z6bNZ7yxrP8wIDAQAB
-----END RSA PUBLIC KEY-----"""

# DC 1 Configuration (backup)
DC1_IP = "149.154.175.50"
DC1_PORT = 443
DC1_PUBLIC_KEY = """-----BEGIN RSA PUBLIC KEY-----
MIIBCgKCAQEAyMEdY1aR+sCR3ZSJrtztKTKqigvO/vBfqACJLZtS7QMgCGXJ6XIR
yy7mx66W0/sOFa7/1mAZtEoIokDP3ShoqF4fVNb6XeqgQfaUHd8wJpDWHcR2OFwv
plUUI1PLTktZ9u2WWE23b+ixNwJjJGwBDJPQEQFBE+vfmH0JP503wr5INS1poWg/
j25sIWeYPHYeOrFp/eXaqhISP6G+q2IeTaWTXpwZj4LzXq5YOpk4bYEQ6mvRq7D1
aHWfYmlEGepfaYR8QY0qvvhYtMte3ITnuSJs171+GDqpdKcSwHnd6FudwGO4pcCO
j4WcDuXc2CTHgH8gFTNhp/Y8/SpDOhvn9QIDAQAB
-----END RSA PUBLIC KEY-----"""
EOF
        
    - name: ü§ñ Bot Cracker Engine
      run: |
        cat > bot_cracker.py << 'EOF'
import asyncio
from telethon import TelegramClient
import random
import re
import time
from datetime import datetime
import json

class BotCracker:
    def __init__(self):
        from telegram_config import API_ID, API_HASH, DC_IP, DC_PORT
        self.api_id = API_ID
        self.api_hash = API_HASH
        self.dc_ip = DC_IP
        self.dc_port = DC_PORT
        self.client = None
        self.found_configs = []
        
    async def create_client(self, session_name):
        """–°–æ–∑–¥–∞–Ω–∏–µ –∫–ª–∏–µ–Ω—Ç–∞ —Å –ø–æ–¥–∫–ª—é—á–µ–Ω–∏–µ–º –∫ DC 2"""
        self.client = TelegramClient(
            session_name,
            self.api_id,
            self.api_hash
        )
        await self.client.connect()
        return self.client
    
    async def attack_bot_10ways(self, bot_username):
        """10 —Å–ø–æ—Å–æ–±–æ–≤ –≤–∑–ª–æ–º–∞ –±–æ—Ç–∞"""
        results = []
        
        try:
            client = await self.create_client(f"session_{random.randint(1000,9999)}")
            entity = await client.get_entity(bot_username)
            
            # –°–ø–æ—Å–æ–± 1: –ë–∞–∑–æ–≤—ã–µ –∫–æ–º–∞–Ω–¥—ã
            basic_commands = ['/start', '/help', '/menu']
            for cmd in basic_commands:
                await client.send_message(entity, cmd)
                await asyncio.sleep(1)
            
            # –°–ø–æ—Å–æ–± 2: –ö–æ–º–∞–Ω–¥—ã –ø–æ–ª—É—á–µ–Ω–∏—è
            get_commands = ['/free', '/get', '/proxy', '/config', '/v2ray', '/key']
            for cmd in get_commands:
                msg = await client.send_message(entity, cmd)
                await asyncio.sleep(0.5)
                reply = await client.get_messages(entity, limit=1)
                if reply and reply[0].text:
                    configs = self.extract_configs(reply[0].text)
                    results.extend(configs)
            
            # –°–ø–æ—Å–æ–± 3: –ö–ª–∏–∫ –ø–æ –∫–Ω–æ–ø–∫–∞–º
            msgs = await client.get_messages(entity, limit=5)
            for msg in msgs:
                if msg.buttons:
                    for row in msg.buttons:
                        for btn in row[:3]:
                            try:
                                await btn.click()
                                await asyncio.sleep(1)
                                updates = await client.get_messages(entity, limit=1)
                                if updates and updates[0].text:
                                    results.extend(self.extract_configs(updates[0].text))
                            except:
                                continue
            
            # –°–ø–æ—Å–æ–± 4: –¢–µ—Å—Ç–æ–≤—ã–µ –∫–æ–º–∞–Ω–¥—ã
            test_commands = ['/test', '/trial', '/demo', '/sample']
            for cmd in test_commands:
                await client.send_message(entity, cmd)
                await asyncio.sleep(1)
                reply = await client.get_messages(entity, limit=1)
                if reply and reply[0].text:
                    results.extend(self.extract_configs(reply[0].text))
            
            # –°–ø–æ—Å–æ–± 5: –ö–æ–º–∞–Ω–¥—ã –Ω–∞ —Ä—É—Å—Å–∫–æ–º
            ru_commands = ['/–±–µ—Å–ø–ª–∞—Ç–Ω–æ', '/–ø—Ä–æ–∫—Å–∏', '/–∫–ª—é—á', '/–ø–æ–ª—É—á–∏—Ç—å']
            for cmd in ru_commands:
                await client.send_message(entity, cmd)
                await asyncio.sleep(1)
                reply = await client.get_messages(entity, limit=1)
                if reply and reply[0].text:
                    results.extend(self.extract_configs(reply[0].text))
            
            # –°–ø–æ—Å–æ–± 6: –†–∞–∑–Ω—ã–µ —Ñ–æ—Ä–º–∞—Ç—ã
            format_commands = ['/vless', '/vmess', '/ss', '/trojan', '/mtproto']
            for cmd in format_commands:
                await client.send_message(entity, cmd)
                await asyncio.sleep(1)
                reply = await client.get_messages(entity, limit=1)
                if reply and reply[0].text:
                    results.extend(self.extract_configs(reply[0].text))
            
            # –°–ø–æ—Å–æ–± 7: –°–ª—É—á–∞–π–Ω—ã–µ —Å–∏–º–≤–æ–ª—ã
            random_chars = ['/test123', '/get123', '/free123', '/config123']
            for cmd in random_chars:
                await client.send_message(entity, cmd)
                await asyncio.sleep(0.5)
            
            # –°–ø–æ—Å–æ–± 8: –ü–æ–≤—Ç–æ—Ä–Ω–∞—è –æ—Ç–ø—Ä–∞–≤–∫–∞
            for _ in range(3):
                await client.send_message(entity, '/start')
                await asyncio.sleep(2)
                reply = await client.get_messages(entity, limit=1)
                if reply and reply[0].text:
                    results.extend(self.extract_configs(reply[0].text))
            
            # –°–ø–æ—Å–æ–± 9: –ü—Ä–æ–≤–µ—Ä–∫–∞ –≤—Å–µ—Ö —Å–æ–æ–±—â–µ–Ω–∏–π
            all_msgs = await client.get_messages(entity, limit=20)
            for msg in all_msgs:
                if msg.text:
                    results.extend(self.extract_configs(msg.text))
            
            # –°–ø–æ—Å–æ–± 10: –î–ª–∏–Ω–Ω—ã–µ –∫–æ–º–∞–Ω–¥—ã
            long_commands = ['/get_free_proxy_now', '/generate_v2ray_config', '/create_trial_account']
            for cmd in long_commands:
                await client.send_message(entity, cmd)
                await asyncio.sleep(1)
            
            await client.disconnect()
            
        except Exception as e:
            print(f"Error attacking {bot_username}: {e}")
        
        return list(set(results))
    
    def extract_configs(self, text):
        """–ò–∑–≤–ª–µ—á–µ–Ω–∏–µ –∫–æ–Ω—Ñ–∏–≥–æ–≤ –∏–∑ —Ç–µ–∫—Å—Ç–∞"""
        if not text:
            return []
        
        patterns = [
            r'(vless://[a-zA-Z0-9\-_.@:/?#[\]@!$&\'()*+,;=%]+)',
            r'(vmess://[a-zA-Z0-9\-_.+/=]+)',
            r'(ss://[a-zA-Z0-9\-_.@:/?#[\]@!$&\'()*+,;=%]+)',
            r'(trojan://[a-zA-Z0-9\-_.@:/?#[\]@!$&\'()*+,;=%]+)',
            r'(tg://proxy\?[a-zA-Z0-9\-_.@:/?#[\]@!$&\'()*+,;=%]+)',
            r'(mtproto://[a-zA-Z0-9\-_.@:/?#[\]@!$&\'()*+,;=%]+)',
            r'(https://t\.me/proxy\?[a-zA-Z0-9\-_.@:/?#[\]@!$&\'()*+,;=%]+)'
        ]
        
        found = []
        for pattern in patterns:
            found.extend(re.findall(pattern, text))
        return found

EOF
        
    - name: üï∑Ô∏è Universal Scanner
      run: |
        cat > scanner.py << 'EOF'
import asyncio
from telethon import TelegramClient
from telethon.tl.functions.messages import SearchRequest
from telethon.tl.types import InputMessagesFilterEmpty, InputPeerEmpty
from datetime import datetime, timedelta

class UniversalScanner:
    def __init__(self):
        from telegram_config import API_ID, API_HASH
        self.api_id = API_ID
        self.api_hash = API_HASH
        self.client = None
        self.bots = set()
        self.configs = []
        
    async def initialize(self):
        self.client = TelegramClient('scanner', self.api_id, self.api_hash)
        await self.client.start()
        
    async def scan_public_sources(self):
        """–°–∫–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ –ø—É–±–ª–∏—á–Ω—ã—Ö –∏—Å—Ç–æ—á–Ω–∏–∫–æ–≤"""
        sources = [
            '@proxy_list', '@v2ray_configs', '@free_proxy',
            '@vpn_configs', '@telegram_proxy', '@mtproto_proxies',
            '@shadowsocks_list', '@vless_proxies'
        ]
        
        for source in sources:
            try:
                entity = await self.client.get_entity(source)
                msgs = await self.client.get_messages(entity, limit=50)
                
                for msg in msgs:
                    if msg.text:
                        # –ò—â–µ–º –∫–æ–Ω—Ñ–∏–≥–∏
                        configs = self.extract_configs(msg.text)
                        self.configs.extend(configs)
                        
                        # –ò—â–µ–º –±–æ—Ç–æ–≤
                        bots = re.findall(r'@(\w+bot)', msg.text, re.I)
                        self.bots.update(bots)
            except:
                continue
    
    async def search_by_keywords(self):
        """–ü–æ–∏—Å–∫ –ø–æ –∫–ª—é—á–µ–≤—ã–º —Å–ª–æ–≤–∞–º"""
        keywords = [
            'free proxy', 'v2ray config', 'shadowsocks',
            'telegram proxy', 'mtproto', 'vless', 'vmess'
        ]
        
        for keyword in keywords:
            try:
                result = await self.client(SearchRequest(
                    peer=InputPeerEmpty(),
                    q=keyword,
                    filter=InputMessagesFilterEmpty(),
                    min_date=datetime.now() - timedelta(days=7),
                    max_date=datetime.now(),
                    offset_id=0,
                    add_offset=0,
                    limit=50,
                    max_id=0,
                    min_id=0,
                    hash=0
                ))
                
                for msg in result.messages:
                    if hasattr(msg, 'message') and msg.message:
                        configs = self.extract_configs(msg.message)
                        self.configs.extend(configs)
            except:
                continue
    
    def extract_configs(self, text):
        """–ò–∑–≤–ª–µ—á–µ–Ω–∏–µ –∫–æ–Ω—Ñ–∏–≥–æ–≤"""
        import re
        patterns = [
            r'(vless://[^\s]+)',
            r'(vmess://[^\s]+)',
            r'(ss://[^\s]+)',
            r'(trojan://[^\s]+)',
            r'(tg://proxy[^\s]+)'
        ]
        
        found = []
        for pattern in patterns:
            found.extend(re.findall(pattern, text))
        return found

EOF
        
    - name: ‚ö° Config Checker
      run: |
        cat > checker.py << 'EOF'
import asyncio
import aiohttp
import time

class ConfigChecker:
    async def check_config(self, config):
        """–ü—Ä–æ–≤–µ—Ä–∫–∞ –∫–æ–Ω—Ñ–∏–≥–∞ –Ω–∞ –¥–æ—Å—Ç—É–ø–Ω–æ—Å—Ç—å"""
        start = time.time()
        
        try:
            if config.startswith('tg://'):
                # –ü—Ä–æ–≤–µ—Ä–∫–∞ Telegram –ø—Ä–æ–∫—Å–∏
                async with aiohttp.ClientSession() as session:
                    async with session.get('https://telegram.org', proxy=config) as resp:
                        if resp.status == 200:
                            ping = (time.time() - start) * 1000
                            return {'config': config, 'ping': ping, 'status': 'active'}
            else:
                # –ü—Ä–æ–≤–µ—Ä–∫–∞ VPN –∫–æ–Ω—Ñ–∏–≥–æ–≤
                async with aiohttp.ClientSession() as session:
                    async with session.get('https://google.com', timeout=5) as resp:
                        if resp.status == 200:
                            ping = (time.time() - start) * 1000
                            return {'config': config, 'ping': ping, 'status': 'active'}
        except:
            pass
        
        return None
    
    async def check_all(self, configs):
        """–ü—Ä–æ–≤–µ—Ä–∫–∞ –≤—Å–µ—Ö –∫–æ–Ω—Ñ–∏–≥–æ–≤"""
        tasks = [self.check_config(c) for c in configs[:100]]
        results = await asyncio.gather(*tasks)
        
        # –§–∏–ª—å—Ç—Ä—É–µ–º —Ä–∞–±–æ—á–∏–µ –∏ —Å–æ—Ä—Ç–∏—Ä—É–µ–º –ø–æ –ø–∏–Ω–≥—É
        working = [r for r in results if r]
        working.sort(key=lambda x: x['ping'])
        
        return working[:30]  # –¢–æ–ø-30 –ª—É—á—à–∏—Ö

EOF
        
    - name: üé® Dashboard Generator
      run: |
        cat > dashboard.py << 'EOF'
import qrcode
import json
from datetime import datetime
import base64
from io import BytesIO

class DashboardGenerator:
    def generate_qr(self, data):
        qr = qrcode.QRCode(box_size=8, border=2)
        qr.add_data(data)
        img = qr.make_image(fill_color="#00ff9d", back_color="#0a0c0f")
        
        buffered = BytesIO()
        img.save(buffered, format="PNG")
        return base64.b64encode(buffered.getvalue()).decode()
    
    def generate_html(self, configs, stats):
        cards = ""
        
        for i, cfg in enumerate(configs[:9]):
            qr = self.generate_qr(cfg['config'])
            cfg_type = "Telegram" if "tg://" in cfg['config'] else "VPN"
            
            cards += f"""
            <div class="config-card" data-type="{cfg_type.lower()}">
                <div class="config-header">
                    <span class="config-type">{cfg_type}</span>
                    <span class="config-ping">{int(cfg['ping'])}ms</span>
                </div>
                <div class="config-qr">
                    <img src="data:image/png;base64,{qr}" alt="QR">
                </div>
                <button class="copy-btn" onclick="copyConfig('{cfg['config']}')">
                    üìã –ö–æ–ø–∏—Ä–æ–≤–∞—Ç—å
                </button>
            </div>
            """
        
        html = f"""<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üßä ICEBREAKER - Free Internet</title>
    <style>
        * {{
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }}
        body {{
            background: #0a0c0f;
            color: #fff;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            line-height: 1.6;
        }}
        .container {{
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }}
        .header {{
            text-align: center;
            padding: 40px 20px;
            background: #1a1e24;
            border-radius: 20px;
            margin-bottom: 30px;
        }}
        .header h1 {{
            font-size: 3em;
            background: linear-gradient(135deg, #00ff9d, #00b8ff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }}
        .stats {{
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 20px;
            margin-bottom: 30px;
        }}
        .stat-card {{
            background: #1a1e24;
            padding: 20px;
            border-radius: 15px;
            text-align: center;
        }}
        .stat-value {{
            font-size: 2em;
            font-weight: bold;
            color: #00ff9d;
        }}
        .apps {{
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 15px;
            margin-bottom: 30px;
        }}
        .app-card {{
            background: #1a1e24;
            padding: 15px;
            border-radius: 15px;
            text-align: center;
            border: 1px solid #00ff9d33;
        }}
        .app-link {{
            display: inline-block;
            margin-top: 10px;
            padding: 8px 20px;
            background: linear-gradient(135deg, #00ff9d, #00b8ff);
            color: #000;
            text-decoration: none;
            border-radius: 20px;
            font-weight: bold;
        }}
        .config-grid {{
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }}
        .config-card {{
            background: #1a1e24;
            padding: 15px;
            border-radius: 15px;
            border: 1px solid #00ff9d33;
            text-align: center;
        }}
        .config-qr img {{
            max-width: 150px;
            margin: 10px 0;
        }}
        .copy-btn {{
            width: 100%;
            padding: 10px;
            background: linear-gradient(135deg, #00ff9d, #00b8ff);
            border: none;
            border-radius: 10px;
            color: #000;
            font-weight: bold;
            cursor: pointer;
        }}
        .subscription-box {{
            background: #1a1e24;
            padding: 20px;
            border-radius: 15px;
            margin-top: 30px;
        }}
        .sub-link {{
            display: block;
            padding: 10px;
            background: #0a0c0f;
            border-radius: 10px;
            word-break: break-all;
            font-size: 0.9em;
        }}
        .footer {{
            text-align: center;
            margin-top: 40px;
            padding: 20px;
            color: #666;
        }}
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üßä ICEBREAKER</h1>
            <p>–ê–≤—Ç–æ–Ω–æ–º–Ω–∞—è —Å—Ç–∞–Ω—Ü–∏—è —Å–≤–æ–±–æ–¥–Ω–æ–≥–æ –∏–Ω—Ç–µ—Ä–Ω–µ—Ç–∞</p>
            <div style="margin-top: 15px; color: #00ff9d;">
                –û–±–Ω–æ–≤–ª–µ–Ω–æ: {datetime.now().strftime('%d.%m.%Y %H:%M')}
            </div>
        </div>
        
        <div class="stats">
            <div class="stat-card">
                <div class="stat-value">{stats['total']}</div>
                <div>–í—Å–µ–≥–æ –∫–æ–Ω—Ñ–∏–≥–æ–≤</div>
            </div>
            <div class="stat-card">
                <div class="stat-value">{stats['telegram']}</div>
                <div>Telegram</div>
            </div>
            <div class="stat-card">
                <div class="stat-value">{stats['vpn']}</div>
                <div>VPN</div>
            </div>
        </div>
        
        <h2>üì± –ü—Ä–∏–ª–æ–∂–µ–Ω–∏—è</h2>
        <div class="apps">
            <div class="app-card">
                <div>ü§ñ Nekobox (Android)</div>
                <a href="https://github.com/MatsuriDayo/NekoBoxForAndroid/releases" class="app-link">–°–∫–∞—á–∞—Ç—å</a>
            </div>
            <div class="app-card">
                <div>üì± v2rayNG (Android)</div>
                <a href="https://github.com/2dust/v2rayNG/releases" class="app-link">–°–∫–∞—á–∞—Ç—å</a>
            </div>
            <div class="app-card">
                <div>üçé Streisand (iOS)</div>
                <a href="https://apps.apple.com/app/streisand/id6450534064" class="app-link">–°–∫–∞—á–∞—Ç—å</a>
            </div>
            <div class="app-card">
                <div>üì° V2BOX (iOS)</div>
                <a href="https://apps.apple.com/app/v2box/id6446018936" class="app-link">–°–∫–∞—á–∞—Ç—å</a>
            </div>
        </div>
        
        <h2>üîë –†–∞–±–æ—á–∏–µ –∫–æ–Ω—Ñ–∏–≥–∏</h2>
        <div class="config-grid">
            {cards}
        </div>
        
        <div class="subscription-box">
            <h3>üì° –°—Å—ã–ª–∫–∏ –¥–ª—è –∞–≤—Ç–æ–æ–±–Ω–æ–≤–ª–µ–Ω–∏—è</h3>
            <div style="margin-top: 15px;">
                <div style="color: #00ff9d; margin-bottom: 5px;">Telegram Proxies:</div>
                <div class="sub-link">https://raw.githubusercontent.com/${{{{ github.repository }}}}/main/telegram_proxies.txt</div>
            </div>
            <div style="margin-top: 15px;">
                <div style="color: #00b8ff; margin-bottom: 5px;">VPN Configs:</div>
                <div class="sub-link">https://raw.githubusercontent.com/${{{{ github.repository }}}}/main/vpn_configs.json</div>
            </div>
        </div>
        
        <div class="footer">
            <p>üßä ICEBREAKER - –û–±–Ω–æ–≤–ª—è–µ—Ç—Å—è –∫–∞–∂–¥—ã–π —á–∞—Å</p>
        </div>
    </div>
    
    <script>
        function copyConfig(config) {{
            navigator.clipboard.writeText(config);
            alert('‚úÖ –ö–æ–Ω—Ñ–∏–≥ —Å–∫–æ–ø–∏—Ä–æ–≤–∞–Ω!');
        }}
    </script>
</body>
</html>"""
        
        with open('docs/index.html', 'w', encoding='utf-8') as f:
            f.write(html)

EOF
        
    - name: üöÄ Master Orchestrator
      run: |
        cat > master.py << 'EOF'
import asyncio
import json
from bot_cracker import BotCracker
from scanner import UniversalScanner
from checker import ConfigChecker
from dashboard import DashboardGenerator

async def main():
    print("üßä ICEBREAKER Starting...")
    
    # –°–∫–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ
    scanner = UniversalScanner()
    await scanner.initialize()
    await scanner.scan_public_sources()
    await scanner.search_by_keywords()
    
    print(f"üì¶ Found {len(scanner.configs)} raw configs")
    print(f"ü§ñ Found {len(scanner.bots)} bots")
    
    # –ê—Ç–∞–∫–∞ –Ω–∞ –±–æ—Ç–æ–≤
    cracker = BotCracker()
    all_configs = scanner.configs.copy()
    
    for bot in list(scanner.bots)[:20]:  # –ê—Ç–∞–∫—É–µ–º –ø–µ—Ä–≤—ã–µ 20 –±–æ—Ç–æ–≤
        print(f"üéØ Attacking @{bot}...")
        bot_configs = await cracker.attack_bot_10ways(bot)
        all_configs.extend(bot_configs)
        print(f"   Found {len(bot_configs)} configs")
        await asyncio.sleep(2)
    
    # –£–±–∏—Ä–∞–µ–º –¥—É–±–ª–∏–∫–∞—Ç—ã
    all_configs = list(set(all_configs))
    print(f"üìä Total unique configs: {len(all_configs)}")
    
    # –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ –∂–∏–≤–æ—Å—Ç—å
    checker = ConfigChecker()
    working = await checker.check_all(all_configs)
    print(f"‚úÖ Working configs: {len(working)}")
    
    # –†–∞–∑–¥–µ–ª—è–µ–º –ø–æ —Ç–∏–ø–∞–º
    telegram = [c for c in working if 'tg://' in c['config'] or 'mtproto' in c['config']]
    vpn = [c for c in working if not ('tg://' in c['config'] or 'mtproto' in c['config'])]
    
    # –°–æ—Ö—Ä–∞–Ω—è–µ–º —Ñ–∞–π–ª—ã
    with open('telegram_proxies.txt', 'w') as f:
        for t in telegram:
            f.write(t['config'] + '\n')
    
    with open('vpn_configs.json', 'w') as f:
        json.dump(vpn, f, indent=2)
    
    with open('all_in_one.raw', 'w') as f:
        for w in working:
            f.write(w['config'] + '\n')
    
    # –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞
    stats = {
        'total': len(working),
        'telegram': len(telegram),
        'vpn': len(vpn),
        'avg_ping': sum(w['ping'] for w in working) / len(working) if working else 0
    }
    
    # –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º –¥–∞—à–±–æ—Ä–¥
    dashboard = DashboardGenerator()
    dashboard.generate_html(working, stats)
    
    print("‚úÖ ICEBREAKER Complete!")

if __name__ == "__main__":
    asyncio.run(main())
EOF
        
    - name: üéØ Execute ICEBREAKER
      run: |
        python master.py
        
    - name: üì¶ Create Release
      if: success()
      run: |
        TAG="icebreaker-$(date +'%Y%m%d-%H%M%S')"
        gh release create "$TAG" \
          --title "üßä ICEBREAKER $(date +'%d.%m.%Y %H:%M')" \
          --notes "–ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–µ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ" \
          telegram_proxies.txt vpn_configs.json all_in_one.raw
      env:
        GH_TOKEN: ${{ github.token }}
        
    - name: üì§ Deploy to Pages
      if: success()
      run: |
        mkdir -p docs
        git config user.name "GitHub Actions"
        git config user.email "actions@github.com"
        git add docs/ telegram_proxies.txt vpn_configs.json all_in_one.raw
        git commit -m "üßä Auto-update $(date +'%Y%m%d')" || exit 0
        git push
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}jobs:
  neural-infiltration:
    runs-on: ubuntu-latest
    timeout-minutes: 45
    
    strategy:
      matrix:
        instance: [1, 2, 3]  # –ú–Ω–æ–∂–µ—Å—Ç–≤–µ–Ω–Ω—ã–µ –∏–Ω—Å—Ç–∞–Ω—Å—ã –¥–ª—è –ø–∞—Ä–∞–ª–ª–µ–ª—å–Ω–æ–π –∞—Ç–∞–∫–∏
    
    steps:
    - name: üåÄ Quantum Randomization
      run: |
        # –°–æ–∑–¥–∞–µ–º —É–Ω–∏–∫–∞–ª—å–Ω—ã–π fingerprint –¥–ª—è –∫–∞–∂–¥–æ–≥–æ –∑–∞–ø—É—Å–∫–∞
        RANDOM_SEED=$(( RANDOM * $(date +%s%N) ))
        echo "FINGERPRINT=$RANDOM_SEED" >> $GITHUB_ENV
        echo "USER_AGENT=Mozilla/5.0 (Windows NT $((RANDOM%10+10)).0; Win64; x64) AppleWebKit/$((RANDOM%500+500)).36"
        
    - name: üì¶ Checkout & Environment Setup
      uses: actions/checkout@v4
      
    - name: üêç Python Ultra Installation
      run: |
        sudo apt-get update
        sudo apt-get install -y \
          python3.11-full \
          python3-pip \
          tor \
          proxychains4 \
          xvfb \
          chromium-browser \
          chromium-chromedriver \
          jq \
          parallel \
          sqlite3 \
          redis-tools
        
    - name: üîß Install Advanced Dependencies
      run: |
        pip install --upgrade pip
        pip install --quiet \
          telethon \
          pyrogram \
          tgcrypto \
          cryptg \
          asyncio \
          aiohttp \
          aiohttp-socks \
          beautifulsoup4 \
          selenium \
          undetected-chromedriver \
          playwright \
          fake-useragent \
          cloudscraper \
          requests \
          requests-toolbelt \
          curl_cffi \
          websockets \
          websocket-client \
          pyppeteer \
          playwright-stealth \
          pyotp \
          python-telegram-bot \
          python-dotenv \
          pyyaml \
          json5 \
          orjson \
          pillow \
          qrcode \
          pyzbar \
          opencv-python \
          numpy \
          pandas \
          scikit-learn \
          tensorflow-cpu \
          transformers \
          torch \
          sentencepiece \
          protobuf \
          colorama \
          rich \
          tqdm \
          loguru \
          prometheus-client \
          grafana-api \
          redis \
          pymongo \
          psycopg2-binary \
          sqlalchemy \
          alembic \
          celery \
          flower
    
    - name: üé≠ Telegram Multi-Session Manager
      run: |
        cat > telegram_session_manager.py << 'EOF'
        import asyncio
        from telethon import TelegramClient, events
        from telethon.tl.functions.messages import ImportChatInviteRequest
        from telethon.tl.functions.channels import JoinChannelRequest
        from telethon.tl.types import InputPhoneContact
        from telethon.errors import FloodWaitError, SessionPasswordNeededError
        import random
        import json
        import time
        from datetime import datetime
        import hashlib
        import os
        
        class TelegramSessionManager:
            def __init__(self):
                self.sessions = []
                self.proxies = self.load_proxies()
                # –í–∞—à–∏ —Ä–µ–∞–ª—å–Ω—ã–µ API credentials
                self.api_id = 38922115  # –í–∞—à API ID
                self.api_hash = 'b34ae241317eff8743f538a8272c5f6d'  # –í–∞—à API Hash
                self.bot_tokens = []
                self.user_phones = []
                
                # –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è –¥–∞—Ç–∞-—Ü–µ–Ω—Ç—Ä–æ–≤ Telegram
                self.dc_config = {
                    1: {
                        'ip': '149.154.175.50',
                        'port': 443,
                        'public_key': '''-----BEGIN RSA PUBLIC KEY-----
MIIBCgKCAQEAyMEdY1aR+sCR3ZSJrtztKTKqigvO/vBfqACJLZtS7QMgCGXJ6XIR
yy7mx66W0/sOFa7/1mAZtEoIokDP3ShoqF4fVNb6XeqgQfaUHd8wJpDWHcR2OFwv
plUUI1PLTktZ9u2WWE23b+ixNwJjJGwBDJPQEQFBE+vfmH0JP503wr5INS1poWg/
j25sIWeYPHYeOrFp/eXaqhISP6G+q2IeTaWTXpwZj4LzXq5YOpk4bYEQ6mvRq7D1
aHWfYmlEGepfaYR8Q0YqvvhYtMte3ITnuSJs171+GDqpdKcSwHnd6FudwGO4pcCO
j4WcDuXc2CTHgH8gFTNhp/Y8/SpDOhvn9QIDAQAB
-----END RSA PUBLIC KEY-----'''
                    },
                    2: {
                        'ip': '149.154.167.50',
                        'port': 443,
                        'public_key': '''-----BEGIN RSA PUBLIC KEY-----
MIIBCgKCAQEA6LszBcC1LGzyr992NzE0ieY+BSaOW622Aa9Bd4ZHLl+TuFQ4lo4g
5nKaMBwK/BIb9xUfg0Q29/2mgIR6Zr9krM7HjuIcCzFvDtr+L0GQjae9H0pRB2OO
62cECs5HKhT5DZ98K33vmWiLowc621dQuwKWSQKjWf50XYFw42h21P2KXUGyp2y/
+aEyZ+uVgLLQbRA1dEjSDZ2iGRy12Mk5gpYc397aYp438fsJoHIgJ2lgMv5h7WY9
t6N/byY9Nw9p21Og3AoXSL2q/2IJ1WRUhebgAdGVMlV1fkuOQoEzR7EdpqtQD9Cs
5+bfo3Nhmcyvk5ftB0WkJ9z6bNZ7yxrP8wIDAQAB
-----END RSA PUBLIC KEY-----'''
                    }
                }
                
            def load_proxies(self):
                # –ó–∞–≥—Ä—É–∑–∫–∞ –ø—Ä–æ–∫—Å–∏ –∏–∑ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö –æ–∫—Ä—É–∂–µ–Ω–∏—è
                proxy_list = os.getenv('PROXY_LIST', '').split(',')
                return [{'proxy_type': 'socks5', 'addr': p.split(':')[0], 
                        'port': int(p.split(':')[1])} for p in proxy_list if p]
            
            async def create_session(self, session_name, proxy=None, dc_id=2):  # DC 2 –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é
                # –ò—Å–ø–æ–ª—å–∑—É–µ–º –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—é DC 2 (149.154.167.50:443)
                dc_config = self.dc_config.get(dc_id, self.dc_config[2])
                
                client = TelegramClient(
                    f'sessions/{session_name}',
                    self.api_id,
                    self.api_hash,
                    proxy=proxy,
                    device_model=f"Desktop {random.randint(1000,9999)}",
                    system_version=f"Windows {random.randint(8,11)}",
                    app_version=f"{random.randint(1,9)}.{random.randint(0,9)}.{random.randint(0,9)}",
                    dc_id=dc_id,
                    port=dc_config['port']
                )
                await client.connect()
                return client
            
            async def brute_force_bot(self, bot_username, attack_vectors):
                """10 —Ä–∞–∑–Ω—ã—Ö —Å–ø–æ—Å–æ–±–æ–≤ –≤–∑–ª–æ–º–∞ –±–æ—Ç–∞"""
                results = []
                
                # –°–ø–æ—Å–æ–± 1: –ü—Ä—è–º–æ–µ –≤–∑–∞–∏–º–æ–¥–µ–π—Å—Ç–≤–∏–µ
                try:
                    client = await self.create_session(f"bot_session_{random.randint(1000,9999)}")
                    entity = await client.get_entity(bot_username)
                    
                    # –°–ø–æ—Å–æ–± 2: –û—Ç–ø—Ä–∞–≤–∫–∞ –∫–æ–º–∞–Ω–¥ —á–µ—Ä–µ–∑ –º–µ–Ω—é
                    async with client.conversation(entity) as conv:
                        msg = await conv.send_message('/start')
                        response = await conv.get_response()
                        
                        # –ü–æ–∏—Å–∫ –∫–Ω–æ–ø–æ–∫ –º–µ–Ω—é
                        if response.buttons:
                            for row in response.buttons:
                                for button in row:
                                    if '—Ç–µ—Å—Ç' in button.text.lower() or 'test' in button.text.lower():
                                        await button.click()
                                        test_response = await conv.get_edit()
                                        results.extend(self.parse_configs(test_response.text))
                    
                    # –°–ø–æ—Å–æ–± 3: –û—Ç–ø—Ä–∞–≤–∫–∞ —Ä–∞–∑–ª–∏—á–Ω—ã—Ö payloads
                    payloads = [
                        '/get_config', '/proxy', '/vpn', '/key',
                        '/generate', '/new', '/create', '/free',
                        '/trial', '/test', '/demo', '/start trial',
                        'get free config', 'free proxy', 'vless',
                        '/code', '/token', '/auth', '/login'
                    ]
                    
                    for payload in payloads:
                        try:
                            msg = await client.send_message(entity, payload)
                            reply = await client.get_messages(entity, limit=1)
                            results.extend(self.parse_configs(reply[0].text))
                        except:
                            continue
                    
                    # –°–ø–æ—Å–æ–± 4: –≠–º—É–ª—è—Ü–∏—è –≤–µ–±-–∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–∞
                    bot_info = await client.get_entity(bot_username)
                    if bot_info.username:
                        web_results = await self.emulate_web_interface(bot_info.username)
                        results.extend(web_results)
                    
                except Exception as e:
                    print(f"Error in method 1: {e}")
                
                # –°–ø–æ—Å–æ–± 5: –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ —Ä–∞–∑–Ω—ã—Ö –∞–∫–∫–∞—É–Ω—Ç–æ–≤
                for i in range(5):
                    try:
                        alt_client = await self.create_session(f"alt_session_{i}")
                        alt_entity = await alt_client.get_entity(bot_username)
                        
                        # –†–∞–∑–Ω—ã–µ –≤—Ä–µ–º–µ–Ω–Ω—ã–µ –ø—Ä–æ–º–µ–∂—É—Ç–∫–∏
                        time.sleep(random.uniform(2, 10))
                        
                        msg = await alt_client.send_message(alt_entity, '/start')
                        await asyncio.sleep(random.uniform(1, 3))
                        
                        # –ö–ª–∏–∫ –ø–æ —Ä–∞–∑–Ω—ã–º –∫–Ω–æ–ø–∫–∞–º –≤ —Ä–∞–∑–Ω–æ–º –ø–æ—Ä—è–¥–∫–µ
                        messages = await alt_client.get_messages(alt_entity, limit=5)
                        for message in messages:
                            if message.buttons:
                                for row in message.buttons:
                                    for button in random.sample(row, min(len(row), 3)):
                                        try:
                                            await button.click()
                                            await asyncio.sleep(random.uniform(0.5, 2))
                                            updates = await alt_client.get_messages(alt_entity, limit=1)
                                            results.extend(self.parse_configs(updates[0].text))
                                        except:
                                            continue
                    except:
                        continue
                
                # –°–ø–æ—Å–æ–± 6: –≠–º—É–ª—è—Ü–∏—è –º–æ–±–∏–ª—å–Ω–æ–≥–æ —É—Å—Ç—Ä–æ–π—Å—Ç–≤–∞
                mobile_client = await self.create_session(
                    f"mobile_session_{random.randint(1000,9999)}",
                    device="iPhone14,3",
                    system_version="iOS 16.5"
                )
                # ... –º–æ–±–∏–ª—å–Ω–∞—è —ç–º—É–ª—è—Ü–∏—è
                
                # –°–ø–æ—Å–æ–± 7: WebView —ç–º—É–ª—è—Ü–∏—è —á–µ—Ä–µ–∑ Selenium
                web_results = await self.emulate_webview(bot_username)
                results.extend(web_results)
                
                # –°–ø–æ—Å–æ–± 8: API brute force
                api_results = await self.brute_force_api(bot_username)
                results.extend(api_results)
                
                # –°–ø–æ—Å–æ–± 9: Social engineering —ç–º—É–ª—è—Ü–∏—è
                social_results = await self.social_engineering_attack(bot_username)
                results.extend(social_results)
                
                # –°–ø–æ—Å–æ–± 10: Deep learning bypass
                dl_results = await self.deep_learning_bypass(bot_username)
                results.extend(dl_results)
                
                return list(set(results))  # –£–Ω–∏–∫–∞–ª—å–Ω—ã–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã
                
            def parse_configs(self, text):
                patterns = [
                    r'(vless://[a-zA-Z0-9\-_.@:/?#[\]@!$&\'()*+,;=%]*)',
                    r'(vmess://[a-zA-Z0-9\-_.+/=]*)',
                    r'(ss://[a-zA-Z0-9\-_.@:/?#[\]@!$&\'()*+,;=%]*)',
                    r'(trojan://[a-zA-Z0-9\-_.@:/?#[\]@!$&\'()*+,;=%]*)',
                    r'(tg://proxy\?[a-zA-Z0-9\-_.@:/?#[\]@!$&\'()*+,;=%]*)',
                    r'(mtproto://[a-zA-Z0-9\-_.@:/?#[\]@!$&\'()*+,;=%]*)',
                    r'(https://t\.me/proxy\?[a-zA-Z0-9\-_.@:/?#[\]@!$&\'()*+,;=%]*)',
                    r'(socks5://[a-zA-Z0-9\-_.@:/?#[\]@!$&\'()*+,;=%]*)'
                ]
                
                found = []
                for pattern in patterns:
                    found.extend(re.findall(pattern, text))
                return found
                
            async def scan_all_channels(self, keywords):
                """–°–∫–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ –≤—Å–µ–≥–æ Telegram –ø–æ –∫–ª—é—á–µ–≤—ã–º —Å–ª–æ–≤–∞–º"""
                client = await self.create_session("master_scanner")
                
                all_configs = []
                search_queries = [
                    'free proxy', 'v2ray config', 'shadowsocks', 
                    'telegram proxy', 'mtproto', 'vless', 'vmess',
                    'free vpn', 'config v2ray', 'proxy list',
                    'private proxy', 'premium proxy leak',
                    'test proxy', 'trial vpn', 'free internet'
                ]
                
                for query in search_queries:
                    try:
                        # –ü–æ–∏—Å–∫ —Å–æ–æ–±—â–µ–Ω–∏–π
                        messages = await client.get_messages('@', search=query, limit=100)
                        
                        for msg in messages:
                            if msg.text:
                                configs = self.parse_configs(msg.text)
                                all_configs.extend(configs)
                            
                            # –ü–æ–∏—Å–∫ –≤ –º–µ–¥–∏–∞
                            if msg.document:
                                # –°–∫–∞—á–∏–≤–∞–µ–º –∏ –∞–Ω–∞–ª–∏–∑–∏—Ä—É–µ–º –¥–æ–∫—É–º–µ–Ω—Ç—ã
                                path = await msg.download_media()
                                with open(path, 'r', errors='ignore') as f:
                                    content = f.read()
                                    all_configs.extend(self.parse_configs(content))
                    
                    except FloodWaitError as e:
                        wait_time = e.seconds
                        print(f"Flood wait: {wait_time}s")
                        await asyncio.sleep(wait_time)
                    
                return all_configs
        
        EOF
    
    - name: ü§ñ Bot Cracker Engine - 10 Layer Attack
      run: |
        cat > bot_cracker_advanced.py << 'EOF'
        import asyncio
        import random
        import time
        import json
        import hashlib
        from selenium import webdriver
        from selenium.webdriver.common.by import By
        from selenium.webdriver.support.ui import WebDriverWait
        from selenium.webdriver.support import expected_conditions as EC
        from selenium.webdriver.chrome.options import Options
        from undetected_chromedriver import Chrome, ChromeOptions
        from fake_useragent import UserAgent
        import requests
        from curl_cffi import requests as curl_requests
        import websocket
        import base64
        import urllib.parse
        
        class BotCrackerAdvanced:
            def __init__(self):
                self.ua = UserAgent()
                self.successful_approaches = []
                self.attack_history = {}
                self.api_id = 38922115
                self.api_hash = 'b34ae241317eff8743f538a8272c5f6d'
                
            def layer1_direct_commands(self, bot_url):
                """–°–ª–æ–π 1: –ü—Ä—è–º—ã–µ –∫–æ–º–∞–Ω–¥—ã —á–µ—Ä–µ–∑ API"""
                commands = [
                    '/start', '/start trial', '/free', '/get_free',
                    '/proxy', '/get_proxy', '/config', '/get_config',
                    '/v2ray', '/get_v2ray', '/vless', '/vmess',
                    '/ss', '/shadowsocks', '/trojan', '/mtproto',
                    '/generate', '/new', '/create', '/make',
                    '/code', '/key', '/token', '/auth',
                    '/login', '/register', '/signup', '/trial',
                    '/test', '/demo', '/example', '/sample',
                    '/get', '/give', '/send', '/take',
                    '/free_key', '/free_config', '/free_proxy',
                    '/trial_key', '/trial_config', '/trial_proxy',
                    '/test_key', '/test_config', '/test_proxy'
                ]
                
                results = []
                for cmd in commands:
                    try:
                        # –≠–º—É–ª—è—Ü–∏—è –æ—Ç–ø—Ä–∞–≤–∫–∏ –∫–æ–º–∞–Ω–¥—ã —á–µ—Ä–µ–∑ —Ä–∞–∑–Ω—ã–µ –º–µ—Ç–æ–¥—ã
                        response = self.send_telegram_command(bot_url, cmd)
                        if response and self.contains_config(response):
                            results.extend(self.extract_configs(response))
                            
                        # –°–ª—É—á–∞–π–Ω—ã–µ –∑–∞–¥–µ—Ä–∂–∫–∏ –º–µ–∂–¥—É –∫–æ–º–∞–Ω–¥–∞–º–∏
                        time.sleep(random.uniform(0.1, 0.5))
                    except:
                        continue
                return results
                
            def layer2_web_emulation(self, bot_url):
                """–°–ª–æ–π 2: –≠–º—É–ª—è—Ü–∏—è –≤–µ–±-–∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–∞"""
                chrome_options = Options()
                chrome_options.add_argument('--headless')
                chrome_options.add_argument('--no-sandbox')
                chrome_options.add_argument('--disable-dev-shm-usage')
                chrome_options.add_argument(f'user-agent={self.ua.random}')
                
                driver = Chrome(options=chrome_options)
                
                try:
                    # –ü–µ—Ä–µ—Ö–æ–¥–∏–º –Ω–∞ –≤–µ–±-–≤–µ—Ä—Å–∏—é –±–æ—Ç–∞
                    web_url = f"https://web.telegram.org/k/#@{bot_url}"
                    driver.get(web_url)
                    
                    # –ñ–¥–µ–º –∑–∞–≥—Ä—É–∑–∫–∏
                    WebDriverWait(driver, 10).until(
                        EC.presence_of_element_located((By.CLASS_NAME, "input-message-container"))
                    )
                    
                    # –≠–º—É–ª–∏—Ä—É–µ–º –¥–µ–π—Å—Ç–≤–∏—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
                    actions = [
                        ('–∫–ª–∏–∫ –ø–æ –º–µ–Ω—é', "//div[contains(@class, 'btn-menu')]"),
                        ('–æ—Ç–∫—Ä—ã—Ç–∏–µ –∫–ª–∞–≤–∏–∞—Ç—É—Ä—ã', "//div[contains(@class, 'keyboard-button')]"),
                        ('–Ω–∞–∂–∞—Ç–∏–µ –Ω–∞ –∫–Ω–æ–ø–∫—É', "//button[contains(text(), '–ü–æ–ª—É—á–∏—Ç—å')]"),
                        ('–≤–≤–æ–¥ –∫–æ–º–∞–Ω–¥', "//div[@contenteditable='true']")
                    ]
                    
                    results = []
                    for action_name, selector in actions:
                        try:
                            element = driver.find_element(By.XPATH, selector)
                            driver.execute_script("arguments[0].click();", element)
                            time.sleep(random.uniform(1, 3))
                            
                            # –°–æ–±–∏—Ä–∞–µ–º –≤—Å–µ —Å–æ–æ–±—â–µ–Ω–∏—è
                            messages = driver.find_elements(By.CLASS_NAME, "message")
                            for msg in messages:
                                text = msg.text
                                if self.contains_config(text):
                                    results.extend(self.extract_configs(text))
                        except:
                            continue
                            
                finally:
                    driver.quit()
                    
                return results
                
            def layer3_mobile_emulation(self, bot_url):
                """–°–ª–æ–π 3: –≠–º—É–ª—è—Ü–∏—è –º–æ–±–∏–ª—å–Ω–æ–≥–æ —É—Å—Ç—Ä–æ–π—Å—Ç–≤–∞"""
                # –ò—Å–ø–æ–ª—å–∑—É–µ–º –º–æ–±–∏–ª—å–Ω—ã–µ User-Agent
                mobile_agents = [
                    'Mozilla/5.0 (iPhone; CPU iPhone OS 14_0 like Mac OS X)',
                    'Mozilla/5.0 (Android 11; Mobile; rv:68.0) Gecko/68.0 Firefox/88.0',
                    'Mozilla/5.0 (Linux; Android 10; SM-G975F) AppleWebKit/537.36'
                ]
                
                for agent in mobile_agents:
                    try:
                        # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –∑–∞–ø—Ä–æ—Å—ã —Å –º–æ–±–∏–ª—å–Ω—ã–º–∏ –∑–∞–≥–æ–ª–æ–≤–∫–∞–º–∏
                        headers = {
                            'User-Agent': agent,
                            'Accept': 'application/json',
                            'Accept-Language': 'en-US,en;q=0.9',
                            'X-Requested-With': 'XMLHttpRequest'
                        }
                        
                        # –≠–º—É–ª–∏—Ä—É–µ–º –º–æ–±–∏–ª—å–Ω–æ–µ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ
                        session = requests.Session()
                        session.headers.update(headers)
                        
                        # –ü—Ä–æ–±—É–µ–º —Ä–∞–∑–Ω—ã–µ —ç–Ω–¥–ø–æ–∏–Ω—Ç—ã
                        endpoints = [
                            f'/api/bot/{bot_url}/getConfig',
                            f'/webapp/data?bot={bot_url}',
                            f'/api/v1/bot/{bot_url}/free',
                            f'/get?bot={bot_url}'
                        ]
                        
                        for endpoint in endpoints:
                            try:
                                response = session.get(f'https://t.me{endpoint}')
                                if response.status_code == 200:
                                    data = response.json()
                                    configs = self.extract_configs_from_json(data)
                                    if configs:
                                        return configs
                            except:
                                continue
                                
                    except Exception as e:
                        print(f"Mobile emulation error: {e}")
                        
                return []
                
            def layer4_websocket_attack(self, bot_url):
                """–°–ª–æ–π 4: WebSocket –∞—Ç–∞–∫–∞"""
                try:
                    ws_url = f"wss://{bot_url}.t.me/ws"
                    ws = websocket.WebSocket()
                    ws.connect(ws_url)
                    
                    # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —Ä–∞–∑–Ω—ã–µ —Ç–∏–ø—ã —Å–æ–æ–±—â–µ–Ω–∏–π
                    message_types = [
                        {'type': 'start', 'data': {}},
                        {'type': 'get_config', 'data': {'format': 'v2ray'}},
                        {'type': 'request', 'data': {'method': 'getFree'}},
                        {'type': 'subscribe', 'data': {'channel': 'configs'}}
                    ]
                    
                    results = []
                    for msg in message_types:
                        ws.send(json.dumps(msg))
                        response = ws.recv()
                        
                        # –ê–Ω–∞–ª–∏–∑–∏—Ä—É–µ–º –æ—Ç–≤–µ—Ç
                        if response:
                            parsed = json.loads(response)
                            configs = self.extract_configs_from_json(parsed)
                            results.extend(configs)
                            
                    ws.close()
                    return results
                    
                except:
                    return []
                    
            def layer5_mtproto_direct(self, bot_url):
                """–°–ª–æ–π 5: –ü—Ä—è–º–æ–µ MTProto –≤–∑–∞–∏–º–æ–¥–µ–π—Å—Ç–≤–∏–µ"""
                # –≠–º—É–ª—è—Ü–∏—è MTProto –∑–∞–ø—Ä–æ—Å–æ–≤
                mtproto_methods = [
                    'messages.getBotInfo',
                    'messages.getBotConfig',
                    'bots.getBotInfo',
                    'bots.getBotCommands'
                ]
                
                results = []
                for method in mtproto_methods:
                    try:
                        # –°–æ–∑–¥–∞–µ–º MTProto –∑–∞–ø—Ä–æ—Å
                        request = {
                            '_': method,
                            'bot': f'@{bot_url}',
                            'lang': 'en'
                        }
                        
                        # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —á–µ—Ä–µ–∑ —Ä–∞–∑–Ω—ã–µ —Ç—Ä–∞–Ω—Å–ø–æ—Ä—Ç—ã
                        response = self.send_mtproto_request(request)
                        if response and 'config' in response:
                            results.append(response['config'])
                            
                    except:
                        continue
                        
                return results
                
            def layer6_recursive_menu_crawler(self, bot_url):
                """–°–ª–æ–π 6: –†–µ–∫—É—Ä—Å–∏–≤–Ω—ã–π –æ–±—Ö–æ–¥ –º–µ–Ω—é"""
                visited_menus = set()
                queue = ['/start']
                results = []
                
                while queue and len(visited_menus) < 50:
                    current = queue.pop(0)
                    if current in visited_menus:
                        continue
                        
                    try:
                        # –ü–æ–ª—É—á–∞–µ–º –º–µ–Ω—é
                        menu = self.get_bot_menu(bot_url, current)
                        visited_menus.add(current)
                        
                        if menu and 'buttons' in menu:
                            # –ê–Ω–∞–ª–∏–∑–∏—Ä—É–µ–º –∫–∞–∂–¥—É—é –∫–Ω–æ–ø–∫—É
                            for button in menu['buttons']:
                                button_text = button.get('text', '')
                                button_data = button.get('data', '')
                                
                                # –ü—Ä–æ–≤–µ—Ä—è–µ–º —Ç–µ–∫—Å—Ç –∫–Ω–æ–ø–∫–∏
                                if any(word in button_text.lower() for word in 
                                       ['–ø–æ–ª—É—á–∏—Ç—å', 'get', 'free', 'config', 'proxy', 'key']):
                                    # –ö–ª–∏–∫–∞–µ–º –ø–æ –∫–Ω–æ–ø–∫–µ
                                    response = self.click_button(bot_url, button_data)
                                    if response:
                                        configs = self.extract_configs(response)
                                        results.extend(configs)
                                        
                                # –î–æ–±–∞–≤–ª—è–µ–º –≤ –æ—á–µ—Ä–µ–¥—å –¥–ª—è —Ä–µ–∫—É—Ä—Å–∏–≤–Ω–æ–≥–æ –æ–±—Ö–æ–¥–∞
                                if button_data and button_data not in visited_menus:
                                    queue.append(button_data)
                                    
                    except Exception as e:
                        print(f"Menu error: {e}")
                        
                return results
                
            def layer7_injection_attack(self, bot_url):
                """–°–ª–æ–π 7: –ò–Ω—ä–µ–∫—Ü–∏–∏ —Ä–∞–∑–ª–∏—á–Ω—ã—Ö —Ñ–æ—Ä–º–∞—Ç–æ–≤"""
                injections = [
                    '/get_config?format=vless',
                    '/get_config?format=vmess',
                    '/get_config?format=ss',
                    '/get_config?format=trojan',
                    '/api/v1/config?type=all',
                    '/api/v1/config?type=mtproto',
                    '/api/v1/config?type=shadowsocks',
                    '/api/v1/config?output=json',
                    '/api/v1/config?output=text',
                    '/api/v1/config?output=base64',
                    '/get?protocol=vless',
                    '/get?protocol=vmess',
                    '/get?protocol=ss',
                    '/get?protocol=trojan',
                    '/generate?count=5',
                    '/generate?count=10',
                    '/generate?country=all',
                    '/generate?type=premium'
                ]
                
                results = []
                for injection in injections:
                    try:
                        response = self.send_telegram_command(bot_url, injection)
                        if response and len(response) > 50:  # –ú–∏–Ω–∏–º–∞–ª—å–Ω–∞—è –¥–ª–∏–Ω–∞ –æ—Ç–≤–µ—Ç–∞
                            configs = self.extract_configs(response)
                            results.extend(configs)
                            
                        # –°–ª—É—á–∞–π–Ω—ã–µ –∑–∞–¥–µ—Ä–∂–∫–∏
                        time.sleep(random.uniform(0.5, 2))
                        
                    except:
                        continue
                        
                return results
                
            def layer8_timing_attack(self, bot_url):
                """–°–ª–æ–π 8: Timing-based –∞—Ç–∞–∫–∞"""
                # –ê–Ω–∞–ª–∏–∑–∏—Ä—É–µ–º –≤—Ä–µ–º—è –æ—Ç–≤–µ—Ç–∞ –¥–ª—è —Ä–∞–∑–Ω—ã—Ö –∫–æ–º–∞–Ω–¥
                timing_data = {}
                
                test_commands = ['/start', '/help', '/info', '/menu']
                for cmd in test_commands:
                    start = time.time()
                    try:
                        response = self.send_telegram_command(bot_url, cmd)
                        elapsed = time.time() - start
                        timing_data[cmd] = elapsed
                    except:
                        continue
                        
                # –ù–∞—Ö–æ–¥–∏–º –∞–Ω–æ–º–∞–ª–∏–∏ –≤–æ –≤—Ä–µ–º–µ–Ω–∏ –æ—Ç–≤–µ—Ç–∞
                avg_time = sum(timing_data.values()) / len(timing_data) if timing_data else 0
                
                suspicious_commands = []
                for cmd, elapsed in timing_data.items():
                    if elapsed > avg_time * 1.5:  # –ö–æ–º–∞–Ω–¥—ã —Å –∞–Ω–æ–º–∞–ª—å–Ω–æ –¥–æ–ª–≥–∏–º –æ—Ç–≤–µ—Ç–æ–º
                        suspicious_commands.append(cmd)
                        
                # –ü—Ä–æ–≤–µ—Ä—è–µ–º –ø–æ–¥–æ–∑—Ä–∏—Ç–µ–ª—å–Ω—ã–µ –∫–æ–º–∞–Ω–¥—ã
                results = []
                for cmd in suspicious_commands:
                    for attempt in range(3):  # –ü–æ–≤—Ç–æ—Ä—è–µ–º –Ω–µ—Å–∫–æ–ª—å–∫–æ —Ä–∞–∑
                        response = self.send_telegram_command(bot_url, cmd)
                        if response:
                            configs = self.extract_configs(response)
                            results.extend(configs)
                            
                return results
                
            def layer9_machine_learning_bypass(self, bot_url):
                """–°–ª–æ–π 9: ML-based –æ–±—Ö–æ–¥ –∑–∞—â–∏—Ç—ã"""
                # –ò—Å–ø–æ–ª—å–∑—É–µ–º –ø—Ä–µ–¥–æ–±—É—á–µ–Ω–Ω—É—é –º–æ–¥–µ–ª—å –¥–ª—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –∫–æ–º–∞–Ω–¥
                import numpy as np
                from sklearn.feature_extraction.text import CountVectorizer
                from sklearn.naive_bayes import MultinomialNB
                
                # –û–±—É—á–∞–µ–º –º–æ–¥–µ–ª—å –Ω–∞ –∏—Å—Ç–æ—Ä–∏–∏ —É—Å–ø–µ—à–Ω—ã—Ö –∫–æ–º–∞–Ω–¥
                if self.successful_approaches:
                    vectorizer = CountVectorizer()
                    X = vectorizer.fit_transform(self.successful_approaches)
                    y = [1] * len(self.successful_approaches)
                    
                    model = MultinomialNB()
                    model.fit(X, y)
                    
                    # –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º –Ω–æ–≤—ã–µ –∫–æ–º–∞–Ω–¥—ã
                    base_commands = ['get', 'free', 'config', 'proxy', 'key']
                    prefixes = ['/', '!', '.', '-', '']
                    suffixes = ['_now', '_me', '_please', '_pls', '']
                    
                    generated = []
                    for base in base_commands:
                        for prefix in prefixes:
                            for suffix in suffixes:
                                cmd = f"{prefix}{base}{suffix}"
                                generated.append(cmd)
                                
                    # –û—Ü–µ–Ω–∏–≤–∞–µ–º –≤–µ—Ä–æ—è—Ç–Ω–æ—Å—Ç—å —É—Å–ø–µ—Ö–∞
                    X_test = vectorizer.transform(generated)
                    probabilities = model.predict_proba(X_test)
                    
                    # –¢–µ—Å—Ç–∏—Ä—É–µ–º –∫–æ–º–∞–Ω–¥—ã —Å –≤—ã—Å–æ–∫–æ–π –≤–µ—Ä–æ—è—Ç–Ω–æ—Å—Ç—å—é
                    results = []
                    for cmd, prob in zip(generated, probabilities):
                        if prob[1] > 0.7:  # –í—ã—Å–æ–∫–∞—è –≤–µ—Ä–æ—è—Ç–Ω–æ—Å—Ç—å —É—Å–ø–µ—Ö–∞
                            response = self.send_telegram_command(bot_url, cmd)
                            if response:
                                configs = self.extract_configs(response)
                                results.extend(configs)
                                
                    return results
                    
                return []
                
            def layer10_deep_learning_generation(self, bot_url):
                """–°–ª–æ–π 10: –ì–ª—É–±–æ–∫–æ–µ –æ–±—É—á–µ–Ω–∏–µ –¥–ª—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –∑–∞–ø—Ä–æ—Å–æ–≤"""
                try:
                    from transformers import pipeline
                    
                    # –ó–∞–≥—Ä—É–∂–∞–µ–º –º–æ–¥–µ–ª—å –¥–ª—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ —Ç–µ–∫—Å—Ç–∞
                    generator = pipeline('text-generation', model='gpt2')
                    
                    # –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º –µ—Å—Ç–µ—Å—Ç–≤–µ–Ω–Ω—ã–µ –∑–∞–ø—Ä–æ—Å—ã
                    prompts = [
                        "How can I get a free proxy server?",
                        "I need a VPN configuration for Telegram",
                        "Please give me a test config for v2ray",
                        "Can I have a trial proxy please?",
                        "Free internet access configuration"
                    ]
                    
                    results = []
                    for prompt in prompts:
                        generated = generator(prompt, max_length=50, num_return_sequences=3)
                        
                        for item in generated:
                            text = item['generated_text']
                            # –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º –≤ –∫–æ–º–∞–Ω–¥—É –¥–ª—è –±–æ—Ç–∞
                            command = self.natural_to_command(text)
                            
                            response = self.send_telegram_command(bot_url, command)
                            if response:
                                configs = self.extract_configs(response)
                                results.extend(configs)
                                
                    return results
                    
                except Exception as e:
                    print(f"Deep learning error: {e}")
                    return []
                    
            def send_telegram_command(self, bot_url, command):
                # –°–∏–º—É–ª—è—Ü–∏—è –æ—Ç–ø—Ä–∞–≤–∫–∏ –∫–æ–º–∞–Ω–¥—ã –≤ Telegram
                # –†–µ–∞–ª—å–Ω–∞—è —Ä–µ–∞–ª–∏–∑–∞—Ü–∏—è —á–µ—Ä–µ–∑ Telethon/Pyrogram
                pass
                
            def contains_config(self, text):
                patterns = ['vless://', 'vmess://', 'ss://', 'trojan://', 'tg://']
                return any(pattern in text for pattern in patterns)
                
            def extract_configs(self, text):
                import re
                patterns = [
                    r'(vless://[^\s]+)',
                    r'(vmess://[^\s]+)',
                    r'(ss://[^\s]+)',
                    r'(trojan://[^\s]+)',
                    r'(tg://proxy[^\s]+)'
                ]
                
                found = []
                for pattern in patterns:
                    found.extend(re.findall(pattern, text))
                return found
                
            def extract_configs_from_json(self, data):
                # –†–µ–∫—É—Ä—Å–∏–≤–Ω—ã–π –ø–æ–∏—Å–∫ –∫–æ–Ω—Ñ–∏–≥–æ–≤ –≤ JSON
                configs = []
                if isinstance(data, dict):
                    for key, value in data.items():
                        if isinstance(value, str) and self.contains_config(value):
                            configs.extend(self.extract_configs(value))
                        elif isinstance(value, (dict, list)):
                            configs.extend(self.extract_configs_from_json(value))
                elif isinstance(data, list):
                    for item in data:
                        configs.extend(self.extract_configs_from_json(item))
                return configs
                
            def get_bot_menu(self, bot_url, command):
                # –ü–æ–ª—É—á–µ–Ω–∏–µ –º–µ–Ω—é –±–æ—Ç–∞
                pass
                
            def click_button(self, bot_url, button_data):
                # –≠–º—É–ª—è—Ü–∏—è –∫–ª–∏–∫–∞ –ø–æ –∫–Ω–æ–ø–∫–µ
                pass
                
            def send_mtproto_request(self, request):
                # –û—Ç–ø—Ä–∞–≤–∫–∞ MTProto –∑–∞–ø—Ä–æ—Å–∞
                pass
                
            def natural_to_command(self, text):
                # –ö–æ–Ω–≤–µ—Ä—Ç–∞—Ü–∏—è –µ—Å—Ç–µ—Å—Ç–≤–µ–Ω–Ω–æ–≥–æ —è–∑—ã–∫–∞ –≤ –∫–æ–º–∞–Ω–¥—É
                words = text.lower().split()
                if 'free' in words or 'trial' in words:
                    return '/free'
                elif 'config' in words or 'configuration' in words:
                    return '/config'
                elif 'proxy' in words:
                    return '/proxy'
                elif 'v2ray' in words:
                    return '/v2ray'
                else:
                    return '/start'
        
        EOF
        
    - name: üï∑Ô∏è Universal Telegram Scanner
      run: |
        cat > universal_scanner.py << 'EOF'
        import asyncio
        from telethon import TelegramClient, events
        from telethon.tl.functions.messages import SearchRequest
        from telethon.tl.types import InputMessagesFilterEmpty, InputPeerEmpty
        import random
        from datetime import datetime, timedelta
        
        class UniversalScanner:
            def __init__(self):
                self.api_id = 38922115
                self.api_hash = 'b34ae241317eff8743f538a8272c5f6d'
                self.client = None
                self.discovered_bots = set()
                self.discovered_channels = set()
                self.configs = []
                
            async def initialize(self):
                self.client = TelegramClient('scanner_session', self.api_id, self.api_hash)
                await self.client.start()
                
            async def scan_public_resources(self):
                # –°–∫–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ –ø—É–±–ª–∏—á–Ω—ã—Ö —Ä–µ—Å—É—Ä—Å–æ–≤
                public_sources = [
                    '@proxy_list', '@v2ray_configs', '@free_proxy',
                    '@vpn_configs', '@telegram_proxy', '@mtproto_proxies',
                    '@shadowsocks_list', '@vless_proxies', '@vmess_proxies',
                    '@trojan_configs', '@socks5_proxies'
                ]
                
                for source in public_sources:
                    try:
                        entity = await self.client.get_entity(source)
                        messages = await self.client.get_messages(entity, limit=100)
                        
                        for msg in messages:
                            if msg.text:
                                configs = self.extract_configs(msg.text)
                                self.configs.extend(configs)
                                
                            # –ò—â–µ–º –±–æ—Ç–æ–≤ –≤ —Å–æ–æ–±—â–µ–Ω–∏—è—Ö
                            bots = self.find_bots(msg.text)
                            self.discovered_bots.update(bots)
                            
                    except Exception as e:
                        print(f"Error scanning {source}: {e}")
                        
            async def search_by_keywords(self):
                keywords = [
                    'free proxy', 'v2ray config', 'shadowsocks', 'mtproto',
                    'telegram proxy', 'vless', 'vmess', 'trojan', 'socks5',
                    'private proxy', 'premium config', 'test vpn'
                ]
                
                for keyword in keywords:
                    try:
                        result = await self.client(SearchRequest(
                            peer=InputPeerEmpty(),
                            q=keyword,
                            filter=InputMessagesFilterEmpty(),
                            min_date=datetime.now() - timedelta(days=7),
                            max_date=datetime.now(),
                            offset_id=0,
                            add_offset=0,
                            limit=100,
                            max_id=0,
                            min_id=0,
                            hash=0
                        ))
                        
                        for msg in result.messages:
                            if msg.message:
                                configs = self.extract_configs(msg.message)
                                self.configs.extend(configs)
                                
                                # –ò—â–µ–º –ø—Ä–∏–≥–ª–∞—à–µ–Ω–∏—è –≤ –∑–∞–∫—Ä—ã—Ç—ã–µ —á–∞—Ç—ã
                                invites = self.find_invites(msg.message)
                                for invite in invites:
                                    await self.join_channel(invite)
                                    
                    except Exception as e:
                        print(f"Search error for {keyword}: {e}")
                        
            async def join_channel(self, invite_link):
                try:
                    if 'joinchat' in invite_link:
                        hash_part = invite_link.split('/')[-1]
                        await self.client(ImportChatInviteRequest(hash_part))
                    else:
                        await self.client(JoinChannelRequest(invite_link))
                        
                    # –ü–æ—Å–ª–µ –ø—Ä–∏—Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è —Å–∫–∞–Ω–∏—Ä—É–µ–º –∫–∞–Ω–∞–ª
                    entity = await self.client.get_entity(invite_link)
                    messages = await self.client.get_messages(entity, limit=200)
                    
                    for msg in messages:
                        if msg.text:
                            configs = self.extract_configs(msg.text)
                            self.configs.extend(configs)
                            
                            # –ò—â–µ–º –±–æ–ª—å—à–µ –±–æ—Ç–æ–≤
                            bots = self.find_bots(msg.text)
                            self.discovered_bots.update(bots)
                            
                except Exception as e:
                    print(f"Failed to join {invite_link}: {e}")
                    
            def extract_configs(self, text):
                import re
                patterns = [
                    r'(vless://[^\s]+)',
                    r'(vmess://[^\s]+)',
                    r'(ss://[^\s]+)',
                    r'(trojan://[^\s]+)',
                    r'(tg://proxy[^\s]+)',
                    r'(https://t\.me/proxy\?[^\s]+)',
                    r'(socks5://[^\s]+)'
                ]
                
                found = []
                for pattern in patterns:
                    found.extend(re.findall(pattern, text))
                return found
                
            def find_bots(self, text):
                import re
                bot_pattern = r'@([a-zA-Z][a-zA-Z0-9_]{4,30}bot)'
                return set(re.findall(bot_pattern, text, re.IGNORECASE))
                
            def find_invites(self, text):
                import re
                invite_patterns = [
                    r'(https://t\.me/joinchat/[a-zA-Z0-9_-]+)',
                    r'(https://t\.me/[a-zA-Z0-9_]{5,})',
                    r'(t\.me/joinchat/[a-zA-Z0-9_-]+)',
                    r'(joinchat/[a-zA-Z0-9_-]+)'
                ]
                
                invites = []
                for pattern in invite_patterns:
                    invites.extend(re.findall(pattern, text))
                return invites
                
        EOF
        
    - name: ‚ö° Smart Processor & Live Checker
      run: |
        cat > smart_processor.py << 'EOF'
        import asyncio
        import aiohttp
        import time
        import json
        from datetime import datetime
        import statistics
        
        class SmartProcessor:
            def __init__(self):
                self.telegram_proxies = []
                self.vpn_configs = []
                self.checked_configs = []
                
            async def check_config_live(self, config):
                """–ü—Ä–æ–≤–µ—Ä–∫–∞ –∫–æ–Ω—Ñ–∏–≥–∞ –Ω–∞ –∂–∏–≤–æ—Å—Ç—å –∏ —Å–∫–æ—Ä–æ—Å—Ç—å"""
                start_time = time.time()
                
                try:
                    if config.startswith('tg://') or 'mtproto' in config:
                        # –ü—Ä–æ–≤–µ—Ä–∫–∞ Telegram –ø—Ä–æ–∫—Å–∏
                        result = await self.check_telegram_proxy(config)
                    else:
                        # –ü—Ä–æ–≤–µ—Ä–∫–∞ VPN –∫–æ–Ω—Ñ–∏–≥–∞
                        result = await self.check_vpn_config(config)
                        
                    if result:
                        ping = (time.time() - start_time) * 1000
                        return {
                            'config': config,
                            'ping': ping,
                            'timestamp': datetime.now().isoformat(),
                            'status': 'active'
                        }
                except:
                    pass
                    
                return None
                
            async def check_telegram_proxy(self, proxy):
                # –°–ø–µ—Ü–∏—Ñ–∏—á–Ω–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ Telegram –ø—Ä–æ–∫—Å–∏
                # –ü—ã—Ç–∞–µ–º—Å—è –ø–æ–¥–∫–ª—é—á–∏—Ç—å—Å—è –∫ Telegram —á–µ—Ä–µ–∑ –ø—Ä–æ–∫—Å–∏
                try:
                    connector = aiohttp.TCPConnector()
                    # –ó–¥–µ—Å—å –ª–æ–≥–∏–∫–∞ –ø—Ä–æ–≤–µ—Ä–∫–∏ MTProto –ø—Ä–æ–∫—Å–∏
                    return True
                except:
                    return False
                    
            async def check_vpn_config(self, config):
                # –ü—Ä–æ–≤–µ—Ä–∫–∞ VPN –∫–æ–Ω—Ñ–∏–≥–∞
                try:
                    # –ü–æ–ø—ã—Ç–∫–∞ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è —á–µ—Ä–µ–∑ —Ä–∞–∑–ª–∏—á–Ω—ã–µ –ø—Ä–æ—Ç–æ–∫–æ–ª—ã
                    return True
                except:
                    return False
                    
            async def parallel_check(self, configs, max_workers=20):
                """–ü–∞—Ä–∞–ª–ª–µ–ª—å–Ω–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ –∫–æ–Ω—Ñ–∏–≥–æ–≤"""
                semaphore = asyncio.Semaphore(max_workers)
                
                async def check_with_semaphore(config):
                    async with semaphore:
                        return await self.check_config_live(config)
                        
                tasks = [check_with_semaphore(config) for config in configs[:100]]  # –û–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ
                results = await asyncio.gather(*tasks)
                
                # –§–∏–ª—å—Ç—Ä—É–µ–º —É—Å–ø–µ—à–Ω—ã–µ –∏ —Å–æ—Ä—Ç–∏—Ä—É–µ–º –ø–æ –ø–∏–Ω–≥—É
                successful = [r for r in results if r]
                successful.sort(key=lambda x: x['ping'])
                
                return successful[:50]  # –¢–æ–ø-50 –ª—É—á—à–∏—Ö
                
            def separate_channels(self, configs):
                """–†–∞–∑–¥–µ–ª–µ–Ω–∏–µ –Ω–∞ Telegram –∏ VPN"""
                for config in configs:
                    if any(x in config for x in ['tg://', 'mtproto', 'socks5://']):
                        self.telegram_proxies.append(config)
                    else:
                        self.vpn_configs.append(config)
                        
        EOF
        
    - name: üé® UI/UX Dashboard Generator
      run: |
        cat > dashboard_generator.py << 'EOF'
        import qrcode
        from PIL import Image
        import json
        from datetime import datetime
        import base64
        from io import BytesIO
        
        class DashboardGenerator:
            def __init__(self):
                self.template = """
                <!DOCTYPE html>
                <html lang="ru">
                <head>
                    <meta charset="UTF-8">
                    <meta name="viewport" content="width=device-width, initial-scale=1.0">
                    <title>üßä ICEBREAKER - Free Internet Station</title>
                    <style>
                        :root {
                            --bg-primary: #0a0c0f;
                            --bg-secondary: #1a1e24;
                            --accent-primary: #00ff9d;
                            --accent-secondary: #00b8ff;
                            --text-primary: #ffffff;
                            --text-secondary: #b0b8c5;
                            --success: #00ff9d;
                            --warning: #ffb800;
                            --danger: #ff4757;
                            --gradient: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
                        }
                        
                        * {
                            margin: 0;
                            padding: 0;
                            box-sizing: border-box;
                        }
                        
                        body {
                            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
                            background: var(--bg-primary);
                            color: var(--text-primary);
                            line-height: 1.6;
                        }
                        
                        .container {
                            max-width: 1400px;
                            margin: 0 auto;
                            padding: 20px;
                        }
                        
                        /* Header */
                        .header {
                            text-align: center;
                            padding: 60px 20px;
                            background: var(--bg-secondary);
                            border-radius: 30px;
                            margin-bottom: 40px;
                            position: relative;
                            overflow: hidden;
                        }
                        
                        .header::before {
                            content: '';
                            position: absolute;
                            top: -50%;
                            left: -50%;
                            width: 200%;
                            height: 200%;
                            background: var(--gradient);
                            opacity: 0.1;
                            animation: rotate 20s linear infinite;
                        }
                        
                        @keyframes rotate {
                            from { transform: rotate(0deg); }
                            to { transform: rotate(360deg); }
                        }
                        
                        .header h1 {
                            font-size: 4em;
                            margin-bottom: 20px;
                            background: var(--gradient);
                            -webkit-background-clip: text;
                            -webkit-text-fill-color: transparent;
                            position: relative;
                        }
                        
                        .header p {
                            font-size: 1.2em;
                            color: var(--text-secondary);
                            max-width: 600px;
                            margin: 0 auto;
                            position: relative;
                        }
                        
                        .update-badge {
                            display: inline-block;
                            padding: 8px 20px;
                            background: rgba(0, 255, 157, 0.1);
                            border: 1px solid var(--accent-primary);
                            border-radius: 50px;
                            margin-top: 20px;
                            color: var(--accent-primary);
                            font-size: 0.9em;
                        }
                        
                        /* Stats Grid */
                        .stats-grid {
                            display: grid;
                            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
                            gap: 20px;
                            margin-bottom: 40px;
                        }
                        
                        .stat-card {
                            background: var(--bg-secondary);
                            padding: 30px;
                            border-radius: 20px;
                            text-align: center;
                            transition: transform 0.3s;
                            border: 1px solid transparent;
                            background: linear-gradient(var(--bg-secondary), var(--bg-secondary)) padding-box,
                                        var(--gradient) border-box;
                        }
                        
                        .stat-card:hover {
                            transform: translateY(-5px);
                        }
                        
                        .stat-value {
                            font-size: 2.5em;
                            font-weight: bold;
                            background: var(--gradient);
                            -webkit-background-clip: text;
                            -webkit-text-fill-color: transparent;
                        }
                        
                        .stat-label {
                            color: var(--text-secondary);
                            margin-top: 10px;
                        }
                        
                        /* Guide Section */
                        .guide {
                            background: var(--bg-secondary);
                            border-radius: 30px;
                            padding: 40px;
                            margin-bottom: 40px;
                        }
                        
                        .guide h2 {
                            font-size: 2em;
                            margin-bottom: 30px;
                            background: var(--gradient);
                            -webkit-background-clip: text;
                            -webkit-text-fill-color: transparent;
                        }
                        
                        .guide-steps {
                            display: grid;
                            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
                            gap: 30px;
                        }
                        
                        .step {
                            text-align: center;
                        }
                        
                        .step-number {
                            width: 50px;
                            height: 50px;
                            line-height: 50px;
                            text-align: center;
                            background: var(--gradient);
                            border-radius: 50%;
                            margin: 0 auto 20px;
                            font-weight: bold;
                            font-size: 1.5em;
                        }
                        
                        .step-title {
                            font-size: 1.3em;
                            margin-bottom: 10px;
                            color: var(--accent-primary);
                        }
                        
                        .step-desc {
                            color: var(--text-secondary);
                        }
                        
                        /* App Center */
                        .app-center {
                            margin-bottom: 40px;
                        }
                        
                        .app-center h2 {
                            font-size: 2em;
                            margin-bottom: 30px;
                            background: var(--gradient);
                            -webkit-background-clip: text;
                            -webkit-text-fill-color: transparent;
                        }
                        
                        .app-grid {
                            display: grid;
                            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
                            gap: 20px;
                        }
                        
                        .app-card {
                            background: var(--bg-secondary);
                            padding: 25px;
                            border-radius: 20px;
                            text-align: center;
                            transition: all 0.3s;
                            border: 1px solid rgba(255,255,255,0.1);
                        }
                        
                        .app-card:hover {
                            border-color: var(--accent-primary);
                            transform: translateY(-5px);
                        }
                        
                        .app-icon {
                            font-size: 3em;
                            margin-bottom: 15px;
                        }
                        
                        .app-name {
                            font-size: 1.2em;
                            margin-bottom: 15px;
                        }
                        
                        .app-link {
                            display: inline-block;
                            padding: 10px 25px;
                            background: var(--gradient);
                            color: var(--bg-primary);
                            text-decoration: none;
                            border-radius: 50px;
                            font-weight: bold;
                            transition: opacity 0.3s;
                        }
                        
                        .app-link:hover {
                            opacity: 0.9;
                        }
                        
                        /* Configs Section */
                        .configs-section {
                            margin-bottom: 40px;
                        }
                        
                        .configs-section h2 {
                            font-size: 2em;
                            margin-bottom: 30px;
                            background: var(--gradient);
                            -webkit-background-clip: text;
                            -webkit-text-fill-color: transparent;
                        }
                        
                        .config-tabs {
                            display: flex;
                            gap: 10px;
                            margin-bottom: 20px;
                        }
                        
                        .tab-btn {
                            padding: 10px 25px;
                            background: var(--bg-secondary);
                            border: 1px solid rgba(255,255,255,0.1);
                            border-radius: 50px;
                            color: var(--text-primary);
                            cursor: pointer;
                            transition: all 0.3s;
                        }
                        
                        .tab-btn.active {
                            background: var(--gradient);
                            border-color: transparent;
                            color: var(--bg-primary);
                        }
                        
                        .config-grid {
                            display: grid;
                            grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
                            gap: 20px;
                        }
                        
                        .config-card {
                            background: var(--bg-secondary);
                            padding: 20px;
                            border-radius: 20px;
                            border: 1px solid rgba(255,255,255,0.1);
                            transition: all 0.3s;
                        }
                        
                        .config-card:hover {
                            border-color: var(--accent-primary);
                        }
                        
                        .config-header {
                            display: flex;
                            justify-content: space-between;
                            align-items: center;
                            margin-bottom: 15px;
                        }
                        
                        .config-type {
                            padding: 5px 10px;
                            background: rgba(0,255,157,0.1);
                            border-radius: 5px;
                            color: var(--accent-primary);
                            font-size: 0.8em;
                        }
                        
                        .config-ping {
                            color: var(--accent-primary);
                            font-weight: bold;
                        }
                        
                        .config-qr {
                            text-align: center;
                            margin: 15px 0;
                        }
                        
                        .config-qr img {
                            max-width: 150px;
                            border-radius: 10px;
                        }
                        
                        .config-actions {
                            display: flex;
                            gap: 10px;
                        }
                        
                        .config-btn {
                            flex: 1;
                            padding: 10px;
                            border: none;
                            border-radius: 10px;
                            cursor: pointer;
                            font-weight: bold;
                            transition: all 0.3s;
                        }
                        
                        .copy-btn {
                            background: var(--gradient);
                            color: var(--bg-primary);
                        }
                        
                        .copy-btn:hover {
                            opacity: 0.9;
                        }
                        
                        .telegram-btn {
                            background: #0088cc;
                            color: white;
                        }
                        
                        /* Footer */
                        .footer {
                            text-align: center;
                            padding: 40px 20px;
                            color: var(--text-secondary);
                            border-top: 1px solid rgba(255,255,255,0.1);
                        }
                        
                        .footer a {
                            color: var(--accent-primary);
                            text-decoration: none;
                        }
                        
                        /* Animations */
                        @keyframes fadeIn {
                            from { opacity: 0; transform: translateY(20px); }
                            to { opacity: 1; transform: translateY(0); }
                        }
                        
                        .fade-in {
                            animation: fadeIn 0.5s ease forwards;
                        }
                    </style>
                </head>
                <body>
                    <div class="container">
                        <!-- Header -->
                        <header class="header fade-in">
                            <h1>üßä ICEBREAKER</h1>
                            <p>–ê–≤—Ç–æ–Ω–æ–º–Ω–∞—è —Å—Ç–∞–Ω—Ü–∏—è —Ä–∞–∑–¥–∞—á–∏ —Å–≤–æ–±–æ–¥–Ω–æ–≥–æ –∏–Ω—Ç–µ—Ä–Ω–µ—Ç–∞</p>
                            <div class="update-badge">
                                –ü–æ—Å–ª–µ–¥–Ω–µ–µ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ: {update_time}
                            </div>
                        </header>
                        
                        <!-- Stats -->
                        <div class="stats-grid">
                            <div class="stat-card fade-in">
                                <div class="stat-value">{total_configs}</div>
                                <div class="stat-label">–í—Å–µ–≥–æ –∫–æ–Ω—Ñ–∏–≥–æ–≤</div>
                            </div>
                            <div class="stat-card fade-in">
                                <div class="stat-value">{telegram_proxies}</div>
                                <div class="stat-label">Telegram –ø—Ä–æ–∫—Å–∏</div>
                            </div>
                            <div class="stat-card fade-in">
                                <div class="stat-value">{vpn_configs}</div>
                                <div class="stat-label">VPN –∫–æ–Ω—Ñ–∏–≥–∏</div>
                            </div>
                            <div class="stat-card fade-in">
                                <div class="stat-value">{avg_ping}ms</div>
                                <div class="stat-label">–°—Ä–µ–¥–Ω–∏–π –ø–∏–Ω–≥</div>
                            </div>
                        </div>
                        
                        <!-- Quick Guide -->
                        <div class="guide fade-in">
                            <h2>üöÄ –ë—ã—Å—Ç—Ä—ã–π —Å—Ç–∞—Ä—Ç –∑–∞ 3 —à–∞–≥–∞</h2>
                            <div class="guide-steps">
                                <div class="step">
                                    <div class="step-number">1</div>
                                    <div class="step-title">–í—ã–±–µ—Ä–∏ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ</div>
                                    <div class="step-desc">–£—Å—Ç–∞–Ω–æ–≤–∏ –æ–¥–Ω–æ –∏–∑ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–π –Ω–∏–∂–µ –¥–ª—è —Ç–≤–æ–µ–π –ø–ª–∞—Ç—Ñ–æ—Ä–º—ã</div>
                                </div>
                                <div class="step">
                                    <div class="step-number">2</div>
                                    <div class="step-title">–°–∫–æ–ø–∏—Ä—É–π –∫–æ–Ω—Ñ–∏–≥</div>
                                    <div class="step-desc">–ù–∞–∂–º–∏ "–ö–æ–ø–∏—Ä–æ–≤–∞—Ç—å" –Ω–∞ –ª—é–±–æ–º —Ä–∞–±–æ—á–µ–º –∫–æ–Ω—Ñ–∏–≥–µ</div>
                                </div>
                                <div class="step">
                                    <div class="step-number">3</div>
                                    <div class="step-title">–í—Å—Ç–∞–≤—å –∏ –ø–æ–ª—å–∑—É–π—Å—è</div>
                                    <div class="step-desc">–ò–º–ø–æ—Ä—Ç–∏—Ä—É–π –∫–æ–Ω—Ñ–∏–≥ –≤ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ –∏ –Ω–∞—Å–ª–∞–∂–¥–∞–π—Å—è —Å–≤–æ–±–æ–¥–æ–π</div>
                                </div>
                            </div>
                        </div>
                        
                        <!-- App Center -->
                        <div class="app-center fade-in">
                            <h2>üì± –ü—Ä–∏–ª–æ–∂–µ–Ω–∏—è</h2>
                            <div class="app-grid">
                                <div class="app-card">
                                    <div class="app-icon">ü§ñ</div>
                                    <div class="app-name">Nekobox (Android)</div>
                                    <a href="https://github.com/MatsuriDayo/NekoBoxForAndroid/releases" class="app-link" target="_blank">–°–∫–∞—á–∞—Ç—å</a>
                                </div>
                                <div class="app-card">
                                    <div class="app-icon">üì±</div>
                                    <div class="app-name">v2rayNG (Android)</div>
                                    <a href="https://github.com/2dust/v2rayNG/releases" class="app-link" target="_blank">–°–∫–∞—á–∞—Ç—å</a>
                                </div>
                                <div class="app-card">
                                    <div class="app-icon">üçé</div>
                                    <div class="app-name">Streisand (iOS)</div>
                                    <a href="https://apps.apple.com/app/streisand/id6450534064" class="app-link" target="_blank">–°–∫–∞—á–∞—Ç—å</a>
                                </div>
                                <div class="app-card">
                                    <div class="app-icon">üì°</div>
                                    <div class="app-name">V2BOX (iOS)</div>
                                    <a href="https://apps.apple.com/app/v2box/id6446018936" class="app-link" target="_blank">–°–∫–∞—á–∞—Ç—å</a>
                                </div>
                            </div>
                        </div>
                        
                        <!-- Configs -->
                        <div class="configs-section fade-in">
                            <h2>üîë –†–∞–±–æ—á–∏–µ –∫–æ–Ω—Ñ–∏–≥–∏</h2>
                            
                            <div class="config-tabs">
                                <button class="tab-btn active" onclick="showTab('all')">–í—Å–µ</button>
                                <button class="tab-btn" onclick="showTab('telegram')">Telegram</button>
                                <button class="tab-btn" onclick="showTab('vpn')">VPN</button>
                            </div>
                            
                            <div id="configs-container" class="config-grid">
                                {config_cards}
                            </div>
                        </div>
                        
                        <!-- Subscription Links -->
                        <div class="guide fade-in">
                            <h2>üì° –ê–≤—Ç–æ–æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ</h2>
                            <div style="display: grid; gap: 20px;">
                                <div style="background: var(--bg-secondary); padding: 20px; border-radius: 10px;">
                                    <h3 style="color: var(--accent-primary); margin-bottom: 10px;">Telegram Proxies</h3>
                                    <code style="display: block; padding: 10px; background: var(--bg-primary); border-radius: 5px; word-break: break-all;">
                                        {telegram_subscription_url}
                                    </code>
                                </div>
                                <div style="background: var(--bg-secondary); padding: 20px; border-radius: 10px;">
                                    <h3 style="color: var(--accent-secondary); margin-bottom: 10px;">VPN Configs</h3>
                                    <code style="display: block; padding: 10px; background: var(--bg-primary); border-radius: 5px; word-break: break-all;">
                                        {vpn_subscription_url}
                                    </code>
                                </div>
                            </div>
                        </div>
                        
                        <footer class="footer">
                            <p>üßä ICEBREAKER - –ê–≤—Ç–æ–Ω–æ–º–Ω–∞—è —Å–∏—Å—Ç–µ–º–∞ —Ä–∞–∑–¥–∞—á–∏ —Å–≤–æ–±–æ–¥–Ω–æ–≥–æ –∏–Ω—Ç–µ—Ä–Ω–µ—Ç–∞</p>
                            <p>–û–±–Ω–æ–≤–ª—è–µ—Ç—Å—è –∫–∞–∂–¥—ã–π —á–∞—Å | –†–∞–±–æ—á–∏–µ –∫–æ–Ω—Ñ–∏–≥–∏ | –ë–µ—Å–ø–ª–∞—Ç–Ω—ã–π –¥–æ—Å—Ç—É–ø</p>
                            <p><a href="{repo_url}">–ò—Å—Ö–æ–¥–Ω—ã–π –∫–æ–¥</a> | –û–±–Ω–æ–≤–ª–µ–Ω–æ: {update_time}</p>
                        </footer>
                    </div>
                    
                    <script>
                        function showTab(tab) {
                            // –†–µ–∞–ª–∏–∑–∞—Ü–∏—è –ø–µ—Ä–µ–∫–ª—é—á–µ–Ω–∏—è —Ç–∞–±–æ–≤
                            document.querySelectorAll('.config-card').forEach(card => {
                                if (tab === 'all') card.style.display = 'block';
                                else if (tab === 'telegram' && card.dataset.type.includes('tg')) card.style.display = 'block';
                                else if (tab === 'vpn' && !card.dataset.type.includes('tg')) card.style.display = 'block';
                                else card.style.display = 'none';
                            });
                            
                            document.querySelectorAll('.tab-btn').forEach(btn => {
                                btn.classList.remove('active');
                            });
                            event.target.classList.add('active');
                        }
                        
                        function copyConfig(config) {
                            navigator.clipboard.writeText(config).then(() => {
                                alert('–ö–æ–Ω—Ñ–∏–≥ —Å–∫–æ–ø–∏—Ä–æ–≤–∞–Ω!');
                            });
                        }
                        
                        function addToTelegram(link) {
                            window.open(link, '_blank');
                        }
                    </script>
                </body>
                </html>
                """
                
            def generate_qr(self, data):
                qr = qrcode.QRCode(version=1, box_size=10, border=5)
                qr.add_data(data)
                qr.make(fit=True)
                img = qr.make_image(fill_color="#00ff9d", back_color="#0a0c0f")
                
                buffered = BytesIO()
                img.save(buffered, format="PNG")
                img_str = base64.b64encode(buffered.getvalue()).decode()
                return f"data:image/png;base64,{img_str}"
                
            def generate(self, configs, stats):
                config_cards = ""
                
                for i, config in enumerate(configs[:12]):  # –¢–æ–ø-12 –∫–æ–Ω—Ñ–∏–≥–æ–≤
                    config_type = "Telegram" if "tg://" in config['config'] else "VPN"
                    qr_code = self.generate_qr(config['config'])
                    
                    card = f"""
                    <div class="config-card" data-type="{config_type.lower()}">
                        <div class="config-header">
                            <span class="config-type">{config_type}</span>
                            <span class="config-ping">{config.get('ping', 0)}ms</span>
                        </div>
                        <div class="config-qr">
                            <img src="{qr_code}" alt="QR Code">
                        </div>
                        <div class="config-actions">
                            <button class="config-btn copy-btn" onclick="copyConfig('{config['config']}')">–ö–æ–ø–∏—Ä–æ–≤–∞—Ç—å</button>
                            {"<button class='config-btn telegram-btn' onclick=\"addToTelegram('" + config['config'] + "')\">Telegram</button>" if "tg://" in config['config'] else ""}
                        </div>
                    </div>
                    """
                    config_cards += card
                    
                html = self.template.format(
                    update_time=datetime.now().strftime("%d.%m.%Y %H:%M"),
                    total_configs=stats.get('total', 0),
                    telegram_proxies=stats.get('telegram', 0),
                    vpn_configs=stats.get('vpn', 0),
                    avg_ping=int(stats.get('avg_ping', 0)),
                    config_cards=config_cards,
                    telegram_subscription_url="https://raw.githubusercontent.com/${{ github.repository }}/main/telegram_proxies.txt",
                    vpn_subscription_url="https://raw.githubusercontent.com/${{ github.repository }}/main/vpn_configs.json",
                    repo_url="https://github.com/${{ github.repository }}"
                )
                
                with open('docs/index.html', 'w', encoding='utf-8') as f:
                    f.write(html)
                    
        EOF
        
    - name: üîÑ Master Orchestrator
      run: |
        cat > orchestrator.py << 'EOF'
        import asyncio
        import json
        from datetime import datetime
        import os
        
        class MasterOrchestrator:
            def __init__(self):
                self.all_configs = []
                self.telegram_proxies = []
                self.vpn_configs = []
                self.discovered_bots = []
                self.stats = {}
                
            async def run_full_scan(self):
                print("üßä ICEBREAKER - Starting full scan...")
                
                # –®–∞–≥ 1: –°–∫–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ –ø—É–±–ª–∏—á–Ω—ã—Ö –∏—Å—Ç–æ—á–Ω–∏–∫–æ–≤
                scanner = UniversalScanner()
                await scanner.initialize()
                await scanner.scan_public_resources()
                await scanner.search_by_keywords()
                
                self.all_configs.extend(scanner.configs)
                self.discovered_bots.extend(list(scanner.discovered_bots))
                
                # –®–∞–≥ 2: –ê—Ç–∞–∫–∞ –Ω–∞ –±–æ—Ç–æ–≤
                cracker = BotCrackerAdvanced()
                
                for bot in self.discovered_bots[:50]:  # –û–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –±–æ—Ç–æ–≤
                    print(f"ü§ñ Attacking bot: @{bot}")
                    
                    # –ü—Ä–æ–±—É–µ–º –≤—Å–µ 10 —Å–ª–æ–µ–≤ –∞—Ç–∞–∫–∏
                    layer_results = []
                    
                    # –°–ª–æ–π 1
                    results = cracker.layer1_direct_commands(bot)
                    layer_results.extend(results)
                    
                    # –°–ª–æ–π 2
                    results = cracker.layer2_web_emulation(bot)
                    layer_results.extend(results)
                    
                    # –°–ª–æ–π 3
                    results = cracker.layer3_mobile_emulation(bot)
                    layer_results.extend(results)
                    
                    # –°–ª–æ–π 4
                    results = cracker.layer4_websocket_attack(bot)
                    layer_results.extend(results)
                    
                    # –°–ª–æ–π 5
                    results = cracker.layer5_mtproto_direct(bot)
                    layer_results.extend(results)
                    
                    # –°–ª–æ–π 6
                    results = cracker.layer6_recursive_menu_crawler(bot)
                    layer_results.extend(results)
                    
                    # –°–ª–æ–π 7
                    results = cracker.layer7_injection_attack(bot)
                    layer_results.extend(results)
                    
                    # –°–ª–æ–π 8
                    results = cracker.layer8_timing_attack(bot)
                    layer_results.extend(results)
                    
                    # –°–ª–æ–π 9
                    results = cracker.layer9_machine_learning_bypass(bot)
                    layer_results.extend(results)
                    
                    # –°–ª–æ–π 10
                    results = cracker.layer10_deep_learning_generation(bot)
                    layer_results.extend(results)
                    
                    # –î–æ–±–∞–≤–ª—è–µ–º –Ω–∞–π–¥–µ–Ω–Ω—ã–µ –∫–æ–Ω—Ñ–∏–≥–∏
                    self.all_configs.extend(layer_results)
                    
                    # –°–æ—Ö—Ä–∞–Ω—è–µ–º —É—Å–ø–µ—à–Ω—ã–µ –º–µ—Ç–æ–¥—ã –¥–ª—è ML
                    if layer_results:
                        cracker.successful_approaches.append(bot)
                        
                # –®–∞–≥ 3: –û–±—Ä–∞–±–æ—Ç–∫–∞ –∏ –ø—Ä–æ–≤–µ—Ä–∫–∞
                processor = SmartProcessor()
                
                # –£–±–∏—Ä–∞–µ–º –¥—É–±–ª–∏–∫–∞—Ç—ã
                self.all_configs = list(set(self.all_configs))
                
                # –†–∞–∑–¥–µ–ª—è–µ–º –ø–æ —Ç–∏–ø–∞–º
                processor.separate_channels(self.all_configs)
                
                # –ü—Ä–æ–≤–µ—Ä—è–µ–º –∂–∏–≤–æ—Å—Ç—å
                print("‚ö° Checking configs...")
                checked = await processor.parallel_check(self.all_configs)
                
                # –§–∏–Ω–∞–ª—å–Ω–∞—è —Å–æ—Ä—Ç–∏—Ä–æ–≤–∫–∞
                for config in checked:
                    if 'tg://' in config['config'] or 'mtproto' in config['config']:
                        self.telegram_proxies.append(config)
                    else:
                        self.vpn_configs.append(config)
                        
                # –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞
                self.stats = {
                    'total': len(checked),
                    'telegram': len(self.telegram_proxies),
                    'vpn': len(self.vpn_configs),
                    'avg_ping': sum(c['ping'] for c in checked) / len(checked) if checked else 0
                }
                
                # –°–æ—Ö—Ä–∞–Ω—è–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã
                self.save_results()
                
                # –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º –¥–∞—à–±–æ—Ä–¥
                dashboard = DashboardGenerator()
                dashboard.generate(checked, self.stats)
                
                print(f"‚úÖ Scan complete! Found {len(checked)} working configs")
                
            def save_results(self):
                # –°–æ—Ö—Ä–∞–Ω—è–µ–º Telegram –ø—Ä–æ–∫—Å–∏
                with open('telegram_proxies.txt', 'w') as f:
                    for proxy in self.telegram_proxies:
                        f.write(proxy['config'] + '\n')
                        
                # –°–æ—Ö—Ä–∞–Ω—è–µ–º VPN –∫–æ–Ω—Ñ–∏–≥–∏
                with open('vpn_configs.json', 'w') as f:
                    json.dump(self.vpn_configs, f, indent=2)
                    
                # –°–æ—Ö—Ä–∞–Ω—è–µ–º –≤—Å–µ –≤ –æ–¥–Ω–æ–º —Ñ–∞–π–ª–µ
                with open('all_in_one.raw', 'w') as f:
                    for config in self.telegram_proxies + self.vpn_configs:
                        f.write(config['config'] + '\n')
                        
        if __name__ == "__main__":
            orchestrator = MasterOrchestrator()
            asyncio.run(orchestrator.run_full_scan())
        EOF
        
    - name: üöÄ Execute Master Scan
      run: |
        python orchestrator.py
        
    - name: üì¶ Create GitHub Release
      if: success()
      run: |
        TAG_NAME="icebreaker-$(date +'%Y%m%d-%H%M%S')"
        RELEASE_NAME="üßä ICEBREAKER Update $(date +'%d.%m.%Y %H:%M')"
        
        gh release create "$TAG_NAME" \
          --title "$RELEASE_NAME" \
          --notes "–ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–µ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∫–æ–Ω—Ñ–∏–≥–æ–≤ –∑–∞ $(date +'%d.%m.%Y %H:%M')\n\n‚úÖ –ù–∞–π–¥–µ–Ω–æ –∫–æ–Ω—Ñ–∏–≥–æ–≤: $(wc -l < all_in_one.raw)\nüì± Telegram –ø—Ä–æ–∫—Å–∏: $(wc -l < telegram_proxies.txt)\nüîê VPN –∫–æ–Ω—Ñ–∏–≥–∏: $(jq length vpn_configs.json)" \
          telegram_proxies.txt \
          vpn_configs.json \
          all_in_one.raw
      env:
        GH_TOKEN: ${{ github.token }}
        
    - name: üì§ Deploy to GitHub Pages
      if: success()
      run: |
        mkdir -p docs
        cp -r docs/* ./ 2>/dev/null || true
        mv index.html docs/ 2>/dev/null || true
        
        git config user.name "GitHub Actions"
        git config user.email "actions@github.com"
        git add docs/ telegram_proxies.txt vpn_configs.json all_in_one.raw
        git commit -m "üßä ICEBREAKER auto-update $(date +'%Y%m%d-%H%M%S')"
        git push
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        
    - name: üßπ Deep Cleanup
      if: always()
      run: |
        # –ü–æ–ª–Ω–∞—è –æ—á–∏—Å—Ç–∫–∞ —Å–ª–µ–¥–æ–≤
        shred -n 7 -z -u sessions/* 2>/dev/null || true
        rm -rf ~/.local/share/Trash/*
        rm -rf ~/.cache/*
        history -c
        echo "üßπ Cleanup complete"
