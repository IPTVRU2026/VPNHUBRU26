name: üßä ICEBREAKER - Ultimate Auto-Deploying System

on:
  schedule:
    - cron: '0 * * * *'  # –ö–∞–∂–¥—ã–π —á–∞—Å
  workflow_dispatch:
  push:
    branches: [ main ]

env:
  TG_API_ID: "38922115"
  TG_API_HASH: "b34ae241317eff8743f538a8272c5f6d"

jobs:
  icebreaker:
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pages: write
      id-token: write
    
    steps:
    - name: üîß Setup Python
      uses: actions/setup-python@v5
      with:
        python-version: '3.11'

    - name: üì¶ Install Dependencies
      run: |
        pip install telethon pyrogram tgcrypto aiohttp beautifulsoup4 requests lxml qrcode pillow

    - name: üìù Create All Scripts
      run: |
        mkdir -p {output/telegram,output/vpn,output/raw,output/qr,logs,sessions,site,scripts}
        
        # ==================== BOT INFILTRATOR ====================
        cat > scripts/bot_infiltrator.py << 'SCRIPT1'
        #!/usr/bin/env python3
        import asyncio, random, json, re, logging
        from datetime import datetime
        from telethon import TelegramClient, events
        from telethon.tl.functions.messages import GetBotCallbackAnswerRequest
        from telethon.tl.types import KeyboardButtonCallback, KeyboardButtonUrl
        
        API_ID = 38922115
        API_HASH = "b34ae241317eff8743f538a8272c5f6d"
        
        TARGET_BOTS = ["@MTProtoProxybot", "@ProxyMTProtoBot", "@socks5_bot", "@vmess_vless_bot", 
                       "@FreeVPNbot", "@v2ray_config_bot", "@shadowsocks_bot", "@proxytelegrambot",
                       "@vpnconfig_bot", "@proxy_seller_bot"]
        
        CONFIG_PATTERNS = {
            'tg_proxy': re.compile(r'(tg://proxy\?[^\s]+)'),
            'vless': re.compile(r'(vless://[^\s]+)'),
            'vmess': re.compile(r'(vmess://[^\s]+)'),
            'ss': re.compile(r'(ss://[^\s]+)'),
            'trojan': re.compile(r'(trojan://[^\s]+)'),
        }
        
        logging.basicConfig(level=logging.INFO)
        logger = logging.getLogger(__name__)
        
        class BotInfiltrator:
            def __init__(self):
                self.client = None
                self.configs = {'telegram': [], 'vpn': [], 'raw': []}
        
            async def init_client(self):
                self.client = TelegramClient("sessions/ice", API_ID, API_HASH)
                await self.client.start()
                logger.info("‚úÖ Client ready")
        
            async def strategy_1_direct(self, bot):
                try:
                    await self.client.send_message(bot, '/start')
                    await asyncio.sleep(2)
                    msgs = await self.client.get_messages(bot, limit=5)
                    for m in msgs:
                        if m.text: self.extract(m.text, bot, "direct")
                    return True
                except: return False
        
            async def strategy_2_buttons(self, bot):
                try:
                    msgs = await self.client.get_messages(bot, limit=10)
                    for m in msgs:
                        if m.reply_markup:
                            for row in m.reply_markup.rows:
                                for btn in row.buttons:
                                    if isinstance(btn, KeyboardButtonCallback):
                                        try:
                                            await self.client(GetBotCallbackAnswerRequest(peer=bot, msg_id=m.id, data=btn.data))
                                            await asyncio.sleep(1)
                                            new = await self.client.get_messages(bot, limit=3)
                                            for n in new:
                                                if n.text: self.extract(n.text, bot, "button")
                                        except: pass
                    return True
                except: return False
        
            async def strategy_3_menu(self, bot):
                try:
                    cmds = ['/free', '/test', '/trial', 'Free', 'Test']
                    for c in cmds:
                        await self.client.send_message(bot, c)
                        await asyncio.sleep(1)
                        msgs = await self.client.get_messages(bot, limit=3)
                        for m in msgs:
                            if m.text: self.extract(m.text, bot, "menu")
                    return True
                except: return False
        
            async def strategy_4_history(self, bot):
                try:
                    msgs = await self.client.get_messages(bot, limit=100)
                    for m in msgs:
                        if m.text: self.extract(m.text, bot, "history")
                    return True
                except: return False
        
            async def strategy_5_urls(self, bot):
                try:
                    msgs = await self.client.get_messages(bot, limit=20)
                    for m in msgs:
                        if m.reply_markup:
                            for row in m.reply_markup.rows:
                                for btn in row.buttons:
                                    if isinstance(btn, KeyboardButtonUrl):
                                        self.configs['telegram'].append({'config': btn.url, 'source': bot, 'method': 'url'})
                    return True
                except: return False
        
            def extract(self, text, source, method):
                for typ, pat in CONFIG_PATTERNS.items():
                    for m in pat.findall(text):
                        data = {'config': m, 'type': typ, 'source': source, 'method': method, 'time': datetime.now().isoformat()}
                        if typ in ['tg_proxy']:
                            if data not in self.configs['telegram']: 
                                self.configs['telegram'].append(data)
                                logger.info(f"‚úÖ TG: {m[:50]}...")
                        else:
                            if data not in self.configs['vpn']: 
                                self.configs['vpn'].append(data)
                                logger.info(f"‚úÖ VPN: {m[:50]}...")
                        self.configs['raw'].append(data)
        
            async def attack(self, bot):
                logger.info(f"üéØ Attacking {bot}")
                strategies = [self.strategy_1_direct, self.strategy_2_buttons, self.strategy_3_menu, 
                             self.strategy_4_history, self.strategy_5_urls]
                for s in strategies:
                    try:
                        await s(bot)
                        await asyncio.sleep(random.uniform(1, 3))
                    except: pass
        
            async def run(self):
                await self.init_client()
                for bot in TARGET_BOTS:
                    try:
                        await self.attack(bot)
                        await asyncio.sleep(5)
                    except Exception as e:
                        logger.error(f"Failed {bot}: {e}")
                
                with open('output/telegram/from_bots.txt', 'w') as f:
                    for i in self.configs['telegram']: f.write(f"{i['config']}\n")
                with open('output/vpn/from_bots.json', 'w') as f:
                    json.dump(self.configs['vpn'], f, indent=2)
                
                await self.client.disconnect()
                logger.info(f"üéâ Done: {len(self.configs['telegram'])} TG, {len(self.configs['vpn'])} VPN")
        
        asyncio.run(BotInfiltrator().run())
        SCRIPT1
        
        # ==================== TELEGRAM MONITOR ====================
        cat > scripts/tg_monitor.py << 'SCRIPT2'
        #!/usr/bin/env python3
        import asyncio, json, re, logging
        from datetime import datetime
        from telethon import TelegramClient
        
        API_ID = 38922115
        API_HASH = "b34ae241317eff8743f538a8272c5f6d"
        
        CHANNELS = ["@proxy_mtm", "@free_proxy_vpn", "@vpn_free", "@v2raycollector", "@VmessProtocol",
                   "@DirectVPN", "@freev2rays", "@MTProxies", "@proxy_socks5", "@freeshadowsocks"]
        
        PATTERNS = {
            'vless': re.compile(r'vless://[^\s]+'),
            'vmess': re.compile(r'vmess://[^\s]+'),
            'ss': re.compile(r'ss://[^\s]+'),
            'tg_proxy': re.compile(r'tg://proxy\?[^\s]+'),
        }
        
        logging.basicConfig(level=logging.INFO)
        logger = logging.getLogger(__name__)
        
        class Monitor:
            def __init__(self):
                self.client = None
                self.configs = []
        
            async def init(self):
                self.client = TelegramClient("sessions/mon", API_ID, API_HASH)
                await self.client.start()
        
            async def scan(self, ch):
                logger.info(f"üì° Scanning {ch}")
                try:
                    entity = await self.client.get_entity(ch)
                    msgs = await self.client.get_messages(entity, limit=100)
                    for m in msgs:
                        if m.text:
                            for typ, pat in PATTERNS.items():
                                for match in pat.findall(m.text):
                                    data = {'config': match, 'type': typ, 'source': ch, 'time': datetime.now().isoformat()}
                                    if data not in self.configs:
                                        self.configs.append(data)
                                        logger.info(f"‚úÖ Found {typ}")
                except Exception as e:
                    logger.error(f"Error {ch}: {e}")
        
            async def run(self):
                await self.init()
                for ch in CHANNELS:
                    await self.scan(ch)
                    await asyncio.sleep(2)
                
                tg = [c for c in self.configs if c['type'] == 'tg_proxy']
                vpn = [c for c in self.configs if c['type'] in ['vless','vmess','ss']]
                
                with open('output/telegram/from_channels.txt', 'w') as f:
                    for i in tg: f.write(f"{i['config']}\n")
                with open('output/vpn/from_channels.json', 'w') as f:
                    json.dump(vpn, f, indent=2)
                
                await self.client.disconnect()
                logger.info(f"üéâ Done: {len(tg)} TG, {len(vpn)} VPN")
        
        asyncio.run(Monitor().run())
        SCRIPT2
        
        # ==================== WEB CRAWLER ====================
        cat > scripts/web_crawler.py << 'SCRIPT3'
        #!/usr/bin/env python3
        import asyncio, aiohttp, re, json, logging
        from datetime import datetime
        from bs4 import BeautifulSoup
        
        PATTERNS = {
            'vless': re.compile(r'vless://[^\s]+'),
            'vmess': re.compile(r'vmess://[^\s]+'),
            'ss': re.compile(r'ss://[^\s]+'),
            'tg_proxy': re.compile(r'tg://proxy\?[^\s]+'),
        }
        
        logging.basicConfig(level=logging.INFO)
        logger = logging.getLogger(__name__)
        
        class Crawler:
            def __init__(self):
                self.session = None
                self.configs = []
        
            async def init(self):
                self.session = aiohttp.ClientSession(headers={'User-Agent': 'Mozilla/5.0'})
        
            async def gists(self):
                logger.info("üîç GitHub Gists...")
                queries = ['vless config', 'vmess config', 'v2ray', 'proxy telegram']
                for q in queries:
                    try:
                        url = f"https://gist.github.com/search?q={q.replace(' ', '+')}"
                        async with self.session.get(url) as r:
                            html = await r.text()
                            soup = BeautifulSoup(html, 'html.parser')
                            links = soup.find_all('a', class_='Link--primary')
                            for link in links[:5]:
                                raw = f"https://gist.github.com{link['href']}/raw"
                                try:
                                    async with self.session.get(raw) as gr:
                                        content = await gr.text()
                                        self.extract(content, f"Gist:{q}")
                                except: pass
                        await asyncio.sleep(2)
                    except: pass
        
            async def pastebin(self):
                logger.info("üìã Pastebin...")
                try:
                    async with self.session.get("https://pastebin.com/archive") as r:
                        html = await r.text()
                        soup = BeautifulSoup(html, 'html.parser')
                        links = soup.find_all('a', href=re.compile(r'/[A-Za-z0-9]{8}'))
                        for link in links[:15]:
                            pid = link['href'].strip('/')
                            raw = f"https://pastebin.com/raw/{pid}"
                            try:
                                async with self.session.get(raw) as pr:
                                    content = await pr.text()
                                    if any(k in content.lower() for k in ['vless','vmess','proxy']):
                                        self.extract(content, f"Paste:{pid}")
                            except: pass
                            await asyncio.sleep(0.5)
                except: pass
        
            async def github_repos(self):
                logger.info("üéØ GitHub Repos...")
                urls = [
                    "https://raw.githubusercontent.com/awesome-vpn/awesome-vpn/master/all",
                    "https://raw.githubusercontent.com/freefq/free/master/v2"
                ]
                for url in urls:
                    try:
                        async with self.session.get(url) as r:
                            if r.status == 200:
                                content = await r.text()
                                self.extract(content, url)
                    except: pass
        
            def extract(self, text, source):
                for typ, pat in PATTERNS.items():
                    for m in pat.findall(text):
                        data = {'config': m, 'type': typ, 'source': source, 'time': datetime.now().isoformat()}
                        if data not in self.configs:
                            self.configs.append(data)
                            logger.info(f"‚úÖ {typ}")
        
            async def run(self):
                await self.init()
                await asyncio.gather(self.gists(), self.pastebin(), self.github_repos(), return_exceptions=True)
                
                tg = [c for c in self.configs if c['type'] == 'tg_proxy']
                vpn = [c for c in self.configs if c['type'] in ['vless','vmess','ss']]
                
                with open('output/telegram/from_web.txt', 'w') as f:
                    for i in tg: f.write(f"{i['config']}\n")
                with open('output/vpn/from_web.json', 'w') as f:
                    json.dump(vpn, f, indent=2)
                
                await self.session.close()
                logger.info(f"üéâ Done: {len(tg)} TG, {len(vpn)} VPN")
        
        asyncio.run(Crawler().run())
        SCRIPT3
        
        # ==================== CONFIG MERGER ====================
        cat > scripts/merge.py << 'SCRIPT4'
        #!/usr/bin/env python3
        import json, logging, base64
        from pathlib import Path
        
        logging.basicConfig(level=logging.INFO)
        logger = logging.getLogger(__name__)
        
        # Merge Telegram
        tg_set = set()
        for f in ['output/telegram/from_bots.txt', 'output/telegram/from_channels.txt', 'output/telegram/from_web.txt']:
            try:
                with open(f) as file:
                    for line in file:
                        line = line.strip()
                        if line: tg_set.add(line)
            except: pass
        
        with open('output/telegram/telegram_proxies.txt', 'w') as f:
            for cfg in sorted(tg_set): f.write(f"{cfg}\n")
        
        logger.info(f"‚úÖ Merged {len(tg_set)} Telegram proxies")
        
        # Merge VPN
        vpn_list = []
        seen = set()
        for f in ['output/vpn/from_bots.json', 'output/vpn/from_channels.json', 'output/vpn/from_web.json']:
            try:
                with open(f) as file:
                    data = json.load(file)
                    for item in data:
                        cfg = item.get('config', '')
                        if cfg and cfg not in seen:
                            seen.add(cfg)
                            vpn_list.append(item)
            except: pass
        
        with open('output/vpn/vpn_configs.json', 'w') as f:
            json.dump(vpn_list, f, indent=2)
        
        logger.info(f"‚úÖ Merged {len(vpn_list)} VPN configs")
        
        # All-in-one
        with open('output/raw/all_in_one.txt', 'w') as f:
            f.write("# ===== TELEGRAM PROXIES =====\n")
            for cfg in sorted(tg_set): f.write(f"{cfg}\n")
            f.write("\n# ===== VPN CONFIGS =====\n")
            for item in vpn_list: f.write(f"{item['config']}\n")
        
        # Subscription
        all_vpn = '\n'.join([i['config'] for i in vpn_list])
        sub = base64.b64encode(all_vpn.encode()).decode()
        with open('output/raw/subscription.txt', 'w') as f:
            f.write(sub)
        
        logger.info("üì¶ Created all-in-one and subscription")
        SCRIPT4
        
        # ==================== WEBSITE GENERATOR ====================
        cat > scripts/website.py << 'SCRIPT5'
        #!/usr/bin/env python3
        from datetime import datetime
        
        html = f"""<!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <meta name="viewport" content="width=device-width, initial-scale=1.0">
            <title>üßä ICEBREAKER - Free Proxy & VPN</title>
            <style>
                * {{ margin: 0; padding: 0; box-sizing: border-box; }}
                body {{
                    font-family: 'Segoe UI', sans-serif;
                    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                    color: #fff;
                    min-height: 100vh;
                    padding: 20px;
                }}
                .container {{ max-width: 1200px; margin: 0 auto; }}
                header {{
                    text-align: center;
                    padding: 40px 0;
                    border-bottom: 2px solid rgba(255,255,255,0.2);
                }}
                h1 {{
                    font-size: 3.5em;
                    margin-bottom: 10px;
                    text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
                }}
                .tagline {{
                    font-size: 1.3em;
                    opacity: 0.9;
                }}
                .section {{
                    background: rgba(255,255,255,0.1);
                    backdrop-filter: blur(10px);
                    border-radius: 20px;
                    padding: 40px;
                    margin: 30px 0;
                    border: 1px solid rgba(255,255,255,0.2);
                }}
                h2 {{
                    font-size: 2em;
                    margin-bottom: 20px;
                    color: #ffd700;
                }}
                .download-grid {{
                    display: grid;
                    grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
                    gap: 20px;
                }}
                .download-card {{
                    background: rgba(255,255,255,0.1);
                    padding: 25px;
                    border-radius: 15px;
                    border: 2px solid rgba(255,255,255,0.2);
                    transition: all 0.3s;
                }}
                .download-card:hover {{
                    transform: translateY(-5px);
                    border-color: #ffd700;
                    box-shadow: 0 10px 30px rgba(0,0,0,0.3);
                }}
                .download-card h3 {{
                    color: #ffd700;
                    margin-bottom: 15px;
                }}
                .btn {{
                    display: inline-block;
                    background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
                    color: white;
                    padding: 12px 30px;
                    border-radius: 25px;
                    text-decoration: none;
                    margin: 10px 5px;
                    transition: all 0.3s;
                    border: 2px solid rgba(255,255,255,0.3);
                    font-weight: bold;
                }}
                .btn:hover {{
                    transform: scale(1.05);
                    box-shadow: 0 5px 20px rgba(0,0,0,0.3);
                }}
                .guide {{
                    background: rgba(0,0,0,0.2);
                    padding: 25px;
                    border-radius: 15px;
                    margin: 20px 0;
                    border-left: 4px solid #ffd700;
                }}
                .guide h3 {{ color: #ffd700; margin-bottom: 15px; }}
                .guide ol {{ margin-left: 20px; line-height: 1.8; }}
                footer {{
                    text-align: center;
                    padding: 40px 0;
                    border-top: 2px solid rgba(255,255,255,0.2);
                    margin-top: 40px;
                }}
            </style>
        </head>
        <body>
            <div class="container">
                <header>
                    <h1>üßä ICEBREAKER</h1>
                    <p class="tagline">Your Ultimate Free Proxy & VPN Aggregator</p>
                    <p>Auto-updated every hour | Always fresh configs</p>
                    <p style="margin-top: 10px;">Last update: {datetime.now().strftime('%Y-%m-%d %H:%M UTC')}</p>
                </header>
                
                <div class="section">
                    <h2>üì¶ Download Configs</h2>
                    <div class="download-grid">
                        <div class="download-card">
                            <h3>üì± Telegram Proxies</h3>
                            <p>MTProto & SOCKS5 for Telegram</p>
                            <a href="../releases/latest/download/telegram_proxies.txt" class="btn">Download</a>
                        </div>
                        <div class="download-card">
                            <h3>üöÄ VPN Configs</h3>
                            <p>VLESS, VMess, Shadowsocks, Trojan</p>
                            <a href="../releases/latest/download/vpn_configs.json" class="btn">Download</a>
                        </div>
                        <div class="download-card">
                            <h3>üìã All-in-One</h3>
                            <p>All configs in one file</p>
                            <a href="../releases/latest/download/all_in_one.txt" class="btn">Download</a>
                        </div>
                        <div class="download-card">
                            <h3>üîÑ Subscription</h3>
                            <p>Auto-update link</p>
                            <a href="../releases/latest/download/subscription.txt" class="btn">Get Link</a>
                        </div>
                    </div>
                </div>
                
                <div class="section">
                    <h2>üéì Quick Start Guide</h2>
                    <div class="guide">
                        <h3>For Telegram:</h3>
                        <ol>
                            <li>Download telegram_proxies.txt</li>
                            <li>Open Telegram ‚Üí Settings ‚Üí Data and Storage ‚Üí Proxy</li>
                            <li>Add Proxy and paste any line from file</li>
                            <li>Enable and enjoy!</li>
                        </ol>
                    </div>
                    <div class="guide">
                        <h3>For VPN (Android):</h3>
                        <ol>
                            <li>Install Nekobox or v2rayNG</li>
                            <li>Download vpn_configs.json</li>
                            <li>Import file in app</li>
                            <li>Connect!</li>
                        </ol>
                    </div>
                </div>
                
                <footer>
                    <p>üßä <strong>ICEBREAKER</strong> - Autonomous Proxy Aggregator</p>
                    <p>Built with ‚ù§Ô∏è using GitHub Actions</p>
                </footer>
            </div>
        </body>
        </html>"""
        
        with open('site/index.html', 'w') as f:
            f.write(html)
        
        print("‚úÖ Website generated!")
        SCRIPT5
        
        chmod +x scripts/*.py

    - name: ü§ñ Bot Infiltration
      timeout-minutes: 20
      run: python scripts/bot_infiltrator.py
      continue-on-error: true

    - name: üì° Telegram Monitoring
      timeout-minutes: 15
      run: python scripts/tg_monitor.py
      continue-on-error: true

    - name: üï∏Ô∏è Web Crawling
      timeout-minutes: 15
      run: python scripts/web_crawler.py
      continue-on-error: true

    - name: üîÑ Merge Configs
      run: python scripts/merge.py

    - name: üåê Generate Website
      run: python scripts/website.py

    - name: üìä Count Results
      id: stats
      run: |
        TG_COUNT=$(wc -l < output/telegram/telegram_proxies.txt 2>/dev/null || echo 0)
        VPN_COUNT=$(cat output/vpn/vpn_configs.json 2>/dev/null | grep -c '"config"' || echo 0)
        echo "tg_count=$TG_COUNT" >> $GITHUB_OUTPUT
        echo "vpn_count=$VPN_COUNT" >> $GITHUB_OUTPUT
        echo "timestamp=$(date '+%Y-%m-%d %H:%M UTC')" >> $GITHUB_OUTPUT

    - name: üìù Create Release
      id: release
      run: |
        TAG="update-$(date '+%Y%m%d-%H%M')"
        echo "tag=$TAG" >> $GITHUB_OUTPUT
        
        TG_COUNT="${{ steps.stats.outputs.tg_count }}"
        VPN_COUNT="${{ steps.stats.outputs.vpn_count }}"
        TIMESTAMP="$(date '+%Y-%m-%d %H:%M UTC')"
        
        cat > notes.md << EOF
        # üßä ICEBREAKER Auto-Update
        
        **Timestamp:** $TIMESTAMP
        
        ## üìä Statistics
        - Telegram Proxies: $TG_COUNT
        - VPN Configs: $VPN_COUNT
        
        ## üì¶ Files
        - \`telegram_proxies.txt\` - MTProto/SOCKS5 proxies
        - \`vpn_configs.json\` - VPN configurations
        - \`all_in_one.txt\` - All configs
        - \`subscription.txt\` - Subscription link
        
        ## üì± Apps
        **Android:** [Nekobox](https://github.com/MatsuriDayo/NekoBoxForAndroid/releases), [v2rayNG](https://github.com/2dust/v2rayNG/releases)
        **iOS:** [Streisand](https://apps.apple.com/app/streisand/id6450534064), [V2BOX](https://apps.apple.com/app/v2box-v2ray-client/id6446814690)
        
        ---
        *Auto-generated by ICEBREAKER*
        EOF

    - name: üéÅ Publish Release
      uses: softprops/action-gh-release@v1
      with:
        tag_name: ${{ steps.release.outputs.tag }}
        name: "Update ${{ steps.stats.outputs.timestamp }}"
        body_path: notes.md
        files: |
          output/telegram/telegram_proxies.txt
          output/vpn/vpn_configs.json
          output/raw/all_in_one.txt
          output/raw/subscription.txt
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

    - name: üåê Deploy Website
      uses: peaceiris/actions-gh-pages@v3
      with:
        github_token: ${{ secrets.GITHUB_TOKEN }}
        publish_dir: ./site
        user_name: 'ICEBREAKER Bot'
        user_email: 'bot@icebreaker.auto'

    - name: ‚úÖ Complete
      run: |
        echo "üéâ ICEBREAKER completed successfully!"
        echo "üìä Telegram: ${{ steps.stats.outputs.tg_count }}"
        echo "üìä VPN: ${{ steps.stats.outputs.vpn_count }}"
        echo "üåê Website: Updated"
        echo "üì¶ Release: Created"
        cat > scripts/bot_infiltrator.py << 'SCRIPT1'
        #!/usr/bin/env python3
        import asyncio, random, json, re, logging
        from datetime import datetime
        from telethon import TelegramClient, events
        from telethon.tl.functions.messages import GetBotCallbackAnswerRequest
        from telethon.tl.types import KeyboardButtonCallback, KeyboardButtonUrl
        
        API_ID = 38922115
        API_HASH = "b34ae241317eff8743f538a8272c5f6d"
        
        TARGET_BOTS = ["@MTProtoProxybot", "@ProxyMTProtoBot", "@socks5_bot", "@vmess_vless_bot", 
                       "@FreeVPNbot", "@v2ray_config_bot", "@shadowsocks_bot", "@proxytelegrambot",
                       "@vpnconfig_bot", "@proxy_seller_bot"]
        
        CONFIG_PATTERNS = {
            'tg_proxy': re.compile(r'(tg://proxy\?[^\s]+)'),
            'vless': re.compile(r'(vless://[^\s]+)'),
            'vmess': re.compile(r'(vmess://[^\s]+)'),
            'ss': re.compile(r'(ss://[^\s]+)'),
            'trojan': re.compile(r'(trojan://[^\s]+)'),
        }
        
        logging.basicConfig(level=logging.INFO)
        logger = logging.getLogger(__name__)
        
        class BotInfiltrator:
            def __init__(self):
                self.client = None
                self.configs = {'telegram': [], 'vpn': [], 'raw': []}
        
            async def init_client(self):
                self.client = TelegramClient("sessions/ice", API_ID, API_HASH)
                await self.client.start()
                logger.info("‚úÖ Client ready")
        
            async def strategy_1_direct(self, bot):
                try:
                    await self.client.send_message(bot, '/start')
                    await asyncio.sleep(2)
                    msgs = await self.client.get_messages(bot, limit=5)
                    for m in msgs:
                        if m.text: self.extract(m.text, bot, "direct")
                    return True
                except: return False
        
            async def strategy_2_buttons(self, bot):
                try:
                    msgs = await self.client.get_messages(bot, limit=10)
                    for m in msgs:
                        if m.reply_markup:
                            for row in m.reply_markup.rows:
                                for btn in row.buttons:
                                    if isinstance(btn, KeyboardButtonCallback):
                                        try:
                                            await self.client(GetBotCallbackAnswerRequest(peer=bot, msg_id=m.id, data=btn.data))
                                            await asyncio.sleep(1)
                                            new = await self.client.get_messages(bot, limit=3)
                                            for n in new:
                                                if n.text: self.extract(n.text, bot, "button")
                                        except: pass
                    return True
                except: return False
        
            async def strategy_3_menu(self, bot):
                try:
                    cmds = ['/free', '/test', '/trial', 'Free', 'Test']
                    for c in cmds:
                        await self.client.send_message(bot, c)
                        await asyncio.sleep(1)
                        msgs = await self.client.get_messages(bot, limit=3)
                        for m in msgs:
                            if m.text: self.extract(m.text, bot, "menu")
                    return True
                except: return False
        
            async def strategy_4_history(self, bot):
                try:
                    msgs = await self.client.get_messages(bot, limit=100)
                    for m in msgs:
                        if m.text: self.extract(m.text, bot, "history")
                    return True
                except: return False
        
            async def strategy_5_urls(self, bot):
                try:
                    msgs = await self.client.get_messages(bot, limit=20)
                    for m in msgs:
                        if m.reply_markup:
                            for row in m.reply_markup.rows:
                                for btn in row.buttons:
                                    if isinstance(btn, KeyboardButtonUrl):
                                        self.configs['telegram'].append({'config': btn.url, 'source': bot, 'method': 'url'})
                    return True
                except: return False
        
            def extract(self, text, source, method):
                for typ, pat in CONFIG_PATTERNS.items():
                    for m in pat.findall(text):
                        data = {'config': m, 'type': typ, 'source': source, 'method': method, 'time': datetime.now().isoformat()}
                        if typ in ['tg_proxy']:
                            if data not in self.configs['telegram']: 
                                self.configs['telegram'].append(data)
                                logger.info(f"‚úÖ TG: {m[:50]}...")
                        else:
                            if data not in self.configs['vpn']: 
                                self.configs['vpn'].append(data)
                                logger.info(f"‚úÖ VPN: {m[:50]}...")
                        self.configs['raw'].append(data)
        
            async def attack(self, bot):
                logger.info(f"üéØ Attacking {bot}")
                strategies = [self.strategy_1_direct, self.strategy_2_buttons, self.strategy_3_menu, 
                             self.strategy_4_history, self.strategy_5_urls]
                for s in strategies:
                    try:
                        await s(bot)
                        await asyncio.sleep(random.uniform(1, 3))
                    except: pass
        
            async def run(self):
                await self.init_client()
                for bot in TARGET_BOTS:
                    try:
                        await self.attack(bot)
                        await asyncio.sleep(5)
                    except Exception as e:
                        logger.error(f"Failed {bot}: {e}")
                
                with open('output/telegram/from_bots.txt', 'w') as f:
                    for i in self.configs['telegram']: f.write(f"{i['config']}\n")
                with open('output/vpn/from_bots.json', 'w') as f:
                    json.dump(self.configs['vpn'], f, indent=2)
                
                await self.client.disconnect()
                logger.info(f"üéâ Done: {len(self.configs['telegram'])} TG, {len(self.configs['vpn'])} VPN")
        
        asyncio.run(BotInfiltrator().run())
        SCRIPT1
        
        # ==================== TELEGRAM MONITOR ====================
        cat > scripts/tg_monitor.py << 'SCRIPT2'
        #!/usr/bin/env python3
        import asyncio, json, re, logging
        from datetime import datetime
        from telethon import TelegramClient
        
        API_ID = 38922115
        API_HASH = "b34ae241317eff8743f538a8272c5f6d"
        
        CHANNELS = ["@proxy_mtm", "@free_proxy_vpn", "@vpn_free", "@v2raycollector", "@VmessProtocol",
                   "@DirectVPN", "@freev2rays", "@MTProxies", "@proxy_socks5", "@freeshadowsocks"]
        
        PATTERNS = {
            'vless': re.compile(r'vless://[^\s]+'),
            'vmess': re.compile(r'vmess://[^\s]+'),
            'ss': re.compile(r'ss://[^\s]+'),
            'tg_proxy': re.compile(r'tg://proxy\?[^\s]+'),
        }
        
        logging.basicConfig(level=logging.INFO)
        logger = logging.getLogger(__name__)
        
        class Monitor:
            def __init__(self):
                self.client = None
                self.configs = []
        
            async def init(self):
                self.client = TelegramClient("sessions/mon", API_ID, API_HASH)
                await self.client.start()
        
            async def scan(self, ch):
                logger.info(f"üì° Scanning {ch}")
                try:
                    entity = await self.client.get_entity(ch)
                    msgs = await self.client.get_messages(entity, limit=100)
                    for m in msgs:
                        if m.text:
                            for typ, pat in PATTERNS.items():
                                for match in pat.findall(m.text):
                                    data = {'config': match, 'type': typ, 'source': ch, 'time': datetime.now().isoformat()}
                                    if data not in self.configs:
                                        self.configs.append(data)
                                        logger.info(f"‚úÖ Found {typ}")
                except Exception as e:
                    logger.error(f"Error {ch}: {e}")
        
            async def run(self):
                await self.init()
                for ch in CHANNELS:
                    await self.scan(ch)
                    await asyncio.sleep(2)
                
                tg = [c for c in self.configs if c['type'] == 'tg_proxy']
                vpn = [c for c in self.configs if c['type'] in ['vless','vmess','ss']]
                
                with open('output/telegram/from_channels.txt', 'w') as f:
                    for i in tg: f.write(f"{i['config']}\n")
                with open('output/vpn/from_channels.json', 'w') as f:
                    json.dump(vpn, f, indent=2)
                
                await self.client.disconnect()
                logger.info(f"üéâ Done: {len(tg)} TG, {len(vpn)} VPN")
        
        asyncio.run(Monitor().run())
        SCRIPT2
        
        # ==================== WEB CRAWLER ====================
        cat > scripts/web_crawler.py << 'SCRIPT3'
        #!/usr/bin/env python3
        import asyncio, aiohttp, re, json, logging
        from datetime import datetime
        from bs4 import BeautifulSoup
        
        PATTERNS = {
            'vless': re.compile(r'vless://[^\s]+'),
            'vmess': re.compile(r'vmess://[^\s]+'),
            'ss': re.compile(r'ss://[^\s]+'),
            'tg_proxy': re.compile(r'tg://proxy\?[^\s]+'),
        }
        
        logging.basicConfig(level=logging.INFO)
        logger = logging.getLogger(__name__)
        
        class Crawler:
            def __init__(self):
                self.session = None
                self.configs = []
        
            async def init(self):
                self.session = aiohttp.ClientSession(headers={'User-Agent': 'Mozilla/5.0'})
        
            async def gists(self):
                logger.info("üîç GitHub Gists...")
                queries = ['vless config', 'vmess config', 'v2ray', 'proxy telegram']
                for q in queries:
                    try:
                        url = f"https://gist.github.com/search?q={q.replace(' ', '+')}"
                        async with self.session.get(url) as r:
                            html = await r.text()
                            soup = BeautifulSoup(html, 'html.parser')
                            links = soup.find_all('a', class_='Link--primary')
                            for link in links[:5]:
                                raw = f"https://gist.github.com{link['href']}/raw"
                                try:
                                    async with self.session.get(raw) as gr:
                                        content = await gr.text()
                                        self.extract(content, f"Gist:{q}")
                                except: pass
                        await asyncio.sleep(2)
                    except: pass
        
            async def pastebin(self):
                logger.info("üìã Pastebin...")
                try:
                    async with self.session.get("https://pastebin.com/archive") as r:
                        html = await r.text()
                        soup = BeautifulSoup(html, 'html.parser')
                        links = soup.find_all('a', href=re.compile(r'/[A-Za-z0-9]{8}'))
                        for link in links[:15]:
                            pid = link['href'].strip('/')
                            raw = f"https://pastebin.com/raw/{pid}"
                            try:
                                async with self.session.get(raw) as pr:
                                    content = await pr.text()
                                    if any(k in content.lower() for k in ['vless','vmess','proxy']):
                                        self.extract(content, f"Paste:{pid}")
                            except: pass
                            await asyncio.sleep(0.5)
                except: pass
        
            async def github_repos(self):
                logger.info("üéØ GitHub Repos...")
                urls = [
                    "https://raw.githubusercontent.com/awesome-vpn/awesome-vpn/master/all",
                    "https://raw.githubusercontent.com/freefq/free/master/v2"
                ]
                for url in urls:
                    try:
                        async with self.session.get(url) as r:
                            if r.status == 200:
                                content = await r.text()
                                self.extract(content, url)
                    except: pass
        
            def extract(self, text, source):
                for typ, pat in PATTERNS.items():
                    for m in pat.findall(text):
                        data = {'config': m, 'type': typ, 'source': source, 'time': datetime.now().isoformat()}
                        if data not in self.configs:
                            self.configs.append(data)
                            logger.info(f"‚úÖ {typ}")
        
            async def run(self):
                await self.init()
                await asyncio.gather(self.gists(), self.pastebin(), self.github_repos(), return_exceptions=True)
                
                tg = [c for c in self.configs if c['type'] == 'tg_proxy']
                vpn = [c for c in self.configs if c['type'] in ['vless','vmess','ss']]
                
                with open('output/telegram/from_web.txt', 'w') as f:
                    for i in tg: f.write(f"{i['config']}\n")
                with open('output/vpn/from_web.json', 'w') as f:
                    json.dump(vpn, f, indent=2)
                
                await self.session.close()
                logger.info(f"üéâ Done: {len(tg)} TG, {len(vpn)} VPN")
        
        asyncio.run(Crawler().run())
        SCRIPT3
        
        # ==================== CONFIG MERGER ====================
        cat > scripts/merge.py << 'SCRIPT4'
        #!/usr/bin/env python3
        import json, logging, base64
        from pathlib import Path
        
        logging.basicConfig(level=logging.INFO)
        logger = logging.getLogger(__name__)
        
        # Merge Telegram
        tg_set = set()
        for f in ['output/telegram/from_bots.txt', 'output/telegram/from_channels.txt', 'output/telegram/from_web.txt']:
            try:
                with open(f) as file:
                    for line in file:
                        line = line.strip()
                        if line: tg_set.add(line)
            except: pass
        
        with open('output/telegram/telegram_proxies.txt', 'w') as f:
            for cfg in sorted(tg_set): f.write(f"{cfg}\n")
        
        logger.info(f"‚úÖ Merged {len(tg_set)} Telegram proxies")
        
        # Merge VPN
        vpn_list = []
        seen = set()
        for f in ['output/vpn/from_bots.json', 'output/vpn/from_channels.json', 'output/vpn/from_web.json']:
            try:
                with open(f) as file:
                    data = json.load(file)
                    for item in data:
                        cfg = item.get('config', '')
                        if cfg and cfg not in seen:
                            seen.add(cfg)
                            vpn_list.append(item)
            except: pass
        
        with open('output/vpn/vpn_configs.json', 'w') as f:
            json.dump(vpn_list, f, indent=2)
        
        logger.info(f"‚úÖ Merged {len(vpn_list)} VPN configs")
        
        # All-in-one
        with open('output/raw/all_in_one.txt', 'w') as f:
            f.write("# ===== TELEGRAM PROXIES =====\n")
            for cfg in sorted(tg_set): f.write(f"{cfg}\n")
            f.write("\n# ===== VPN CONFIGS =====\n")
            for item in vpn_list: f.write(f"{item['config']}\n")
        
        # Subscription
        all_vpn = '\n'.join([i['config'] for i in vpn_list])
        sub = base64.b64encode(all_vpn.encode()).decode()
        with open('output/raw/subscription.txt', 'w') as f:
            f.write(sub)
        
        logger.info("üì¶ Created all-in-one and subscription")
        SCRIPT4
        
        # ==================== WEBSITE GENERATOR ====================
        cat > scripts/website.py << 'SCRIPT5'
        #!/usr/bin/env python3
        from datetime import datetime
        
        html = f"""<!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <meta name="viewport" content="width=device-width, initial-scale=1.0">
            <title>üßä ICEBREAKER - Free Proxy & VPN</title>
            <style>
                * {{ margin: 0; padding: 0; box-sizing: border-box; }}
                body {{
                    font-family: 'Segoe UI', sans-serif;
                    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                    color: #fff;
                    min-height: 100vh;
                    padding: 20px;
                }}
                .container {{ max-width: 1200px; margin: 0 auto; }}
                header {{
                    text-align: center;
                    padding: 40px 0;
                    border-bottom: 2px solid rgba(255,255,255,0.2);
                }}
                h1 {{
                    font-size: 3.5em;
                    margin-bottom: 10px;
                    text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
                }}
                .tagline {{
                    font-size: 1.3em;
                    opacity: 0.9;
                }}
                .section {{
                    background: rgba(255,255,255,0.1);
                    backdrop-filter: blur(10px);
                    border-radius: 20px;
                    padding: 40px;
                    margin: 30px 0;
                    border: 1px solid rgba(255,255,255,0.2);
                }}
                h2 {{
                    font-size: 2em;
                    margin-bottom: 20px;
                    color: #ffd700;
                }}
                .download-grid {{
                    display: grid;
                    grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
                    gap: 20px;
                }}
                .download-card {{
                    background: rgba(255,255,255,0.1);
                    padding: 25px;
                    border-radius: 15px;
                    border: 2px solid rgba(255,255,255,0.2);
                    transition: all 0.3s;
                }}
                .download-card:hover {{
                    transform: translateY(-5px);
                    border-color: #ffd700;
                    box-shadow: 0 10px 30px rgba(0,0,0,0.3);
                }}
                .download-card h3 {{
                    color: #ffd700;
                    margin-bottom: 15px;
                }}
                .btn {{
                    display: inline-block;
                    background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
                    color: white;
                    padding: 12px 30px;
                    border-radius: 25px;
                    text-decoration: none;
                    margin: 10px 5px;
                    transition: all 0.3s;
                    border: 2px solid rgba(255,255,255,0.3);
                    font-weight: bold;
                }}
                .btn:hover {{
                    transform: scale(1.05);
                    box-shadow: 0 5px 20px rgba(0,0,0,0.3);
                }}
                .guide {{
                    background: rgba(0,0,0,0.2);
                    padding: 25px;
                    border-radius: 15px;
                    margin: 20px 0;
                    border-left: 4px solid #ffd700;
                }}
                .guide h3 {{ color: #ffd700; margin-bottom: 15px; }}
                .guide ol {{ margin-left: 20px; line-height: 1.8; }}
                footer {{
                    text-align: center;
                    padding: 40px 0;
                    border-top: 2px solid rgba(255,255,255,0.2);
                    margin-top: 40px;
                }}
            </style>
        </head>
        <body>
            <div class="container">
                <header>
                    <h1>üßä ICEBREAKER</h1>
                    <p class="tagline">Your Ultimate Free Proxy & VPN Aggregator</p>
                    <p>Auto-updated every hour | Always fresh configs</p>
                    <p style="margin-top: 10px;">Last update: {datetime.now().strftime('%Y-%m-%d %H:%M UTC')}</p>
                </header>
                
                <div class="section">
                    <h2>üì¶ Download Configs</h2>
                    <div class="download-grid">
                        <div class="download-card">
                            <h3>üì± Telegram Proxies</h3>
                            <p>MTProto & SOCKS5 for Telegram</p>
                            <a href="../releases/latest/download/telegram_proxies.txt" class="btn">Download</a>
                        </div>
                        <div class="download-card">
                            <h3>üöÄ VPN Configs</h3>
                            <p>VLESS, VMess, Shadowsocks, Trojan</p>
                            <a href="../releases/latest/download/vpn_configs.json" class="btn">Download</a>
                        </div>
                        <div class="download-card">
                            <h3>üìã All-in-One</h3>
                            <p>All configs in one file</p>
                            <a href="../releases/latest/download/all_in_one.txt" class="btn">Download</a>
                        </div>
                        <div class="download-card">
                            <h3>üîÑ Subscription</h3>
                            <p>Auto-update link</p>
                            <a href="../releases/latest/download/subscription.txt" class="btn">Get Link</a>
                        </div>
                    </div>
                </div>
                
                <div class="section">
                    <h2>üéì Quick Start Guide</h2>
                    <div class="guide">
                        <h3>For Telegram:</h3>
                        <ol>
                            <li>Download telegram_proxies.txt</li>
                            <li>Open Telegram ‚Üí Settings ‚Üí Data and Storage ‚Üí Proxy</li>
                            <li>Add Proxy and paste any line from file</li>
                            <li>Enable and enjoy!</li>
                        </ol>
                    </div>
                    <div class="guide">
                        <h3>For VPN (Android):</h3>
                        <ol>
                            <li>Install Nekobox or v2rayNG</li>
                            <li>Download vpn_configs.json</li>
                            <li>Import file in app</li>
                            <li>Connect!</li>
                        </ol>
                    </div>
                </div>
                
                <footer>
                    <p>üßä <strong>ICEBREAKER</strong> - Autonomous Proxy Aggregator</p>
                    <p>Built with ‚ù§Ô∏è using GitHub Actions</p>
                </footer>
            </div>
        </body>
        </html>"""
        
        with open('site/index.html', 'w') as f:
            f.write(html)
        
        print("‚úÖ Website generated!")
        SCRIPT5
        
        chmod +x scripts/*.py

    - name: ü§ñ Bot Infiltration
      timeout-minutes: 20
      run: python scripts/bot_infiltrator.py
      continue-on-error: true

    - name: üì° Telegram Monitoring
      timeout-minutes: 15
      run: python scripts/tg_monitor.py
      continue-on-error: true

    - name: üï∏Ô∏è Web Crawling
      timeout-minutes: 15
      run: python scripts/web_crawler.py
      continue-on-error: true

    - name: üîÑ Merge Configs
      run: python scripts/merge.py

    - name: üåê Generate Website
      run: python scripts/website.py

    - name: üìä Count Results
      id: stats
      run: |
        TG_COUNT=$(wc -l < output/telegram/telegram_proxies.txt 2>/dev/null || echo 0)
        VPN_COUNT=$(cat output/vpn/vpn_configs.json 2>/dev/null | grep -c '"config"' || echo 0)
        echo "tg_count=$TG_COUNT" >> $GITHUB_OUTPUT
        echo "vpn_count=$VPN_COUNT" >> $GITHUB_OUTPUT
        echo "timestamp=$(date '+%Y-%m-%d %H:%M UTC')" >> $GITHUB_OUTPUT

    - name: üìù Create Release
      id: release
      run: |
        TAG="update-$(date '+%Y%m%d-%H%M')"
        echo "tag=$TAG" >> $GITHUB_OUTPUT
        
        cat > notes.md << EOF
        # üßä ICEBREAKER Auto-Update
        
        **Timestamp:** $(date '+%Y-%m-%d %H:%M UTC')
        
        ## üìä Statistics
        - Telegram Proxies: ${{ steps.stats.outputs.tg_count }}
        - VPN Configs: ${{ steps.stats.outputs.vpn_count }}
        
        ## üì¶ Files
        - \`telegram_proxies.txt\` - MTProto/SOCKS5 proxies
        - \`vpn_configs.json\` - VPN configurations
        - \`all_in_one.txt\` - All configs
        - \`subscription.txt\` - Subscription link
        
        ## üì± Apps
        **Android:** [Nekobox](https://github.com/MatsuriDayo/NekoBoxForAndroid/releases), [v2rayNG](https://github.com/2dust/v2rayNG/releases)
        **iOS:** [Streisand](https://apps.apple.com/app/streisand/id6450534064), [V2BOX](https://apps.apple.com/app/v2box-v2ray-client/id6446814690)
        
        ---
        *Auto-generated by ICEBREAKER*
        EOF

    - name: üéÅ Publish Release
      uses: softprops/action-gh-release@v1
      with:
        tag_name: ${{ steps.release.outputs.tag }}
        name: "Update ${{ steps.stats.outputs.timestamp }}"
        body_path: notes.md
        files: |
          output/telegram/telegram_proxies.txt
          output/vpn/vpn_configs.json
          output/raw/all_in_one.txt
          output/raw/subscription.txt
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

    - name: üåê Deploy Website
      uses: peaceiris/actions-gh-pages@v3
      with:
        github_token: ${{ secrets.GITHUB_TOKEN }}
        publish_dir: ./site
        user_name: 'ICEBREAKER Bot'
        user_email: 'bot@icebreaker.auto'

    - name: ‚úÖ Complete
      run: |
        echo "üéâ ICEBREAKER completed successfully!"
        echo "üìä Telegram: ${{ steps.stats.outputs.tg_count }}"
        echo "üìä VPN: ${{ steps.vpn_count.outputs.vpn_count }}"
        echo "üåê Website: Updated"
        echo "üì¶ Release: Created"
        cat > scripts/bot_infiltrator.py << 'SCRIPT1'
        #!/usr/bin/env python3
        import asyncio, random, json, re, logging
        from datetime import datetime
        from telethon import TelegramClient, events
        from telethon.tl.functions.messages import GetBotCallbackAnswerRequest
        from telethon.tl.types import KeyboardButtonCallback, KeyboardButtonUrl
        
        API_ID = 38922115
        API_HASH = "b34ae241317eff8743f538a8272c5f6d"
        
        TARGET_BOTS = ["@MTProtoProxybot", "@ProxyMTProtoBot", "@socks5_bot", "@vmess_vless_bot", 
                       "@FreeVPNbot", "@v2ray_config_bot", "@shadowsocks_bot", "@proxytelegrambot",
                       "@vpnconfig_bot", "@proxy_seller_bot"]
        
        CONFIG_PATTERNS = {
            'tg_proxy': re.compile(r'(tg://proxy\?[^\s]+)'),
            'vless': re.compile(r'(vless://[^\s]+)'),
            'vmess': re.compile(r'(vmess://[^\s]+)'),
            'ss': re.compile(r'(ss://[^\s]+)'),
            'trojan': re.compile(r'(trojan://[^\s]+)'),
        }
        
        logging.basicConfig(level=logging.INFO)
        logger = logging.getLogger(__name__)
        
        class BotInfiltrator:
            def __init__(self):
                self.client = None
                self.configs = {'telegram': [], 'vpn': [], 'raw': []}
        
            async def init_client(self):
                self.client = TelegramClient("sessions/ice", API_ID, API_HASH)
                await self.client.start()
                logger.info("‚úÖ Client ready")
        
            async def strategy_1_direct(self, bot):
                try:
                    await self.client.send_message(bot, '/start')
                    await asyncio.sleep(2)
                    msgs = await self.client.get_messages(bot, limit=5)
                    for m in msgs:
                        if m.text: self.extract(m.text, bot, "direct")
                    return True
                except: return False
        
            async def strategy_2_buttons(self, bot):
                try:
                    msgs = await self.client.get_messages(bot, limit=10)
                    for m in msgs:
                        if m.reply_markup:
                            for row in m.reply_markup.rows:
                                for btn in row.buttons:
                                    if isinstance(btn, KeyboardButtonCallback):
                                        try:
                                            await self.client(GetBotCallbackAnswerRequest(peer=bot, msg_id=m.id, data=btn.data))
                                            await asyncio.sleep(1)
                                            new = await self.client.get_messages(bot, limit=3)
                                            for n in new:
                                                if n.text: self.extract(n.text, bot, "button")
                                        except: pass
                    return True
                except: return False
        
            async def strategy_3_menu(self, bot):
                try:
                    cmds = ['/free', '/test', '/trial', 'Free', 'Test']
                    for c in cmds:
                        await self.client.send_message(bot, c)
                        await asyncio.sleep(1)
                        msgs = await self.client.get_messages(bot, limit=3)
                        for m in msgs:
                            if m.text: self.extract(m.text, bot, "menu")
                    return True
                except: return False
        
            async def strategy_4_history(self, bot):
                try:
                    msgs = await self.client.get_messages(bot, limit=100)
                    for m in msgs:
                        if m.text: self.extract(m.text, bot, "history")
                    return True
                except: return False
        
            async def strategy_5_urls(self, bot):
                try:
                    msgs = await self.client.get_messages(bot, limit=20)
                    for m in msgs:
                        if m.reply_markup:
                            for row in m.reply_markup.rows:
                                for btn in row.buttons:
                                    if isinstance(btn, KeyboardButtonUrl):
                                        self.configs['telegram'].append({'config': btn.url, 'source': bot, 'method': 'url'})
                    return True
                except: return False
        
            def extract(self, text, source, method):
                for typ, pat in CONFIG_PATTERNS.items():
                    for m in pat.findall(text):
                        data = {'config': m, 'type': typ, 'source': source, 'method': method, 'time': datetime.now().isoformat()}
                        if typ in ['tg_proxy']:
                            if data not in self.configs['telegram']: 
                                self.configs['telegram'].append(data)
                                logger.info(f"‚úÖ TG: {m[:50]}...")
                        else:
                            if data not in self.configs['vpn']: 
                                self.configs['vpn'].append(data)
                                logger.info(f"‚úÖ VPN: {m[:50]}...")
                        self.configs['raw'].append(data)
        
            async def attack(self, bot):
                logger.info(f"üéØ Attacking {bot}")
                strategies = [self.strategy_1_direct, self.strategy_2_buttons, self.strategy_3_menu, 
                             self.strategy_4_history, self.strategy_5_urls]
                for s in strategies:
                    try:
                        await s(bot)
                        await asyncio.sleep(random.uniform(1, 3))
                    except: pass
        
            async def run(self):
                await self.init_client()
                for bot in TARGET_BOTS:
                    try:
                        await self.attack(bot)
                        await asyncio.sleep(5)
                    except Exception as e:
                        logger.error(f"Failed {bot}: {e}")
                
                with open('output/telegram/from_bots.txt', 'w') as f:
                    for i in self.configs['telegram']: f.write(f"{i['config']}\n")
                with open('output/vpn/from_bots.json', 'w') as f:
                    json.dump(self.configs['vpn'], f, indent=2)
                
                await self.client.disconnect()
                logger.info(f"üéâ Done: {len(self.configs['telegram'])} TG, {len(self.configs['vpn'])} VPN")
        
        asyncio.run(BotInfiltrator().run())
        SCRIPT1
        
        # ==================== TELEGRAM MONITOR ====================
        cat > scripts/tg_monitor.py << 'SCRIPT2'
        #!/usr/bin/env python3
        import asyncio, json, re, logging
        from datetime import datetime
        from telethon import TelegramClient
        
        API_ID = 38922115
        API_HASH = "b34ae241317eff8743f538a8272c5f6d"
        
        CHANNELS = ["@proxy_mtm", "@free_proxy_vpn", "@vpn_free", "@v2raycollector", "@VmessProtocol",
                   "@DirectVPN", "@freev2rays", "@MTProxies", "@proxy_socks5", "@freeshadowsocks"]
        
        PATTERNS = {
            'vless': re.compile(r'vless://[^\s]+'),
            'vmess': re.compile(r'vmess://[^\s]+'),
            'ss': re.compile(r'ss://[^\s]+'),
            'tg_proxy': re.compile(r'tg://proxy\?[^\s]+'),
        }
        
        logging.basicConfig(level=logging.INFO)
        logger = logging.getLogger(__name__)
        
        class Monitor:
            def __init__(self):
                self.client = None
                self.configs = []
        
            async def init(self):
                self.client = TelegramClient("sessions/mon", API_ID, API_HASH)
                await self.client.start()
        
            async def scan(self, ch):
                logger.info(f"üì° Scanning {ch}")
                try:
                    entity = await self.client.get_entity(ch)
                    msgs = await self.client.get_messages(entity, limit=100)
                    for m in msgs:
                        if m.text:
                            for typ, pat in PATTERNS.items():
                                for match in pat.findall(m.text):
                                    data = {'config': match, 'type': typ, 'source': ch, 'time': datetime.now().isoformat()}
                                    if data not in self.configs:
                                        self.configs.append(data)
                                        logger.info(f"‚úÖ Found {typ}")
                except Exception as e:
                    logger.error(f"Error {ch}: {e}")
        
            async def run(self):
                await self.init()
                for ch in CHANNELS:
                    await self.scan(ch)
                    await asyncio.sleep(2)
                
                tg = [c for c in self.configs if c['type'] == 'tg_proxy']
                vpn = [c for c in self.configs if c['type'] in ['vless','vmess','ss']]
                
                with open('output/telegram/from_channels.txt', 'w') as f:
                    for i in tg: f.write(f"{i['config']}\n")
                with open('output/vpn/from_channels.json', 'w') as f:
                    json.dump(vpn, f, indent=2)
                
                await self.client.disconnect()
                logger.info(f"üéâ Done: {len(tg)} TG, {len(vpn)} VPN")
        
        asyncio.run(Monitor().run())
        SCRIPT2
        
        # ==================== WEB CRAWLER ====================
        cat > scripts/web_crawler.py << 'SCRIPT3'
        #!/usr/bin/env python3
        import asyncio, aiohttp, re, json, logging
        from datetime import datetime
        from bs4 import BeautifulSoup
        
        PATTERNS = {
            'vless': re.compile(r'vless://[^\s]+'),
            'vmess': re.compile(r'vmess://[^\s]+'),
            'ss': re.compile(r'ss://[^\s]+'),
            'tg_proxy': re.compile(r'tg://proxy\?[^\s]+'),
        }
        
        logging.basicConfig(level=logging.INFO)
        logger = logging.getLogger(__name__)
        
        class Crawler:
            def __init__(self):
                self.session = None
                self.configs = []
        
            async def init(self):
                self.session = aiohttp.ClientSession(headers={'User-Agent': 'Mozilla/5.0'})
        
            async def gists(self):
                logger.info("üîç GitHub Gists...")
                queries = ['vless config', 'vmess config', 'v2ray', 'proxy telegram']
                for q in queries:
                    try:
                        url = f"https://gist.github.com/search?q={q.replace(' ', '+')}"
                        async with self.session.get(url) as r:
                            html = await r.text()
                            soup = BeautifulSoup(html, 'html.parser')
                            links = soup.find_all('a', class_='Link--primary')
                            for link in links[:5]:
                                raw = f"https://gist.github.com{link['href']}/raw"
                                try:
                                    async with self.session.get(raw) as gr:
                                        content = await gr.text()
                                        self.extract(content, f"Gist:{q}")
                                except: pass
                        await asyncio.sleep(2)
                    except: pass
        
            async def pastebin(self):
                logger.info("üìã Pastebin...")
                try:
                    async with self.session.get("https://pastebin.com/archive") as r:
                        html = await r.text()
                        soup = BeautifulSoup(html, 'html.parser')
                        links = soup.find_all('a', href=re.compile(r'/[A-Za-z0-9]{8}'))
                        for link in links[:15]:
                            pid = link['href'].strip('/')
                            raw = f"https://pastebin.com/raw/{pid}"
                            try:
                                async with self.session.get(raw) as pr:
                                    content = await pr.text()
                                    if any(k in content.lower() for k in ['vless','vmess','proxy']):
                                        self.extract(content, f"Paste:{pid}")
                            except: pass
                            await asyncio.sleep(0.5)
                except: pass
        
            async def github_repos(self):
                logger.info("üéØ GitHub Repos...")
                urls = [
                    "https://raw.githubusercontent.com/awesome-vpn/awesome-vpn/master/all",
                    "https://raw.githubusercontent.com/freefq/free/master/v2"
                ]
                for url in urls:
                    try:
                        async with self.session.get(url) as r:
                            if r.status == 200:
                                content = await r.text()
                                self.extract(content, url)
                    except: pass
        
            def extract(self, text, source):
                for typ, pat in PATTERNS.items():
                    for m in pat.findall(text):
                        data = {'config': m, 'type': typ, 'source': source, 'time': datetime.now().isoformat()}
                        if data not in self.configs:
                            self.configs.append(data)
                            logger.info(f"‚úÖ {typ}")
        
            async def run(self):
                await self.init()
                await asyncio.gather(self.gists(), self.pastebin(), self.github_repos(), return_exceptions=True)
                
                tg = [c for c in self.configs if c['type'] == 'tg_proxy']
                vpn = [c for c in self.configs if c['type'] in ['vless','vmess','ss']]
                
                with open('output/telegram/from_web.txt', 'w') as f:
                    for i in tg: f.write(f"{i['config']}\n")
                with open('output/vpn/from_web.json', 'w') as f:
                    json.dump(vpn, f, indent=2)
                
                await self.session.close()
                logger.info(f"üéâ Done: {len(tg)} TG, {len(vpn)} VPN")
        
        asyncio.run(Crawler().run())
        SCRIPT3
        
        # ==================== CONFIG MERGER ====================
        cat > scripts/merge.py << 'SCRIPT4'
        #!/usr/bin/env python3
        import json, logging, base64
        from pathlib import Path
        
        logging.basicConfig(level=logging.INFO)
        logger = logging.getLogger(__name__)
        
        # Merge Telegram
        tg_set = set()
        for f in ['output/telegram/from_bots.txt', 'output/telegram/from_channels.txt', 'output/telegram/from_web.txt']:
            try:
                with open(f) as file:
                    for line in file:
                        line = line.strip()
                        if line: tg_set.add(line)
            except: pass
        
        with open('output/telegram/telegram_proxies.txt', 'w') as f:
            for cfg in sorted(tg_set): f.write(f"{cfg}\n")
        
        logger.info(f"‚úÖ Merged {len(tg_set)} Telegram proxies")
        
        # Merge VPN
        vpn_list = []
        seen = set()
        for f in ['output/vpn/from_bots.json', 'output/vpn/from_channels.json', 'output/vpn/from_web.json']:
            try:
                with open(f) as file:
                    data = json.load(file)
                    for item in data:
                        cfg = item.get('config', '')
                        if cfg and cfg not in seen:
                            seen.add(cfg)
                            vpn_list.append(item)
            except: pass
        
        with open('output/vpn/vpn_configs.json', 'w') as f:
            json.dump(vpn_list, f, indent=2)
        
        logger.info(f"‚úÖ Merged {len(vpn_list)} VPN configs")
        
        # All-in-one
        with open('output/raw/all_in_one.txt', 'w') as f:
            f.write("# ===== TELEGRAM PROXIES =====\n")
            for cfg in sorted(tg_set): f.write(f"{cfg}\n")
            f.write("\n# ===== VPN CONFIGS =====\n")
            for item in vpn_list: f.write(f"{item['config']}\n")
        
        # Subscription
        all_vpn = '\n'.join([i['config'] for i in vpn_list])
        sub = base64.b64encode(all_vpn.encode()).decode()
        with open('output/raw/subscription.txt', 'w') as f:
            f.write(sub)
        
        logger.info("üì¶ Created all-in-one and subscription")
        SCRIPT4
        
        # ==================== WEBSITE GENERATOR ====================
        cat > scripts/website.py << 'SCRIPT5'
        #!/usr/bin/env python3
        from datetime import datetime
        
        html = f"""<!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <meta name="viewport" content="width=device-width, initial-scale=1.0">
            <title>üßä ICEBREAKER - Free Proxy & VPN</title>
            <style>
                * {{ margin: 0; padding: 0; box-sizing: border-box; }}
                body {{
                    font-family: 'Segoe UI', sans-serif;
                    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                    color: #fff;
                    min-height: 100vh;
                    padding: 20px;
                }}
                .container {{ max-width: 1200px; margin: 0 auto; }}
                header {{
                    text-align: center;
                    padding: 40px 0;
                    border-bottom: 2px solid rgba(255,255,255,0.2);
                }}
                h1 {{
                    font-size: 3.5em;
                    margin-bottom: 10px;
                    text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
                }}
                .tagline {{
                    font-size: 1.3em;
                    opacity: 0.9;
                }}
                .section {{
                    background: rgba(255,255,255,0.1);
                    backdrop-filter: blur(10px);
                    border-radius: 20px;
                    padding: 40px;
                    margin: 30px 0;
                    border: 1px solid rgba(255,255,255,0.2);
                }}
                h2 {{
                    font-size: 2em;
                    margin-bottom: 20px;
                    color: #ffd700;
                }}
                .download-grid {{
                    display: grid;
                    grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
                    gap: 20px;
                }}
                .download-card {{
                    background: rgba(255,255,255,0.1);
                    padding: 25px;
                    border-radius: 15px;
                    border: 2px solid rgba(255,255,255,0.2);
                    transition: all 0.3s;
                }}
                .download-card:hover {{
                    transform: translateY(-5px);
                    border-color: #ffd700;
                    box-shadow: 0 10px 30px rgba(0,0,0,0.3);
                }}
                .download-card h3 {{
                    color: #ffd700;
                    margin-bottom: 15px;
                }}
                .btn {{
                    display: inline-block;
                    background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
                    color: white;
                    padding: 12px 30px;
                    border-radius: 25px;
                    text-decoration: none;
                    margin: 10px 5px;
                    transition: all 0.3s;
                    border: 2px solid rgba(255,255,255,0.3);
                    font-weight: bold;
                }}
                .btn:hover {{
                    transform: scale(1.05);
                    box-shadow: 0 5px 20px rgba(0,0,0,0.3);
                }}
                .guide {{
                    background: rgba(0,0,0,0.2);
                    padding: 25px;
                    border-radius: 15px;
                    margin: 20px 0;
                    border-left: 4px solid #ffd700;
                }}
                .guide h3 {{ color: #ffd700; margin-bottom: 15px; }}
                .guide ol {{ margin-left: 20px; line-height: 1.8; }}
                footer {{
                    text-align: center;
                    padding: 40px 0;
                    border-top: 2px solid rgba(255,255,255,0.2);
                    margin-top: 40px;
                }}
            </style>
        </head>
        <body>
            <div class="container">
                <header>
                    <h1>üßä ICEBREAKER</h1>
                    <p class="tagline">Your Ultimate Free Proxy & VPN Aggregator</p>
                    <p>Auto-updated every hour | Always fresh configs</p>
                    <p style="margin-top: 10px;">Last update: {datetime.now().strftime('%Y-%m-%d %H:%M UTC')}</p>
                </header>
                
                <div class="section">
                    <h2>üì¶ Download Configs</h2>
                    <div class="download-grid">
                        <div class="download-card">
                            <h3>üì± Telegram Proxies</h3>
                            <p>MTProto & SOCKS5 for Telegram</p>
                            <a href="../releases/latest/download/telegram_proxies.txt" class="btn">Download</a>
                        </div>
                        <div class="download-card">
                            <h3>üöÄ VPN Configs</h3>
                            <p>VLESS, VMess, Shadowsocks, Trojan</p>
                            <a href="../releases/latest/download/vpn_configs.json" class="btn">Download</a>
                        </div>
                        <div class="download-card">
                            <h3>üìã All-in-One</h3>
                            <p>All configs in one file</p>
                            <a href="../releases/latest/download/all_in_one.txt" class="btn">Download</a>
                        </div>
                        <div class="download-card">
                            <h3>üîÑ Subscription</h3>
                            <p>Auto-update link</p>
                            <a href="../releases/latest/download/subscription.txt" class="btn">Get Link</a>
                        </div>
                    </div>
                </div>
                
                <div class="section">
                    <h2>üéì Quick Start Guide</h2>
                    <div class="guide">
                        <h3>For Telegram:</h3>
                        <ol>
                            <li>Download telegram_proxies.txt</li>
                            <li>Open Telegram ‚Üí Settings ‚Üí Data and Storage ‚Üí Proxy</li>
                            <li>Add Proxy and paste any line from file</li>
                            <li>Enable and enjoy!</li>
                        </ol>
                    </div>
                    <div class="guide">
                        <h3>For VPN (Android):</h3>
                        <ol>
                            <li>Install Nekobox or v2rayNG</li>
                            <li>Download vpn_configs.json</li>
                            <li>Import file in app</li>
                            <li>Connect!</li>
                        </ol>
                    </div>
                </div>
                
                <footer>
                    <p>üßä <strong>ICEBREAKER</strong> - Autonomous Proxy Aggregator</p>
                    <p>Built with ‚ù§Ô∏è using GitHub Actions</p>
                </footer>
            </div>
        </body>
        </html>"""
        
        with open('site/index.html', 'w') as f:
            f.write(html)
        
        print("‚úÖ Website generated!")
        SCRIPT5
        
        chmod +x scripts/*.py

    - name: ü§ñ Bot Infiltration
      timeout-minutes: 20
      run: python scripts/bot_infiltrator.py
      continue-on-error: true

    - name: üì° Telegram Monitoring
      timeout-minutes: 15
      run: python scripts/tg_monitor.py
      continue-on-error: true

    - name: üï∏Ô∏è Web Crawling
      timeout-minutes: 15
      run: python scripts/web_crawler.py
      continue-on-error: true

    - name: üîÑ Merge Configs
      run: python scripts/merge.py

    - name: üåê Generate Website
      run: python scripts/website.py

    - name: üìä Count Results
      id: stats
      run: |
        TG_COUNT=$(wc -l < output/telegram/telegram_proxies.txt 2>/dev/null || echo 0)
        VPN_COUNT=$(cat output/vpn/vpn_configs.json 2>/dev/null | grep -c '"config"' || echo 0)
        echo "tg_count=$TG_COUNT" >> $GITHUB_OUTPUT
        echo "vpn_count=$VPN_COUNT" >> $GITHUB_OUTPUT
        echo "timestamp=$(date '+%Y-%m-%d %H:%M UTC')" >> $GITHUB_OUTPUT

    - name: üìù Create Release
      id: release
      env:
        TG_COUNT: ${{ steps.stats.outputs.tg_count }}
        VPN_COUNT: ${{ steps.stats.outputs.vpn_count }}
      run: |
        TAG="update-$(date '+%Y%m%d-%H%M')"
        echo "tag=$TAG" >> $GITHUB_OUTPUT
        
        cat > notes.md << 'EOF'
        # üßä ICEBREAKER Auto-Update
        
        **Timestamp:** TIMESTAMP_PLACEHOLDER
        
        ## üìä Statistics
        - Telegram Proxies: TG_COUNT_PLACEHOLDER
        - VPN Configs: VPN_COUNT_PLACEHOLDER
        
        ## üì¶ Files
        - `telegram_proxies.txt` - MTProto/SOCKS5 proxies
        - `vpn_configs.json` - VPN configurations
        - `all_in_one.txt` - All configs
        - `subscription.txt` - Subscription link
        
        ## üì± Apps
        **Android:** [Nekobox](https://github.com/MatsuriDayo/NekoBoxForAndroid/releases), [v2rayNG](https://github.com/2dust/v2rayNG/releases)
        **iOS:** [Streisand](https://apps.apple.com/app/streisand/id6450534064), [V2BOX](https://apps.apple.com/app/v2box-v2ray-client/id6446814690)
        
        ---
        *Auto-generated by ICEBREAKER*
        EOF
        
        sed -i "s/TIMESTAMP_PLACEHOLDER/$(date '+%Y-%m-%d %H:%M UTC')/g" notes.md
        sed -i "s/TG_COUNT_PLACEHOLDER/$TG_COUNT/g" notes.md
        sed -i "s/VPN_COUNT_PLACEHOLDER/$VPN_COUNT/g" notes.md

    - name: üéÅ Publish Release
      uses: softprops/action-gh-release@v1
      with:
        tag_name: ${{ steps.release.outputs.tag }}
        name: "Update ${{ steps.stats.outputs.timestamp }}"
        body_path: notes.md
        files: |
          output/telegram/telegram_proxies.txt
          output/vpn/vpn_configs.json
          output/raw/all_in_one.txt
          output/raw/subscription.txt
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

    - name: üåê Deploy Website
      uses: peaceiris/actions-gh-pages@v3
      with:
        github_token: ${{ secrets.GITHUB_TOKEN }}
        publish_dir: ./site
        user_name: 'ICEBREAKER Bot'
        user_email: 'bot@icebreaker.auto'

    - name: ‚úÖ Complete
      run: |
        echo "üéâ ICEBREAKER completed successfully!"
        echo "üìä Telegram: ${{ steps.stats.outputs.tg_count }}"
        echo "üìä VPN: ${{ steps.stats.outputs.vpn_count }}"
        echo "üåê Website: Updated"
        echo "üì¶ Release: Created"        cat > scripts/bot_infiltrator.py << 'SCRIPT1'
        #!/usr/bin/env python3
        import asyncio, random, json, re, logging
        from datetime import datetime
        from telethon import TelegramClient, events
        from telethon.tl.functions.messages import GetBotCallbackAnswerRequest
        from telethon.tl.types import KeyboardButtonCallback, KeyboardButtonUrl
        
        API_ID = 38922115
        API_HASH = "b34ae241317eff8743f538a8272c5f6d"
        
        TARGET_BOTS = ["@MTProtoProxybot", "@ProxyMTProtoBot", "@socks5_bot", "@vmess_vless_bot", 
                       "@FreeVPNbot", "@v2ray_config_bot", "@shadowsocks_bot", "@proxytelegrambot",
                       "@vpnconfig_bot", "@proxy_seller_bot"]
        
        CONFIG_PATTERNS = {
            'tg_proxy': re.compile(r'(tg://proxy\?[^\s]+)'),
            'vless': re.compile(r'(vless://[^\s]+)'),
            'vmess': re.compile(r'(vmess://[^\s]+)'),
            'ss': re.compile(r'(ss://[^\s]+)'),
            'trojan': re.compile(r'(trojan://[^\s]+)'),
        }
        
        logging.basicConfig(level=logging.INFO)
        logger = logging.getLogger(__name__)
        
        class BotInfiltrator:
            def __init__(self):
                self.client = None
                self.configs = {'telegram': [], 'vpn': [], 'raw': []}
        
            async def init_client(self):
                self.client = TelegramClient("sessions/ice", API_ID, API_HASH)
                await self.client.start()
                logger.info("‚úÖ Client ready")
        
            async def strategy_1_direct(self, bot):
                try:
                    await self.client.send_message(bot, '/start')
                    await asyncio.sleep(2)
                    msgs = await self.client.get_messages(bot, limit=5)
                    for m in msgs:
                        if m.text: self.extract(m.text, bot, "direct")
                    return True
                except: return False
        
            async def strategy_2_buttons(self, bot):
                try:
                    msgs = await self.client.get_messages(bot, limit=10)
                    for m in msgs:
                        if m.reply_markup:
                            for row in m.reply_markup.rows:
                                for btn in row.buttons:
                                    if isinstance(btn, KeyboardButtonCallback):
                                        try:
                                            await self.client(GetBotCallbackAnswerRequest(peer=bot, msg_id=m.id, data=btn.data))
                                            await asyncio.sleep(1)
                                            new = await self.client.get_messages(bot, limit=3)
                                            for n in new:
                                                if n.text: self.extract(n.text, bot, "button")
                                        except: pass
                    return True
                except: return False
        
            async def strategy_3_menu(self, bot):
                try:
                    cmds = ['/free', '/test', '/trial', 'Free', 'Test']
                    for c in cmds:
                        await self.client.send_message(bot, c)
                        await asyncio.sleep(1)
                        msgs = await self.client.get_messages(bot, limit=3)
                        for m in msgs:
                            if m.text: self.extract(m.text, bot, "menu")
                    return True
                except: return False
        
            async def strategy_4_history(self, bot):
                try:
                    msgs = await self.client.get_messages(bot, limit=100)
                    for m in msgs:
                        if m.text: self.extract(m.text, bot, "history")
                    return True
                except: return False
        
            async def strategy_5_urls(self, bot):
                try:
                    msgs = await self.client.get_messages(bot, limit=20)
                    for m in msgs:
                        if m.reply_markup:
                            for row in m.reply_markup.rows:
                                for btn in row.buttons:
                                    if isinstance(btn, KeyboardButtonUrl):
                                        self.configs['telegram'].append({'config': btn.url, 'source': bot, 'method': 'url'})
                    return True
                except: return False
        
            def extract(self, text, source, method):
                for typ, pat in CONFIG_PATTERNS.items():
                    for m in pat.findall(text):
                        data = {'config': m, 'type': typ, 'source': source, 'method': method, 'time': datetime.now().isoformat()}
                        if typ in ['tg_proxy']:
                            if data not in self.configs['telegram']: 
                                self.configs['telegram'].append(data)
                                logger.info(f"‚úÖ TG: {m[:50]}...")
                        else:
                            if data not in self.configs['vpn']: 
                                self.configs['vpn'].append(data)
                                logger.info(f"‚úÖ VPN: {m[:50]}...")
                        self.configs['raw'].append(data)
        
            async def attack(self, bot):
                logger.info(f"üéØ Attacking {bot}")
                strategies = [self.strategy_1_direct, self.strategy_2_buttons, self.strategy_3_menu, 
                             self.strategy_4_history, self.strategy_5_urls]
                for s in strategies:
                    try:
                        await s(bot)
                        await asyncio.sleep(random.uniform(1, 3))
                    except: pass
        
            async def run(self):
                await self.init_client()
                for bot in TARGET_BOTS:
                    try:
                        await self.attack(bot)
                        await asyncio.sleep(5)
                    except Exception as e:
                        logger.error(f"Failed {bot}: {e}")
                
                with open('output/telegram/from_bots.txt', 'w') as f:
                    for i in self.configs['telegram']: f.write(f"{i['config']}\n")
                with open('output/vpn/from_bots.json', 'w') as f:
                    json.dump(self.configs['vpn'], f, indent=2)
                
                await self.client.disconnect()
                logger.info(f"üéâ Done: {len(self.configs['telegram'])} TG, {len(self.configs['vpn'])} VPN")
        
        asyncio.run(BotInfiltrator().run())
        SCRIPT1
        
        # ==================== TELEGRAM MONITOR ====================
        cat > scripts/tg_monitor.py << 'SCRIPT2'
        #!/usr/bin/env python3
        import asyncio, json, re, logging
        from datetime import datetime
        from telethon import TelegramClient
        
        API_ID = 38922115
        API_HASH = "b34ae241317eff8743f538a8272c5f6d"
        
        CHANNELS = ["@proxy_mtm", "@free_proxy_vpn", "@vpn_free", "@v2raycollector", "@VmessProtocol",
                   "@DirectVPN", "@freev2rays", "@MTProxies", "@proxy_socks5", "@freeshadowsocks"]
        
        PATTERNS = {
            'vless': re.compile(r'vless://[^\s]+'),
            'vmess': re.compile(r'vmess://[^\s]+'),
            'ss': re.compile(r'ss://[^\s]+'),
            'tg_proxy': re.compile(r'tg://proxy\?[^\s]+'),
        }
        
        logging.basicConfig(level=logging.INFO)
        logger = logging.getLogger(__name__)
        
        class Monitor:
            def __init__(self):
                self.client = None
                self.configs = []
        
            async def init(self):
                self.client = TelegramClient("sessions/mon", API_ID, API_HASH)
                await self.client.start()
        
            async def scan(self, ch):
                logger.info(f"üì° Scanning {ch}")
                try:
                    entity = await self.client.get_entity(ch)
                    msgs = await self.client.get_messages(entity, limit=100)
                    for m in msgs:
                        if m.text:
                            for typ, pat in PATTERNS.items():
                                for match in pat.findall(m.text):
                                    data = {'config': match, 'type': typ, 'source': ch, 'time': datetime.now().isoformat()}
                                    if data not in self.configs:
                                        self.configs.append(data)
                                        logger.info(f"‚úÖ Found {typ}")
                except Exception as e:
                    logger.error(f"Error {ch}: {e}")
        
            async def run(self):
                await self.init()
                for ch in CHANNELS:
                    await self.scan(ch)
                    await asyncio.sleep(2)
                
                tg = [c for c in self.configs if c['type'] == 'tg_proxy']
                vpn = [c for c in self.configs if c['type'] in ['vless','vmess','ss']]
                
                with open('output/telegram/from_channels.txt', 'w') as f:
                    for i in tg: f.write(f"{i['config']}\n")
                with open('output/vpn/from_channels.json', 'w') as f:
                    json.dump(vpn, f, indent=2)
                
                await self.client.disconnect()
                logger.info(f"üéâ Done: {len(tg)} TG, {len(vpn)} VPN")
        
        asyncio.run(Monitor().run())
        SCRIPT2
        
        # ==================== WEB CRAWLER ====================
        cat > scripts/web_crawler.py << 'SCRIPT3'
        #!/usr/bin/env python3
        import asyncio, aiohttp, re, json, logging
        from datetime import datetime
        from bs4 import BeautifulSoup
        
        PATTERNS = {
            'vless': re.compile(r'vless://[^\s]+'),
            'vmess': re.compile(r'vmess://[^\s]+'),
            'ss': re.compile(r'ss://[^\s]+'),
            'tg_proxy': re.compile(r'tg://proxy\?[^\s]+'),
        }
        
        logging.basicConfig(level=logging.INFO)
        logger = logging.getLogger(__name__)
        
        class Crawler:
            def __init__(self):
                self.session = None
                self.configs = []
        
            async def init(self):
                self.session = aiohttp.ClientSession(headers={'User-Agent': 'Mozilla/5.0'})
        
            async def gists(self):
                logger.info("üîç GitHub Gists...")
                queries = ['vless config', 'vmess config', 'v2ray', 'proxy telegram']
                for q in queries:
                    try:
                        url = f"https://gist.github.com/search?q={q.replace(' ', '+')}"
                        async with self.session.get(url) as r:
                            html = await r.text()
                            soup = BeautifulSoup(html, 'html.parser')
                            links = soup.find_all('a', class_='Link--primary')
                            for link in links[:5]:
                                raw = f"https://gist.github.com{link['href']}/raw"
                                try:
                                    async with self.session.get(raw) as gr:
                                        content = await gr.text()
                                        self.extract(content, f"Gist:{q}")
                                except: pass
                        await asyncio.sleep(2)
                    except: pass
        
            async def pastebin(self):
                logger.info("üìã Pastebin...")
                try:
                    async with self.session.get("https://pastebin.com/archive") as r:
                        html = await r.text()
                        soup = BeautifulSoup(html, 'html.parser')
                        links = soup.find_all('a', href=re.compile(r'/[A-Za-z0-9]{8}'))
                        for link in links[:15]:
                            pid = link['href'].strip('/')
                            raw = f"https://pastebin.com/raw/{pid}"
                            try:
                                async with self.session.get(raw) as pr:
                                    content = await pr.text()
                                    if any(k in content.lower() for k in ['vless','vmess','proxy']):
                                        self.extract(content, f"Paste:{pid}")
                            except: pass
                            await asyncio.sleep(0.5)
                except: pass
        
            async def github_repos(self):
                logger.info("üéØ GitHub Repos...")
                urls = [
                    "https://raw.githubusercontent.com/awesome-vpn/awesome-vpn/master/all",
                    "https://raw.githubusercontent.com/freefq/free/master/v2"
                ]
                for url in urls:
                    try:
                        async with self.session.get(url) as r:
                            if r.status == 200:
                                content = await r.text()
                                self.extract(content, url)
                    except: pass
        
            def extract(self, text, source):
                for typ, pat in PATTERNS.items():
                    for m in pat.findall(text):
                        data = {'config': m, 'type': typ, 'source': source, 'time': datetime.now().isoformat()}
                        if data not in self.configs:
                            self.configs.append(data)
                            logger.info(f"‚úÖ {typ}")
        
            async def run(self):
                await self.init()
                await asyncio.gather(self.gists(), self.pastebin(), self.github_repos(), return_exceptions=True)
                
                tg = [c for c in self.configs if c['type'] == 'tg_proxy']
                vpn = [c for c in self.configs if c['type'] in ['vless','vmess','ss']]
                
                with open('output/telegram/from_web.txt', 'w') as f:
                    for i in tg: f.write(f"{i['config']}\n")
                with open('output/vpn/from_web.json', 'w') as f:
                    json.dump(vpn, f, indent=2)
                
                await self.session.close()
                logger.info(f"üéâ Done: {len(tg)} TG, {len(vpn)} VPN")
        
        asyncio.run(Crawler().run())
        SCRIPT3
        
        # ==================== CONFIG MERGER ====================
        cat > scripts/merge.py << 'SCRIPT4'
        #!/usr/bin/env python3
        import json, logging, base64
        from pathlib import Path
        
        logging.basicConfig(level=logging.INFO)
        logger = logging.getLogger(__name__)
        
        # Merge Telegram
        tg_set = set()
        for f in ['output/telegram/from_bots.txt', 'output/telegram/from_channels.txt', 'output/telegram/from_web.txt']:
            try:
                with open(f) as file:
                    for line in file:
                        line = line.strip()
                        if line: tg_set.add(line)
            except: pass
        
        with open('output/telegram/telegram_proxies.txt', 'w') as f:
            for cfg in sorted(tg_set): f.write(f"{cfg}\n")
        
        logger.info(f"‚úÖ Merged {len(tg_set)} Telegram proxies")
        
        # Merge VPN
        vpn_list = []
        seen = set()
        for f in ['output/vpn/from_bots.json', 'output/vpn/from_channels.json', 'output/vpn/from_web.json']:
            try:
                with open(f) as file:
                    data = json.load(file)
                    for item in data:
                        cfg = item.get('config', '')
                        if cfg and cfg not in seen:
                            seen.add(cfg)
                            vpn_list.append(item)
            except: pass
        
        with open('output/vpn/vpn_configs.json', 'w') as f:
            json.dump(vpn_list, f, indent=2)
        
        logger.info(f"‚úÖ Merged {len(vpn_list)} VPN configs")
        
        # All-in-one
        with open('output/raw/all_in_one.txt', 'w') as f:
            f.write("# ===== TELEGRAM PROXIES =====\n")
            for cfg in sorted(tg_set): f.write(f"{cfg}\n")
            f.write("\n# ===== VPN CONFIGS =====\n")
            for item in vpn_list: f.write(f"{item['config']}\n")
        
        # Subscription
        all_vpn = '\n'.join([i['config'] for i in vpn_list])
        sub = base64.b64encode(all_vpn.encode()).decode()
        with open('output/raw/subscription.txt', 'w') as f:
            f.write(sub)
        
        logger.info("üì¶ Created all-in-one and subscription")
        SCRIPT4
        
        # ==================== WEBSITE GENERATOR ====================
        cat > scripts/website.py << 'SCRIPT5'
        #!/usr/bin/env python3
        from datetime import datetime
        
        html = f"""<!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <meta name="viewport" content="width=device-width, initial-scale=1.0">
            <title>üßä ICEBREAKER - Free Proxy & VPN</title>
            <style>
                * {{ margin: 0; padding: 0; box-sizing: border-box; }}
                body {{
                    font-family: 'Segoe UI', sans-serif;
                    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                    color: #fff;
                    min-height: 100vh;
                    padding: 20px;
                }}
                .container {{ max-width: 1200px; margin: 0 auto; }}
                header {{
                    text-align: center;
                    padding: 40px 0;
                    border-bottom: 2px solid rgba(255,255,255,0.2);
                }}
                h1 {{
                    font-size: 3.5em;
                    margin-bottom: 10px;
                    text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
                }}
                .tagline {{
                    font-size: 1.3em;
                    opacity: 0.9;
                }}
                .section {{
                    background: rgba(255,255,255,0.1);
                    backdrop-filter: blur(10px);
                    border-radius: 20px;
                    padding: 40px;
                    margin: 30px 0;
                    border: 1px solid rgba(255,255,255,0.2);
                }}
                h2 {{
                    font-size: 2em;
                    margin-bottom: 20px;
                    color: #ffd700;
                }}
                .download-grid {{
                    display: grid;
                    grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
                    gap: 20px;
                }}
                .download-card {{
                    background: rgba(255,255,255,0.1);
                    padding: 25px;
                    border-radius: 15px;
                    border: 2px solid rgba(255,255,255,0.2);
                    transition: all 0.3s;
                }}
                .download-card:hover {{
                    transform: translateY(-5px);
                    border-color: #ffd700;
                    box-shadow: 0 10px 30px rgba(0,0,0,0.3);
                }}
                .download-card h3 {{
                    color: #ffd700;
                    margin-bottom: 15px;
                }}
                .btn {{
                    display: inline-block;
                    background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
                    color: white;
                    padding: 12px 30px;
                    border-radius: 25px;
                    text-decoration: none;
                    margin: 10px 5px;
                    transition: all 0.3s;
                    border: 2px solid rgba(255,255,255,0.3);
                    font-weight: bold;
                }}
                .btn:hover {{
                    transform: scale(1.05);
                    box-shadow: 0 5px 20px rgba(0,0,0,0.3);
                }}
                .guide {{
                    background: rgba(0,0,0,0.2);
                    padding: 25px;
                    border-radius: 15px;
                    margin: 20px 0;
                    border-left: 4px solid #ffd700;
                }}
                .guide h3 {{ color: #ffd700; margin-bottom: 15px; }}
                .guide ol {{ margin-left: 20px; line-height: 1.8; }}
                footer {{
                    text-align: center;
                    padding: 40px 0;
                    border-top: 2px solid rgba(255,255,255,0.2);
                    margin-top: 40px;
                }}
            </style>
        </head>
        <body>
            <div class="container">
                <header>
                    <h1>üßä ICEBREAKER</h1>
                    <p class="tagline">Your Ultimate Free Proxy & VPN Aggregator</p>
                    <p>Auto-updated every hour | Always fresh configs</p>
                    <p style="margin-top: 10px;">Last update: {datetime.now().strftime('%Y-%m-%d %H:%M UTC')}</p>
                </header>
                
                <div class="section">
                    <h2>üì¶ Download Configs</h2>
                    <div class="download-grid">
                        <div class="download-card">
                            <h3>üì± Telegram Proxies</h3>
                            <p>MTProto & SOCKS5 for Telegram</p>
                            <a href="../releases/latest/download/telegram_proxies.txt" class="btn">Download</a>
                        </div>
                        <div class="download-card">
                            <h3>üöÄ VPN Configs</h3>
                            <p>VLESS, VMess, Shadowsocks, Trojan</p>
                            <a href="../releases/latest/download/vpn_configs.json" class="btn">Download</a>
                        </div>
                        <div class="download-card">
                            <h3>üìã All-in-One</h3>
                            <p>All configs in one file</p>
                            <a href="../releases/latest/download/all_in_one.txt" class="btn">Download</a>
                        </div>
                        <div class="download-card">
                            <h3>üîÑ Subscription</h3>
                            <p>Auto-update link</p>
                            <a href="../releases/latest/download/subscription.txt" class="btn">Get Link</a>
                        </div>
                    </div>
                </div>
                
                <div class="section">
                    <h2>üéì Quick Start Guide</h2>
                    <div class="guide">
                        <h3>For Telegram:</h3>
                        <ol>
                            <li>Download telegram_proxies.txt</li>
                            <li>Open Telegram ‚Üí Settings ‚Üí Data and Storage ‚Üí Proxy</li>
                            <li>Add Proxy and paste any line from file</li>
                            <li>Enable and enjoy!</li>
                        </ol>
                    </div>
                    <div class="guide">
                        <h3>For VPN (Android):</h3>
                        <ol>
                            <li>Install Nekobox or v2rayNG</li>
                            <li>Download vpn_configs.json</li>
                            <li>Import file in app</li>
                            <li>Connect!</li>
                        </ol>
                    </div>
                </div>
                
                <footer>
                    <p>üßä <strong>ICEBREAKER</strong> - Autonomous Proxy Aggregator</p>
                    <p>Built with ‚ù§Ô∏è using GitHub Actions</p>
                </footer>
            </div>
        </body>
        </html>"""
        
        with open('site/index.html', 'w') as f:
            f.write(html)
        
        print("‚úÖ Website generated!")
        SCRIPT5
        
        chmod +x scripts/*.py

    - name: ü§ñ Bot Infiltration
      timeout-minutes: 20
      run: python scripts/bot_infiltrator.py
      continue-on-error: true

    - name: üì° Telegram Monitoring
      timeout-minutes: 15
      run: python scripts/tg_monitor.py
      continue-on-error: true

    - name: üï∏Ô∏è Web Crawling
      timeout-minutes: 15
      run: python scripts/web_crawler.py
      continue-on-error: true

    - name: üîÑ Merge Configs
      run: python scripts/merge.py

    - name: üåê Generate Website
      run: python scripts/website.py

    - name: üìä Count Results
      id: stats
      run: |
        TG_COUNT=$(wc -l < output/telegram/telegram_proxies.txt 2>/dev/null || echo 0)
        VPN_COUNT=$(cat output/vpn/vpn_configs.json 2>/dev/null | grep -c '"config"' || echo 0)
        echo "tg_count=$TG_COUNT" >> $GITHUB_OUTPUT
        echo "vpn_count=$VPN_COUNT" >> $GITHUB_OUTPUT
        echo "timestamp=$(date '+%Y-%m-%d %H:%M UTC')" >> $GITHUB_OUTPUT

    - name: üìù Create Release
      id: release
      run: |
        TAG="update-$(date '+%Y%m%d-%H%M')"
        echo "tag=$TAG" >> $GITHUB_OUTPUT
        
        cat > notes.md << 'EOF'
        # üßä ICEBREAKER Auto-Update
        
        **Timestamp:** TIMESTAMP_PLACEHOLDER
        
        ## üìä Statistics
        - Telegram Proxies: TG_COUNT_PLACEHOLDER
        - VPN Configs: VPN_COUNT_PLACEHOLDER
        
        ## üì¶ Files
        - `telegram_proxies.txt` - MTProto/SOCKS5 proxies
        - `vpn_configs.json` - VPN configurations
        - `all_in_one.txt` - All configs
        - `subscription.txt` - Subscription link
        
        ## üì± Apps
        **Android:** [Nekobox](https://github.com/MatsuriDayo/NekoBoxForAndroid/releases), [v2rayNG](https://github.com/2dust/v2rayNG/releases)
        **iOS:** [Streisand](https://apps.apple.com/app/streisand/id6450534064), [V2BOX](https://apps.apple.com/app/v2box-v2ray-client/id6446814690)
        
        ---
        *Auto-generated by ICEBREAKER*
        EOF
        
        sed -i "s/TIMESTAMP_PLACEHOLDER/$(date '+%Y-%m-%d %H:%M UTC')/g" notes.md
        sed -i "s/TG_COUNT_PLACEHOLDER/${{ steps.stats.outputs.tg_count }}/g" notes.md
        sed -i "s/VPN_COUNT_PLACEHOLDER/${{ steps.stats.outputs.vpn_count }}/g" notes.md

    - name: üéÅ Publish Release
      uses: softprops/action-gh-release@v1
      with:
        tag_name: ${{ steps.release.outputs.tag }}
        name: "Update ${{ steps.stats.outputs.timestamp }}"
        body_path: notes.md
        files: |
          output/telegram/telegram_proxies.txt
          output/vpn/vpn_configs.json
          output/raw/all_in_one.txt
          output/raw/subscription.txt
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

    - name: üåê Deploy Website
      uses: peaceiris/actions-gh-pages@v3
      with:
        github_token: ${{ secrets.GITHUB_TOKEN }}
        publish_dir: ./site
        user_name: 'ICEBREAKER Bot'
        user_email: 'bot@icebreaker.auto'

    - name: ‚úÖ Complete
      run: |
        echo "üéâ ICEBREAKER completed successfully!"
        echo "üìä Telegram: ${{ steps.stats.outputs.tg_count }}"
        echo "üìä VPN: ${{ steps.stats.outputs.vpn_count }}"
        echo "üåê Website: Updated"
        echo "üì¶ Release: Created"
        cat > scripts/bot_infiltrator.py << 'SCRIPT1'
        #!/usr/bin/env python3
        import asyncio, random, json, re, logging
        from datetime import datetime
        from telethon import TelegramClient, events
        from telethon.tl.functions.messages import GetBotCallbackAnswerRequest
        from telethon.tl.types import KeyboardButtonCallback, KeyboardButtonUrl
        
        API_ID = 38922115
        API_HASH = "b34ae241317eff8743f538a8272c5f6d"
        
        TARGET_BOTS = ["@MTProtoProxybot", "@ProxyMTProtoBot", "@socks5_bot", "@vmess_vless_bot", 
                       "@FreeVPNbot", "@v2ray_config_bot", "@shadowsocks_bot", "@proxytelegrambot",
                       "@vpnconfig_bot", "@proxy_seller_bot"]
        
        CONFIG_PATTERNS = {
            'tg_proxy': re.compile(r'(tg://proxy\?[^\s]+)'),
            'vless': re.compile(r'(vless://[^\s]+)'),
            'vmess': re.compile(r'(vmess://[^\s]+)'),
            'ss': re.compile(r'(ss://[^\s]+)'),
            'trojan': re.compile(r'(trojan://[^\s]+)'),
        }
        
        logging.basicConfig(level=logging.INFO)
        logger = logging.getLogger(__name__)
        
        class BotInfiltrator:
            def __init__(self):
                self.client = None
                self.configs = {'telegram': [], 'vpn': [], 'raw': []}
        
            async def init_client(self):
                self.client = TelegramClient("sessions/ice", API_ID, API_HASH)
                await self.client.start()
                logger.info("‚úÖ Client ready")
        
            async def strategy_1_direct(self, bot):
                try:
                    await self.client.send_message(bot, '/start')
                    await asyncio.sleep(2)
                    msgs = await self.client.get_messages(bot, limit=5)
                    for m in msgs:
                        if m.text: self.extract(m.text, bot, "direct")
                    return True
                except: return False
        
            async def strategy_2_buttons(self, bot):
                try:
                    msgs = await self.client.get_messages(bot, limit=10)
                    for m in msgs:
                        if m.reply_markup:
                            for row in m.reply_markup.rows:
                                for btn in row.buttons:
                                    if isinstance(btn, KeyboardButtonCallback):
                                        try:
                                            await self.client(GetBotCallbackAnswerRequest(peer=bot, msg_id=m.id, data=btn.data))
                                            await asyncio.sleep(1)
                                            new = await self.client.get_messages(bot, limit=3)
                                            for n in new:
                                                if n.text: self.extract(n.text, bot, "button")
                                        except: pass
                    return True
                except: return False
        
            async def strategy_3_menu(self, bot):
                try:
                    cmds = ['/free', '/test', '/trial', 'Free', 'Test']
                    for c in cmds:
                        await self.client.send_message(bot, c)
                        await asyncio.sleep(1)
                        msgs = await self.client.get_messages(bot, limit=3)
                        for m in msgs:
                            if m.text: self.extract(m.text, bot, "menu")
                    return True
                except: return False
        
            async def strategy_4_history(self, bot):
                try:
                    msgs = await self.client.get_messages(bot, limit=100)
                    for m in msgs:
                        if m.text: self.extract(m.text, bot, "history")
                    return True
                except: return False
        
            async def strategy_5_urls(self, bot):
                try:
                    msgs = await self.client.get_messages(bot, limit=20)
                    for m in msgs:
                        if m.reply_markup:
                            for row in m.reply_markup.rows:
                                for btn in row.buttons:
                                    if isinstance(btn, KeyboardButtonUrl):
                                        self.configs['telegram'].append({'config': btn.url, 'source': bot, 'method': 'url'})
                    return True
                except: return False
        
            def extract(self, text, source, method):
                for typ, pat in CONFIG_PATTERNS.items():
                    for m in pat.findall(text):
                        data = {'config': m, 'type': typ, 'source': source, 'method': method, 'time': datetime.now().isoformat()}
                        if typ in ['tg_proxy']:
                            if data not in self.configs['telegram']: 
                                self.configs['telegram'].append(data)
                                logger.info(f"‚úÖ TG: {m[:50]}...")
                        else:
                            if data not in self.configs['vpn']: 
                                self.configs['vpn'].append(data)
                                logger.info(f"‚úÖ VPN: {m[:50]}...")
                        self.configs['raw'].append(data)
        
            async def attack(self, bot):
                logger.info(f"üéØ Attacking {bot}")
                strategies = [self.strategy_1_direct, self.strategy_2_buttons, self.strategy_3_menu, 
                             self.strategy_4_history, self.strategy_5_urls]
                for s in strategies:
                    try:
                        await s(bot)
                        await asyncio.sleep(random.uniform(1, 3))
                    except: pass
        
            async def run(self):
                await self.init_client()
                for bot in TARGET_BOTS:
                    try:
                        await self.attack(bot)
                        await asyncio.sleep(5)
                    except Exception as e:
                        logger.error(f"Failed {bot}: {e}")
                
                with open('output/telegram/from_bots.txt', 'w') as f:
                    for i in self.configs['telegram']: f.write(f"{i['config']}\n")
                with open('output/vpn/from_bots.json', 'w') as f:
                    json.dump(self.configs['vpn'], f, indent=2)
                
                await self.client.disconnect()
                logger.info(f"üéâ Done: {len(self.configs['telegram'])} TG, {len(self.configs['vpn'])} VPN")
        
        asyncio.run(BotInfiltrator().run())
        SCRIPT1
        
        # ==================== TELEGRAM MONITOR ====================
        cat > scripts/tg_monitor.py << 'SCRIPT2'
        #!/usr/bin/env python3
        import asyncio, json, re, logging
        from datetime import datetime
        from telethon import TelegramClient
        
        API_ID = 38922115
        API_HASH = "b34ae241317eff8743f538a8272c5f6d"
        
        CHANNELS = ["@proxy_mtm", "@free_proxy_vpn", "@vpn_free", "@v2raycollector", "@VmessProtocol",
                   "@DirectVPN", "@freev2rays", "@MTProxies", "@proxy_socks5", "@freeshadowsocks"]
        
        PATTERNS = {
            'vless': re.compile(r'vless://[^\s]+'),
            'vmess': re.compile(r'vmess://[^\s]+'),
            'ss': re.compile(r'ss://[^\s]+'),
            'tg_proxy': re.compile(r'tg://proxy\?[^\s]+'),
        }
        
        logging.basicConfig(level=logging.INFO)
        logger = logging.getLogger(__name__)
        
        class Monitor:
            def __init__(self):
                self.client = None
                self.configs = []
        
            async def init(self):
                self.client = TelegramClient("sessions/mon", API_ID, API_HASH)
                await self.client.start()
        
            async def scan(self, ch):
                logger.info(f"üì° Scanning {ch}")
                try:
                    entity = await self.client.get_entity(ch)
                    msgs = await self.client.get_messages(entity, limit=100)
                    for m in msgs:
                        if m.text:
                            for typ, pat in PATTERNS.items():
                                for match in pat.findall(m.text):
                                    data = {'config': match, 'type': typ, 'source': ch, 'time': datetime.now().isoformat()}
                                    if data not in self.configs:
                                        self.configs.append(data)
                                        logger.info(f"‚úÖ Found {typ}")
                except Exception as e:
                    logger.error(f"Error {ch}: {e}")
        
            async def run(self):
                await self.init()
                for ch in CHANNELS:
                    await self.scan(ch)
                    await asyncio.sleep(2)
                
                tg = [c for c in self.configs if c['type'] == 'tg_proxy']
                vpn = [c for c in self.configs if c['type'] in ['vless','vmess','ss']]
                
                with open('output/telegram/from_channels.txt', 'w') as f:
                    for i in tg: f.write(f"{i['config']}\n")
                with open('output/vpn/from_channels.json', 'w') as f:
                    json.dump(vpn, f, indent=2)
                
                await self.client.disconnect()
                logger.info(f"üéâ Done: {len(tg)} TG, {len(vpn)} VPN")
        
        asyncio.run(Monitor().run())
        SCRIPT2
        
        # ==================== WEB CRAWLER ====================
        cat > scripts/web_crawler.py << 'SCRIPT3'
        #!/usr/bin/env python3
        import asyncio, aiohttp, re, json, logging
        from datetime import datetime
        from bs4 import BeautifulSoup
        
        PATTERNS = {
            'vless': re.compile(r'vless://[^\s]+'),
            'vmess': re.compile(r'vmess://[^\s]+'),
            'ss': re.compile(r'ss://[^\s]+'),
            'tg_proxy': re.compile(r'tg://proxy\?[^\s]+'),
        }
        
        logging.basicConfig(level=logging.INFO)
        logger = logging.getLogger(__name__)
        
        class Crawler:
            def __init__(self):
                self.session = None
                self.configs = []
        
            async def init(self):
                self.session = aiohttp.ClientSession(headers={'User-Agent': 'Mozilla/5.0'})
        
            async def gists(self):
                logger.info("üîç GitHub Gists...")
                queries = ['vless config', 'vmess config', 'v2ray', 'proxy telegram']
                for q in queries:
                    try:
                        url = f"https://gist.github.com/search?q={q.replace(' ', '+')}"
                        async with self.session.get(url) as r:
                            html = await r.text()
                            soup = BeautifulSoup(html, 'html.parser')
                            links = soup.find_all('a', class_='Link--primary')
                            for link in links[:5]:
                                raw = f"https://gist.github.com{link['href']}/raw"
                                try:
                                    async with self.session.get(raw) as gr:
                                        content = await gr.text()
                                        self.extract(content, f"Gist:{q}")
                                except: pass
                        await asyncio.sleep(2)
                    except: pass
        
            async def pastebin(self):
                logger.info("üìã Pastebin...")
                try:
                    async with self.session.get("https://pastebin.com/archive") as r:
                        html = await r.text()
                        soup = BeautifulSoup(html, 'html.parser')
                        links = soup.find_all('a', href=re.compile(r'/[A-Za-z0-9]{8}'))
                        for link in links[:15]:
                            pid = link['href'].strip('/')
                            raw = f"https://pastebin.com/raw/{pid}"
                            try:
                                async with self.session.get(raw) as pr:
                                    content = await pr.text()
                                    if any(k in content.lower() for k in ['vless','vmess','proxy']):
                                        self.extract(content, f"Paste:{pid}")
                            except: pass
                            await asyncio.sleep(0.5)
                except: pass
        
            async def github_repos(self):
                logger.info("üéØ GitHub Repos...")
                urls = [
                    "https://raw.githubusercontent.com/awesome-vpn/awesome-vpn/master/all",
                    "https://raw.githubusercontent.com/freefq/free/master/v2"
                ]
                for url in urls:
                    try:
                        async with self.session.get(url) as r:
                            if r.status == 200:
                                content = await r.text()
                                self.extract(content, url)
                    except: pass
        
            def extract(self, text, source):
                for typ, pat in PATTERNS.items():
                    for m in pat.findall(text):
                        data = {'config': m, 'type': typ, 'source': source, 'time': datetime.now().isoformat()}
                        if data not in self.configs:
                            self.configs.append(data)
                            logger.info(f"‚úÖ {typ}")
        
            async def run(self):
                await self.init()
                await asyncio.gather(self.gists(), self.pastebin(), self.github_repos(), return_exceptions=True)
                
                tg = [c for c in self.configs if c['type'] == 'tg_proxy']
                vpn = [c for c in self.configs if c['type'] in ['vless','vmess','ss']]
                
                with open('output/telegram/from_web.txt', 'w') as f:
                    for i in tg: f.write(f"{i['config']}\n")
                with open('output/vpn/from_web.json', 'w') as f:
                    json.dump(vpn, f, indent=2)
                
                await self.session.close()
                logger.info(f"üéâ Done: {len(tg)} TG, {len(vpn)} VPN")
        
        asyncio.run(Crawler().run())
        SCRIPT3
        
        # ==================== CONFIG MERGER ====================
        cat > scripts/merge.py << 'SCRIPT4'
        #!/usr/bin/env python3
        import json, logging, base64
        from pathlib import Path
        
        logging.basicConfig(level=logging.INFO)
        logger = logging.getLogger(__name__)
        
        # Merge Telegram
        tg_set = set()
        for f in ['output/telegram/from_bots.txt', 'output/telegram/from_channels.txt', 'output/telegram/from_web.txt']:
            try:
                with open(f) as file:
                    for line in file:
                        line = line.strip()
                        if line: tg_set.add(line)
            except: pass
        
        with open('output/telegram/telegram_proxies.txt', 'w') as f:
            for cfg in sorted(tg_set): f.write(f"{cfg}\n")
        
        logger.info(f"‚úÖ Merged {len(tg_set)} Telegram proxies")
        
        # Merge VPN
        vpn_list = []
        seen = set()
        for f in ['output/vpn/from_bots.json', 'output/vpn/from_channels.json', 'output/vpn/from_web.json']:
            try:
                with open(f) as file:
                    data = json.load(file)
                    for item in data:
                        cfg = item.get('config', '')
                        if cfg and cfg not in seen:
                            seen.add(cfg)
                            vpn_list.append(item)
            except: pass
        
        with open('output/vpn/vpn_configs.json', 'w') as f:
            json.dump(vpn_list, f, indent=2)
        
        logger.info(f"‚úÖ Merged {len(vpn_list)} VPN configs")
        
        # All-in-one
        with open('output/raw/all_in_one.txt', 'w') as f:
            f.write("# ===== TELEGRAM PROXIES =====\n")
            for cfg in sorted(tg_set): f.write(f"{cfg}\n")
            f.write("\n# ===== VPN CONFIGS =====\n")
            for item in vpn_list: f.write(f"{item['config']}\n")
        
        # Subscription
        all_vpn = '\n'.join([i['config'] for i in vpn_list])
        sub = base64.b64encode(all_vpn.encode()).decode()
        with open('output/raw/subscription.txt', 'w') as f:
            f.write(sub)
        
        logger.info("üì¶ Created all-in-one and subscription")
        SCRIPT4
        
        # ==================== WEBSITE GENERATOR ====================
        cat > scripts/website.py << 'SCRIPT5'
        #!/usr/bin/env python3
        from datetime import datetime
        
        html = f"""<!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <meta name="viewport" content="width=device-width, initial-scale=1.0">
            <title>üßä ICEBREAKER - Free Proxy & VPN</title>
            <style>
                * {{ margin: 0; padding: 0; box-sizing: border-box; }}
                body {{
                    font-family: 'Segoe UI', sans-serif;
                    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                    color: #fff;
                    min-height: 100vh;
                    padding: 20px;
                }}
                .container {{ max-width: 1200px; margin: 0 auto; }}
                header {{
                    text-align: center;
                    padding: 40px 0;
                    border-bottom: 2px solid rgba(255,255,255,0.2);
                }}
                h1 {{
                    font-size: 3.5em;
                    margin-bottom: 10px;
                    text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
                }}
                .tagline {{
                    font-size: 1.3em;
                    opacity: 0.9;
                }}
                .section {{
                    background: rgba(255,255,255,0.1);
                    backdrop-filter: blur(10px);
                    border-radius: 20px;
                    padding: 40px;
                    margin: 30px 0;
                    border: 1px solid rgba(255,255,255,0.2);
                }}
                h2 {{
                    font-size: 2em;
                    margin-bottom: 20px;
                    color: #ffd700;
                }}
                .download-grid {{
                    display: grid;
                    grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
                    gap: 20px;
                }}
                .download-card {{
                    background: rgba(255,255,255,0.1);
                    padding: 25px;
                    border-radius: 15px;
                    border: 2px solid rgba(255,255,255,0.2);
                    transition: all 0.3s;
                }}
                .download-card:hover {{
                    transform: translateY(-5px);
                    border-color: #ffd700;
                    box-shadow: 0 10px 30px rgba(0,0,0,0.3);
                }}
                .download-card h3 {{
                    color: #ffd700;
                    margin-bottom: 15px;
                }}
                .btn {{
                    display: inline-block;
                    background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
                    color: white;
                    padding: 12px 30px;
                    border-radius: 25px;
                    text-decoration: none;
                    margin: 10px 5px;
                    transition: all 0.3s;
                    border: 2px solid rgba(255,255,255,0.3);
                    font-weight: bold;
                }}
                .btn:hover {{
                    transform: scale(1.05);
                    box-shadow: 0 5px 20px rgba(0,0,0,0.3);
                }}
                .guide {{
                    background: rgba(0,0,0,0.2);
                    padding: 25px;
                    border-radius: 15px;
                    margin: 20px 0;
                    border-left: 4px solid #ffd700;
                }}
                .guide h3 {{ color: #ffd700; margin-bottom: 15px; }}
                .guide ol {{ margin-left: 20px; line-height: 1.8; }}
                footer {{
                    text-align: center;
                    padding: 40px 0;
                    border-top: 2px solid rgba(255,255,255,0.2);
                    margin-top: 40px;
                }}
            </style>
        </head>
        <body>
            <div class="container">
                <header>
                    <h1>üßä ICEBREAKER</h1>
                    <p class="tagline">Your Ultimate Free Proxy & VPN Aggregator</p>
                    <p>Auto-updated every hour | Always fresh configs</p>
                    <p style="margin-top: 10px;">Last update: {datetime.now().strftime('%Y-%m-%d %H:%M UTC')}</p>
                </header>
                
                <div class="section">
                    <h2>üì¶ Download Configs</h2>
                    <div class="download-grid">
                        <div class="download-card">
                            <h3>üì± Telegram Proxies</h3>
                            <p>MTProto & SOCKS5 for Telegram</p>
                            <a href="../releases/latest/download/telegram_proxies.txt" class="btn">Download</a>
                        </div>
                        <div class="download-card">
                            <h3>üöÄ VPN Configs</h3>
                            <p>VLESS, VMess, Shadowsocks, Trojan</p>
                            <a href="../releases/latest/download/vpn_configs.json" class="btn">Download</a>
                        </div>
                        <div class="download-card">
                            <h3>üìã All-in-One</h3>
                            <p>All configs in one file</p>
                            <a href="../releases/latest/download/all_in_one.txt" class="btn">Download</a>
                        </div>
                        <div class="download-card">
                            <h3>üîÑ Subscription</h3>
                            <p>Auto-update link</p>
                            <a href="../releases/latest/download/subscription.txt" class="btn">Get Link</a>
                        </div>
                    </div>
                </div>
                
                <div class="section">
                    <h2>üéì Quick Start Guide</h2>
                    <div class="guide">
                        <h3>For Telegram:</h3>
                        <ol>
                            <li>Download telegram_proxies.txt</li>
                            <li>Open Telegram ‚Üí Settings ‚Üí Data and Storage ‚Üí Proxy</li>
                            <li>Add Proxy and paste any line from file</li>
                            <li>Enable and enjoy!</li>
                        </ol>
                    </div>
                    <div class="guide">
                        <h3>For VPN (Android):</h3>
                        <ol>
                            <li>Install Nekobox or v2rayNG</li>
                            <li>Download vpn_configs.json</li>
                            <li>Import file in app</li>
                            <li>Connect!</li>
                        </ol>
                    </div>
                </div>
                
                <footer>
                    <p>üßä <strong>ICEBREAKER</strong> - Autonomous Proxy Aggregator</p>
                    <p>Built with ‚ù§Ô∏è using GitHub Actions</p>
                </footer>
            </div>
        </body>
        </html>"""
        
        with open('site/index.html', 'w') as f:
            f.write(html)
        
        print("‚úÖ Website generated!")
        SCRIPT5
        
        chmod +x scripts/*.py

    - name: ü§ñ Bot Infiltration
      timeout-minutes: 20
      run: python scripts/bot_infiltrator.py
      continue-on-error: true

    - name: üì° Telegram Monitoring
      timeout-minutes: 15
      run: python scripts/tg_monitor.py
      continue-on-error: true

    - name: üï∏Ô∏è Web Crawling
      timeout-minutes: 15
      run: python scripts/web_crawler.py
      continue-on-error: true

    - name: üîÑ Merge Configs
      run: python scripts/merge.py

    - name: üåê Generate Website
      run: python scripts/website.py

    - name: üìä Count Results
      id: stats
      run: |
        TG_COUNT=$(wc -l < output/telegram/telegram_proxies.txt || echo 0)
        VPN_COUNT=$(cat output/vpn/vpn_configs.json | grep -c '"config"' || echo 0)
        echo "tg_count=$TG_COUNT" >> $GITHUB_OUTPUT
        echo "vpn_count=$VPN_COUNT" >> $GITHUB_OUTPUT
        echo "timestamp=$(date '+%Y-%m-%d %H:%M UTC')" >> $GITHUB_OUTPUT

    - name: üìù Create Release
      id: release
      run: |
        TAG="update-$(date '+%Y%m%d-%H%M')"
        echo "tag=$TAG" >> $GITHUB_OUTPUT
        
        cat > notes.md << EOF
        # üßä ICEBREAKER Auto-Update
        
        **Timestamp:** $(date '+%Y-%m-%d %H:%M UTC')
        
        ## üìä Statistics
        - Telegram Proxies: ${{ steps.stats.outputs.tg_count }}
        - VPN Configs: ${{ steps.stats.outputs.vpn_count }}
        
        ## üì¶ Files
        - \`telegram_proxies.txt\` - MTProto/SOCKS5 proxies
        - \`vpn_configs.json\` - VPN configurations
        - \`all_in_one.txt\` - All configs
        - \`subscription.txt\` - Subscription link
        
        ## üì± Apps
        **Android:** [Nekobox](https://github.com/MatsuriDayo/NekoBoxForAndroid/releases), [v2rayNG](https://github.com/2dust/v2rayNG/releases)
        **iOS:** [Streisand](https://apps.apple.com/app/streisand/id6450534064), [V2BOX](https://apps.apple.com/app/v2box-v2ray-client/id6446814690)
        
        ---
        *Auto-generated by ICEBREAKER*
        EOF

    - name: üéÅ Publish Release
      uses: softprops/action-gh-release@v1
      with:
        tag_name: ${{ steps.release.outputs.tag }}
        name: "Update ${{ steps.stats.outputs.timestamp }}"
        body_path: notes.md
        files: |
          output/telegram/telegram_proxies.txt
          output/vpn/vpn_configs.json
          output/raw/all_in_one.txt
          output/raw/subscription.txt
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

    - name: üåê Deploy Website
      uses: peaceiris/actions-gh-pages@v3
      with:
        github_token: ${{ secrets.GITHUB_TOKEN }}
        publish_dir: ./site
        user_name: 'ICEBREAKER Bot'
        user_email: 'bot@icebreaker.auto'

    - name: ‚úÖ Complete
      run: |
        echo "üéâ ICEBREAKER completed successfully!"
        echo "üìä Telegram: ${{ steps.stats.outputs.tg_count }}"
        echo "üìä VPN: ${{ steps.stats.outputs.vpn_count }}"
        echo "üåê Website: Updated"
        echo "üì¶ Release: Created"
        async def main():
            client = TelegramClient('session', int(os.getenv('API_ID')), os.getenv('API_HASH'))
            await client.connect()
            
            configs = set()
            channels = ['@proxy_list', '@v2ray_configs', '@free_proxy', '@vpn_configs']
            
            for ch in channels:
                try:
                    entity = await client.get_entity(ch)
                    messages = await client.get_messages(entity, limit=30)
                    
                    for msg in messages:
                        if msg.text:
                            patterns = [
                                r'(vless://[^\s<>]+)',
                                r'(vmess://[^\s<>]+)',
                                r'(ss://[^\s<>]+)',
                                r'(trojan://[^\s<>]+)',
                                r'(tg://proxy\?[^\s<>]+)'
                            ]
                            for pattern in patterns:
                                configs.update(re.findall(pattern, msg.text, re.IGNORECASE))
                    
                    await asyncio.sleep(2)
                except Exception as e:
                    print(f"Error with {ch}: {e}")
            
            await client.disconnect()
            
            tg_proxies = [c for c in configs if 'tg://' in c]
            vpn_configs = [c for c in configs if c not in tg_proxies]
            
            with open('telegram_proxies.txt', 'w') as f:
                f.write('\n'.join(tg_proxies))
            
            with open('vpn_configs.txt', 'w') as f:
                f.write('\n'.join(vpn_configs))
            
            with open('all_configs.txt', 'w') as f:
                f.write('\n'.join(configs))
            
            stats = {
                'timestamp': datetime.now().isoformat(),
                'total': len(configs),
                'telegram': len(tg_proxies),
                'vpn': len(vpn_configs)
            }
            
            with open('stats.json', 'w') as f:
                json.dump(stats, f, indent=2)
            
            print(f"Found {len(configs)} configs")
        
        asyncio.run(main())
        PYSCRIPT
        
    - name: Dashboard
      run: |
        python3 - <<'PYSCRIPT'
        import json
        import qrcode
        import base64
        from io import BytesIO
        
        def generate_qr(data):
            qr = qrcode.QRCode(version=1, box_size=8, border=2)
            qr.add_data(data)
            qr.make(fit=True)
            img = qr.make_image(fill_color="#00ff9d", back_color="#0a0c0f")
            buf = BytesIO()
            img.save(buf, format="PNG")
            return f"data:image/png;base64,{base64.b64encode(buf.getvalue()).decode()}"
        
        try:
            with open('stats.json') as f:
                stats = json.load(f)
            with open('all_configs.txt') as f:
                configs = [line.strip() for line in f if line.strip()]
        except:
            stats = {'timestamp': '', 'total': 0, 'telegram': 0, 'vpn': 0}
            configs = []
        
        cards_html = ''
        for i, cfg in enumerate(configs[:12]):
            cfg_type = 'telegram' if 'tg://' in cfg else 'vpn'
            qr_code = generate_qr(cfg)
            short_cfg = cfg[:45] + '...' if len(cfg) > 45 else cfg
            
            cards_html += f'''
            <div class="card" data-type="{cfg_type}">
              <div class="type">{cfg_type.upper()}</div>
              <img src="{qr_code}" class="qr">
              <code>{short_cfg}</code>
              <button onclick="navigator.clipboard.writeText('{cfg.replace("'", "\\'")}').then(() => alert('Copied!'))">Copy</button>
            </div>
            '''
        
        html = f'''<!DOCTYPE html>
        <html>
        <head>
          <meta charset="UTF-8">
          <meta name="viewport" content="width=device-width, initial-scale=1.0">
          <title>ICEBREAKER</title>
          <style>
            * {{ margin: 0; padding: 0; box-sizing: border-box; }}
            body {{ font-family: system-ui; background: #000; color: #fff; padding: 20px; }}
            .header {{ text-align: center; margin: 40px 0; }}
            .header h1 {{ font-size: 3em; color: #0f0; }}
            .stats {{ display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 20px; margin: 30px 0; }}
            .stat {{ background: #111; padding: 20px; border-radius: 10px; text-align: center; }}
            .stat-value {{ font-size: 2em; color: #0f0; }}
            .grid {{ display: grid; grid-template-columns: repeat(auto-fill, minmax(250px, 1fr)); gap: 15px; }}
            .card {{ background: #111; padding: 15px; border-radius: 10px; }}
            .type {{ display: inline-block; padding: 5px 10px; background: rgba(0,255,0,0.2); border-radius: 5px; color: #0f0; font-size: 0.8em; }}
            .qr {{ width: 100px; display: block; margin: 10px auto; }}
            code {{ display: block; background: #000; padding: 8px; border-radius: 5px; font-size: 0.7em; word-break: break-all; margin: 10px 0; }}
            button {{ width: 100%; padding: 10px; background: #0f0; color: #000; border: none; border-radius: 5px; cursor: pointer; font-weight: bold; }}
            button:hover {{ opacity: 0.8; }}
            .sub {{ margin-top: 40px; background: #111; padding: 20px; border-radius: 10px; }}
            .sub h3 {{ color: #0f0; margin-bottom: 10px; }}
            .sub code {{ background: #000; }}
          </style>
        </head>
        <body>
          <div class="header">
            <h1>üßä ICEBREAKER</h1>
            <p>Free Internet Station</p>
          </div>
          
          <div class="stats">
            <div class="stat">
              <div class="stat-value">{stats['total']}</div>
              <div>Total Configs</div>
            </div>
            <div class="stat">
              <div class="stat-value">{stats['telegram']}</div>
              <div>Telegram</div>
            </div>
            <div class="stat">
              <div class="stat-value">{stats['vpn']}</div>
              <div>VPN</div>
            </div>
          </div>
          
          <h2 style="margin: 30px 0; color: #0f0;">Available Configs</h2>
          <div class="grid">
            {cards_html}
          </div>
          
          <div class="sub">
            <h3>üì° Subscription URLs</h3>
            <p>Telegram: <code>https://raw.githubusercontent.com/${{{{ github.repository }}}}/main/telegram_proxies.txt</code></p>
            <p>VPN: <code>https://raw.githubusercontent.com/${{{{ github.repository }}}}/main/vpn_configs.txt</code></p>
            <p>All: <code>https://raw.githubusercontent.com/${{{{ github.repository }}}}/main/all_configs.txt</code></p>
          </div>
        </body>
        </html>'''
        
        with open('index.html', 'w') as f:
            f.write(html)
        
        print("Dashboard created")
        PYSCRIPT
        
    - name: Release
      run: |
        TAG="v$(date +%s)"
        TOTAL=$(wc -l < all_configs.txt || echo 0)
        TG=$(wc -l < telegram_proxies.txt || echo 0)
        VPN=$(wc -l < vpn_configs.txt || echo 0)
        
        NOTES="Update $(date '+%Y-%m-%d %H:%M')
        
        Total: $TOTAL
        Telegram: $TG
        VPN: $VPN"
        
        gh release create "$TAG" \
          --title "Update $(date '+%Y-%m-%d %H:%M')" \
          --notes "$NOTES" \
          telegram_proxies.txt \
          vpn_configs.txt \
          all_configs.txt \
          stats.json || echo "Release creation completed"
      env:
        GH_TOKEN: ${{ github.token }}
        
    - name: Deploy
      run: |
        git config user.name "ICEBREAKER Bot"
        git config user.email "bot@github.com"
        
        mkdir -p docs
        cp index.html docs/
        
        git add -A
        git diff --quiet && git diff --staged --quiet || git commit -m "Update $(date +%s)"
        git push || echo "Push completed"
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

